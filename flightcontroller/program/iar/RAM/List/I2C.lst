###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       18/Jun/2018  19:47:58
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\I2C.c
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW1DA3.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\I2C.c
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List\I2C.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj\I2C.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\I2C.c
      1          /*
      2           * @file I2C.c
      3           * @version 3.02[By LPLD]
      4           * @date 2013-11-22
      5           * @brief I2C底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn)
   \                     _ZN26_INTERNAL_5_I2C_c_I2C_Init16__NVIC_EnableIRQE4IRQn: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0xe000e100
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0x095B             LSRS     R3,R3,#+5
   \   00000018   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn)
   \                     _ZN26_INTERNAL_5_I2C_c_I2C_Init17__NVIC_DisableIRQE4IRQn: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD40A             BMI.N    ??__NVIC_DisableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0xe000e180
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0x095B             LSRS     R3,R3,#+5
   \   00000018   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
     24          #include "I2C.h"
     25          

   \                                 In section .bss, align 4
     26          int I2C_Timeout_myCont;
   \                     I2C_Timeout_myCont:
   \   00000000                      DS8 4
     27          
     28          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     29          I2C_ISR_CALLBACK I2C_ISR[2];
   \                     I2C_ISR:
   \   00000000                      DS8 8
     30          
     31          /*
     32           * I2C_Init
     33           * I2C通用初始化函数，在该函数中选择I2C通道，选择I2C SCK总线频率，
     34           * 选择I2C SDA 和 I2C SCL的引脚，配置I2C的中断回调函数
     35           * 
     36           * 参数:
     37           *    I2C_InitTypeDef--i2c_init_structure
     38           *                     具体定义见I2C_InitTypeDef
     39           * 输出:
     40           *    0--配置错误
     41           *    1--配置成功
     42           */

   \                                 In section .text, align 2, keep-with-next
     43          uint8 I2C_Init(I2C_InitTypeDef i2c_init_structure)
     44          {
   \                     I2C_Init: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
     45            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000004   0x9C00             LDR      R4,[SP, #+0]
     46            uint8 bus_speed = i2c_init_structure.I2C_ICR;
   \   00000006   0xF89D 0x5004      LDRB     R5,[SP, #+4]
     47            PortPinsEnum_Type scl_pin = i2c_init_structure.I2C_SclPin;
   \   0000000A   0xF89D 0x6006      LDRB     R6,[SP, #+6]
     48            PortPinsEnum_Type sda_pin = i2c_init_structure.I2C_SdaPin;
   \   0000000E   0xF89D 0x7007      LDRB     R7,[SP, #+7]
     49            I2C_ISR_CALLBACK isr_func = i2c_init_structure.I2C_Isr;
   \   00000012   0xF8DD 0x800C      LDR      R8,[SP, #+12]
     50            boolean ode = i2c_init_structure.I2C_OpenDrainEnable;
   \   00000016   0xF89D 0x9008      LDRB     R9,[SP, #+8]
     51            uint8 ode_mask = 0;
   \   0000001A   0xF05F 0x0A00      MOVS     R10,#+0
     52          
     53            //参数检查，判断SCL频率
     54            ASSERT( bus_speed <= 0x3F);
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D40             CMP      R5,#+64
   \   00000022   0xDB04             BLT.N    ??I2C_Init_0
   \   00000024   0x2136             MOVS     R1,#+54
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000002A   0x.... 0x....      BL       assert_failed
     55            
     56            if(ode == TRUE)
   \                     ??I2C_Init_0: (+1)
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000032   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000036   0xD101             BNE.N    ??I2C_Init_1
     57            {
     58              ode_mask = PORT_PCR_ODE_MASK;
   \   00000038   0x2020             MOVS     R0,#+32
   \   0000003A   0x4682             MOV      R10,R0
     59            }
     60          
     61            if(i2cx == I2C0)
   \                     ??I2C_Init_1: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40066000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD140             BNE.N    ??I2C_Init_2
     62            {
     63          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10) 
     64              SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK; //开启I2C0时钟
     65          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
     66              SIM->SCGC4 |= SIM_SCGC4_IIC0_MASK; //开启I2C0时钟
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40048034
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable8_4  ;; 0x40048034
   \   00000052   0x6008             STR      R0,[R1, #+0]
     67          #endif 
     68              if(scl_pin == PTD8)
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x2E64             CMP      R6,#+100
   \   00000058   0xD107             BNE.N    ??I2C_Init_3
     69              {
     70                PORTD->PCR[8] = PORT_PCR_MUX(2) | ode_mask;         
   \   0000005A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005E   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x4004c020
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE011             B.N      ??I2C_Init_4
     71              }
     72              else if(scl_pin == PTB0) 
   \                     ??I2C_Init_3: (+1)
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0x2E20             CMP      R6,#+32
   \   0000006E   0xD107             BNE.N    ??I2C_Init_5
     73              {
     74                PORTB->PCR[0] = PORT_PCR_MUX(2) | ode_mask;
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x4004a000
   \   0000007C   0x6008             STR      R0,[R1, #+0]
   \   0000007E   0xE006             B.N      ??I2C_Init_4
     75              }
     76              else //scl_pin = PTB2
     77              {
     78                PORTB->PCR[2] = PORT_PCR_MUX(2) | ode_mask;
   \                     ??I2C_Init_5: (+1)
   \   00000080   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000084   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x4004a008
   \   0000008C   0x6008             STR      R0,[R1, #+0]
     79              }
     80          
     81              if(sda_pin == PTD9)
   \                     ??I2C_Init_4: (+1)
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x2F65             CMP      R7,#+101
   \   00000092   0xD107             BNE.N    ??I2C_Init_6
     82              {
     83                PORTD->PCR[9] = PORT_PCR_MUX(2) | ode_mask;
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable8_8  ;; 0x4004c024
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0xE03C             B.N      ??I2C_Init_7
     84              }
     85              else if(sda_pin == PTB1) 
   \                     ??I2C_Init_6: (+1)
   \   000000A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A6   0x2F21             CMP      R7,#+33
   \   000000A8   0xD106             BNE.N    ??I2C_Init_8
     86              {
     87                PORTB->PCR[1] = PORT_PCR_MUX(2) | ode_mask;
   \   000000AA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000AE   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   000000B2   0x....             LDR.N    R1,??DataTable8_9  ;; 0x4004a004
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   \   000000B6   0xE032             B.N      ??I2C_Init_7
     88              }
     89              else //sda_pin = PTB3
     90              {
     91                PORTB->PCR[3] = PORT_PCR_MUX(2) | ode_mask; 
   \                     ??I2C_Init_8: (+1)
   \   000000B8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000BC   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   000000C0   0x....             LDR.N    R1,??DataTable8_10  ;; 0x4004a00c
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE02B             B.N      ??I2C_Init_7
     92              }
     93            }
     94            else if(i2cx == I2C1)
   \                     ??I2C_Init_2: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40067000
   \   000000C8   0x4284             CMP      R4,R0
   \   000000CA   0xD126             BNE.N    ??I2C_Init_9
     95            { 
     96          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)  
     97              SIM->SCGC4 |= SIM_SCGC4_I2C1_MASK; //开启I2C0时钟
     98          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
     99              SIM->SCGC4 |= SIM_SCGC4_IIC1_MASK; //开启I2C0时钟
   \   000000CC   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40048034
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000D4   0x....             LDR.N    R1,??DataTable8_4  ;; 0x40048034
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    100          #endif
    101          
    102              if(scl_pin == PTE1)
   \   000000D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DA   0x2E7D             CMP      R6,#+125
   \   000000DC   0xD106             BNE.N    ??I2C_Init_10
    103              {
    104                PORTE->PCR[1] = PORT_PCR_MUX(6) | ode_mask;         
   \   000000DE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000E2   0xF45A 0x60C0      ORRS     R0,R10,#0x600
   \   000000E6   0x....             LDR.N    R1,??DataTable8_12  ;; 0x4004d004
   \   000000E8   0x6008             STR      R0,[R1, #+0]
   \   000000EA   0xE005             B.N      ??I2C_Init_11
    105              }
    106              else //scl_pin = PTC10
    107              {
    108                PORTC->PCR[10] = PORT_PCR_MUX(2) | ode_mask;  
   \                     ??I2C_Init_10: (+1)
   \   000000EC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F0   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   000000F4   0x....             LDR.N    R1,??DataTable8_13  ;; 0x4004b028
   \   000000F6   0x6008             STR      R0,[R1, #+0]
    109              }
    110          
    111              if(sda_pin == PTE0)
   \                     ??I2C_Init_11: (+1)
   \   000000F8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FA   0x2F7C             CMP      R7,#+124
   \   000000FC   0xD106             BNE.N    ??I2C_Init_12
    112              {
    113                PORTE->PCR[0] = PORT_PCR_MUX(6) | ode_mask;
   \   000000FE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000102   0xF45A 0x60C0      ORRS     R0,R10,#0x600
   \   00000106   0x....             LDR.N    R1,??DataTable8_14  ;; 0x4004d000
   \   00000108   0x6008             STR      R0,[R1, #+0]
   \   0000010A   0xE008             B.N      ??I2C_Init_7
    114              }
    115              else //sda_pin = PTC11
    116              {
    117                PORTC->PCR[11] = PORT_PCR_MUX(2) | ode_mask; 
   \                     ??I2C_Init_12: (+1)
   \   0000010C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000110   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   00000114   0x....             LDR.N    R1,??DataTable8_15  ;; 0x4004b02c
   \   00000116   0x6008             STR      R0,[R1, #+0]
   \   00000118   0xE001             B.N      ??I2C_Init_7
    118              }
    119            }
    120            else
    121              return 0;
   \                     ??I2C_Init_9: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xE022             B.N      ??I2C_Init_13
    122            
    123            if(i2c_init_structure.I2C_IntEnable == TRUE && isr_func != NULL)
   \                     ??I2C_Init_7: (+1)
   \   0000011E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xD116             BNE.N    ??I2C_Init_14
   \   00000126   0x4640             MOV      R0,R8
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD013             BEQ.N    ??I2C_Init_14
    124            {
    125              //产生I2C中断的中断源：
    126              //1,完成1个字节传输时，IICIF置位产生中断;
    127              //2,当Calling Address匹配成功时产生中断，参考K60文档1456页I2Cx_S寄存器IAAS位;
    128              //3,从机模式下当总线仲裁丢失时，IICIF置位产生中断;
    129              //  需要同时写1清除II2Cx_S的ARBL标志位和 I2Cx_S的 IICIF的标志位;
    130              //4,如果SMB寄存器的SHTF2 interrupt使能，当SHTF2 timeout时IICIF置位产生中断;
    131              //  需要同时写1清除I2Cx_SMB的SLTF标志位和 I2Cx_S的 IICIF的标志位;
    132              //5,当SLT寄存器不为0时，SMBus的SCL low timer计数等于SLT的值时IICIF置位产生中断;
    133              //  需要同时写1清除I2Cx_SMB的SHTF2标志位和 I2Cx_S的 IICIF的标志位;
    134              //6,当Wakeup 使能，I2C在停止模式下接收到Wakeup信号，将产生中断.
    135          
    136              i2cx->C1 |= I2C_C1_IICIE_MASK;
   \   0000012C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000012E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000132   0x70A0             STRB     R0,[R4, #+2]
    137          
    138              if(i2cx == I2C0)
   \   00000134   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40066000
   \   00000136   0x4284             CMP      R4,R0
   \   00000138   0xD103             BNE.N    ??I2C_Init_15
    139              {
    140                I2C_ISR[0] = isr_func;
   \   0000013A   0x....             LDR.N    R0,??DataTable8_16
   \   0000013C   0xF8C0 0x8000      STR      R8,[R0, #+0]
   \   00000140   0xE008             B.N      ??I2C_Init_14
    141              }
    142              else if(i2cx == I2C0)
   \                     ??I2C_Init_15: (+1)
   \   00000142   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40066000
   \   00000144   0x4284             CMP      R4,R0
   \   00000146   0xD103             BNE.N    ??I2C_Init_16
    143              {
    144                I2C_ISR[1] = isr_func;
   \   00000148   0x....             LDR.N    R0,??DataTable8_16
   \   0000014A   0xF8C0 0x8004      STR      R8,[R0, #+4]
   \   0000014E   0xE001             B.N      ??I2C_Init_14
    145              }
    146              else 
    147                return 0;
   \                     ??I2C_Init_16: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xE007             B.N      ??I2C_Init_13
    148            }
    149          
    150            //i2cx->C2 |= I2C_C2_HDRS_MASK;      //提高I2C驱动能力
    151            i2cx->F  = I2C_F_ICR(bus_speed)|I2C_F_MULT(0);   //配置I2Cx SCL BusSpeed
   \                     ??I2C_Init_14: (+1)
   \   00000154   0xF015 0x003F      ANDS     R0,R5,#0x3F
   \   00000158   0x7060             STRB     R0,[R4, #+1]
    152            i2cx->C1 |= I2C_C1_IICEN_MASK;      //使能I2Cx
   \   0000015A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000015C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000160   0x70A0             STRB     R0,[R4, #+2]
    153            
    154            return 1;
   \   00000162   0x2001             MOVS     R0,#+1
   \                     ??I2C_Init_13: (+1)
   \   00000164   0xB004             ADD      SP,SP,#+16
   \   00000166   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    155          }
    156          
    157          /*
    158           * I2C_Deinit
    159           * I2C模块反初始化函数，在该函数中关闭I2Cx的外设总线时钟，关闭I2C模块的
    160           * 时钟，禁止外设中断。
    161           *
    162           * 参数:
    163           *    I2C_InitTypeDef--i2c_init_structure
    164           *                     具体定义见I2C_InitTypeDef
    165           *
    166           * 输出:
    167           *    无
    168           *
    169           */  

   \                                 In section .text, align 2, keep-with-next
    170          uint8 I2C_Deinit(I2C_InitTypeDef i2c_init_structure)
    171          {
   \                     I2C_Deinit: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    172            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    173          
    174            i2cx->C1 &= ~I2C_C1_IICEN_MASK;      //I2Cx
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000000A   0x70A0             STRB     R0,[R4, #+2]
    175            if(i2cx == I2C0)
   \   0000000C   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40066000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD109             BNE.N    ??I2C_Deinit_0
    176            {
    177          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)  
    178              SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK; //开启I2C0时钟
    179          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
    180              SIM->SCGC4 |= SIM_SCGC4_IIC0_MASK; //开启I2C0时钟
   \   00000012   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40048034
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000001A   0x....             LDR.N    R1,??DataTable8_4  ;; 0x40048034
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    181          #endif
    182              disable_irq((IRQn_Type)I2C0_IRQn);
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init17__NVIC_DisableIRQE4IRQn
   \   00000024   0xE00E             B.N      ??I2C_Deinit_1
    183            }
    184            else if (i2cx == I2C1)
   \                     ??I2C_Deinit_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40067000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD109             BNE.N    ??I2C_Deinit_2
    185            {
    186          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)  
    187              SIM->SCGC4 |= SIM_SCGC4_I2C1_MASK; //开启I2C0时钟
    188          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
    189              SIM->SCGC4 |= SIM_SCGC4_IIC1_MASK; //开启I2C0时钟
   \   0000002C   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40048034
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000034   0x....             LDR.N    R1,??DataTable8_4  ;; 0x40048034
   \   00000036   0x6008             STR      R0,[R1, #+0]
    190          #endif
    191              disable_irq((IRQn_Type)I2C1_IRQn);
   \   00000038   0x2019             MOVS     R0,#+25
   \   0000003A   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init17__NVIC_DisableIRQE4IRQn
   \   0000003E   0xE001             B.N      ??I2C_Deinit_1
    192            }
    193            else
    194            {
    195              return 0;
   \                     ??I2C_Deinit_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE000             B.N      ??I2C_Deinit_3
    196            }
    197            return 1;
   \                     ??I2C_Deinit_1: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \                     ??I2C_Deinit_3: (+1)
   \   00000046   0xB004             ADD      SP,SP,#+16
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    198          }
    199          
    200          /*
    201           * I2C_EnableIrq
    202           * I2C外设中断使能
    203           *
    204           * 参数:
    205           *    I2C_InitTypeDef--i2c_init_structure
    206           *                     具体定义见I2C_InitTypeDef
    207           *
    208           * 输出:
    209           *    无
    210           *
    211           */  

   \                                 In section .text, align 2, keep-with-next
    212          void I2C_EnableIrq(I2C_InitTypeDef i2c_init_structure)
    213          {
   \                     I2C_EnableIrq: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    214            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx; 
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    215          
    216            if(i2cx == I2C0)
   \   00000004   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40066000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD103             BNE.N    ??I2C_EnableIrq_0
    217            {
    218              enable_irq((IRQn_Type)I2C0_IRQn);
   \   0000000A   0x2018             MOVS     R0,#+24
   \   0000000C   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init16__NVIC_EnableIRQE4IRQn
   \   00000010   0xE007             B.N      ??I2C_EnableIrq_1
    219            }
    220            else if (i2cx == I2C1)
   \                     ??I2C_EnableIrq_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40067000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD103             BNE.N    ??I2C_EnableIrq_2
    221            {
    222              enable_irq((IRQn_Type)I2C1_IRQn);
   \   00000018   0x2019             MOVS     R0,#+25
   \   0000001A   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init16__NVIC_EnableIRQE4IRQn
   \   0000001E   0xE000             B.N      ??I2C_EnableIrq_1
    223            }
    224            else
    225            {
    226              return;
   \                     ??I2C_EnableIrq_2: (+1)
   \   00000020   0xE7FF             B.N      ??I2C_EnableIrq_3
    227            }
    228          }
   \                     ??I2C_EnableIrq_1: (+1)
   \                     ??I2C_EnableIrq_3: (+1)
   \   00000022   0xBD1F             POP      {R0-R4,PC}       ;; return
    229          
    230          /*
    231           * I2C_DisableIrq
    232           * 禁止I2C外设中断
    233           *
    234           * 参数:
    235           *    I2C_InitTypeDef--i2c_init_structure
    236           *                     具体定义见I2C_InitTypeDef
    237           *
    238           * 输出:
    239           *    无
    240           *
    241           */  

   \                                 In section .text, align 2, keep-with-next
    242          void I2C_DisableIrq(I2C_InitTypeDef i2c_init_structure)
    243          {
   \                     I2C_DisableIrq: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    244            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
   \   00000002   0x9C00             LDR      R4,[SP, #+0]
    245            i2cx->C1 &= ~I2C_C1_IICIE_MASK;
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000000A   0x70A0             STRB     R0,[R4, #+2]
    246          
    247            if(i2cx == I2C0)
   \   0000000C   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40066000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD103             BNE.N    ??I2C_DisableIrq_0
    248            {
    249              disable_irq((IRQn_Type)I2C0_IRQn);
   \   00000012   0x2018             MOVS     R0,#+24
   \   00000014   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init17__NVIC_DisableIRQE4IRQn
   \   00000018   0xE007             B.N      ??I2C_DisableIrq_1
    250            }
    251            else if (i2cx == I2C1)
   \                     ??I2C_DisableIrq_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40067000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD103             BNE.N    ??I2C_DisableIrq_2
    252            {
    253              disable_irq((IRQn_Type)I2C1_IRQn);
   \   00000020   0x2019             MOVS     R0,#+25
   \   00000022   0x.... 0x....      BL       _ZN26_INTERNAL_5_I2C_c_I2C_Init17__NVIC_DisableIRQE4IRQn
   \   00000026   0xE000             B.N      ??I2C_DisableIrq_1
    254            }
    255            else
    256            {
    257              return;
   \                     ??I2C_DisableIrq_2: (+1)
   \   00000028   0xE7FF             B.N      ??I2C_DisableIrq_3
    258            }
    259          }
   \                     ??I2C_DisableIrq_1: (+1)
   \                     ??I2C_DisableIrq_3: (+1)
   \   0000002A   0xBD1F             POP      {R0-R4,PC}       ;; return
    260          
    261          /*
    262           * I2C_Start
    263           * 产生I2C开始信号
    264           * 
    265           * 参数:
    266           *    i2cx--选择I2C模块的通道
    267           *      |__I2C0           --I2C通道0
    268           *      |__I2C1           --I2C通道1
    269           * 输出:
    270           *    无
    271           */

   \                                 In section .text, align 2, keep-with-next
    272          void I2C_Start(I2C_Type *i2cx)
    273          {
    274            i2cx->C1 |= I2C_C1_TX_MASK ;
   \                     I2C_Start: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    275            i2cx->C1 |= I2C_C1_MST_MASK ;
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    276          }
   \   00000010   0x4770             BX       LR               ;; return
    277          
    278          /*
    279           * ReStart
    280           * I2C再次产生开始信号
    281           * 
    282           * 参数:
    283           *    i2cx--选择I2C模块的通道
    284           *      |__I2C0           --I2C通道0
    285           *      |__I2C1           --I2C通道1
    286           * 输出:
    287           *    无
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          void I2C_ReStart(I2C_Type *i2cx)
    290          {
    291            i2cx->C1 |= I2C_C1_RSTA_MASK ;
   \                     I2C_ReStart: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    292          }
   \   00000008   0x4770             BX       LR               ;; return
    293          
    294          /*
    295           * I2C_Stop
    296           * 产生I2C停止信号
    297           * 
    298           * 参数:
    299           *    i2cx--选择I2C模块的通道
    300           *      |__I2C0           --I2C通道0
    301           *      |__I2C1           --I2C通道1
    302           * 输出:
    303           *    无
    304           */

   \                                 In section .text, align 2, keep-with-next
    305          void I2C_Stop(I2C_Type *i2cx)
    306          {
    307            i2cx->C1 &=(~I2C_C1_MST_MASK);
   \                     I2C_Stop: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    308            i2cx->C1 &=(~I2C_C1_TX_MASK); 
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0xF011 0x01EF      ANDS     R1,R1,#0xEF
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    309          }
   \   00000010   0x4770             BX       LR               ;; return
    310          
    311          /*
    312           * I2C_WaitAck
    313           * I2C设置等待应答信号，开启则等待，关闭则不等待
    314           * 
    315           * 参数:
    316           *    i2cx--选择I2C模块的通道
    317           *      |__I2C0           --I2C通道0
    318           *      |__I2C1           --I2C通道1
    319           *    is_wait--选择是否等待应答
    320           *      |__I2C_ACK_OFF    --关闭等待Ack
    321           *      |__I2C_ACK_ON     --开启等待Ack，并等待ACK信号
    322           * 输出:
    323           *    无
    324           */

   \                                 In section .text, align 2, keep-with-next
    325          void I2C_WaitAck(I2C_Type *i2cx, uint8 is_wait)
    326          {
   \                     I2C_WaitAck: (+1)
   \   00000000   0xB410             PUSH     {R4}
    327            int time_out;
    328            if(is_wait == I2C_ACK_ON)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD116             BNE.N    ??I2C_WaitAck_0
    329            {
    330              while(!(i2cx->S & I2C_S_IICIF_MASK))
   \                     ??I2C_WaitAck_1: (+1)
   \   00000008   0x78C3             LDRB     R3,[R0, #+3]
   \   0000000A   0x079B             LSLS     R3,R3,#+30
   \   0000000C   0xD40E             BMI.N    ??I2C_WaitAck_2
    331              {
    332                if(time_out>80000) //如果等待超时，强行退出 60000
   \   0000000E   0x....             LDR.N    R3,??DataTable8_17  ;; 0x13881
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xDB09             BLT.N    ??I2C_WaitAck_3
    333                {
    334                  I2C_Timeout_myCont++;
   \   00000014   0x....             LDR.N    R3,??DataTable8_18
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \   0000001A   0x....             LDR.N    R4,??DataTable8_18
   \   0000001C   0x6023             STR      R3,[R4, #+0]
    335                  i2cx->C1 |= I2C_C1_TXAK_MASK; 
   \   0000001E   0x7883             LDRB     R3,[R0, #+2]
   \   00000020   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   00000024   0x7083             STRB     R3,[R0, #+2]
    336                  break;
   \   00000026   0xE001             B.N      ??I2C_WaitAck_2
    337                }
    338                else time_out++;
   \                     ??I2C_WaitAck_3: (+1)
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0xE7ED             B.N      ??I2C_WaitAck_1
    339              }
    340              i2cx->S |= I2C_S_IICIF_MASK;
   \                     ??I2C_WaitAck_2: (+1)
   \   0000002C   0x78C3             LDRB     R3,[R0, #+3]
   \   0000002E   0xF053 0x0302      ORRS     R3,R3,#0x2
   \   00000032   0x70C3             STRB     R3,[R0, #+3]
   \   00000034   0xE003             B.N      ??I2C_WaitAck_4
    341            }
    342            else
    343            {
    344              //关闭I2C的ACK
    345              i2cx->C1 |= I2C_C1_TXAK_MASK; 
   \                     ??I2C_WaitAck_0: (+1)
   \   00000036   0x7883             LDRB     R3,[R0, #+2]
   \   00000038   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   0000003C   0x7083             STRB     R3,[R0, #+2]
    346            }
    347          }
   \                     ??I2C_WaitAck_4: (+1)
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    348          
    349          /*
    350           * I2C_Write
    351           * I2C发送一个字节给目的地址设备
    352           * 
    353           * 参数:
    354           *    i2cx--选择I2C模块的通道
    355           *      |__I2C0           --I2C通道0
    356           *      |__I2C1           --I2C通道1
    357           *    data8--要发送的字节数据
    358           * 输出:
    359           *    无
    360           *
    361           */

   \                                 In section .text, align 2, keep-with-next
    362          void I2C_WriteByte(I2C_Type *i2cx, uint8 data8)
    363          {
    364            i2cx->D = data8; 
   \                     I2C_WriteByte: (+1)
   \   00000000   0x7101             STRB     R1,[R0, #+4]
    365          }
   \   00000002   0x4770             BX       LR               ;; return
    366          
    367          /*
    368           * I2C_Read
    369           * I2C从外部设备读一个字节
    370           * 
    371           * 参数:
    372           *    i2cx--选择I2C模块的通道
    373           *      |__I2C0           --I2C通道0
    374           *      |__I2C1           --I2C通道1
    375           * 输出:
    376           *    I2C读取的字节 
    377           */
    378          

   \                                 In section .text, align 2, keep-with-next
    379          uint8 I2C_ReadByte(I2C_Type *i2cx)
    380          {
   \                     I2C_ReadByte: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    381            uint8 temp;
    382            temp = i2cx->D; 
   \   00000002   0x7908             LDRB     R0,[R1, #+4]
    383            return temp;
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    384          }
    385          
    386          /*
    387           * I2C_SetMasterWR
    388           * I2C主机读写模式配置
    389           * 
    390           * 参数:
    391           *    IICx--选择I2C模块的通道
    392           *      |__I2C0           --I2C通道0
    393           *      |__I2C1           --I2C通道1
    394           *    mode--读写模式选择
    395           *      |__I2C_MWSR         --主机写
    396           *      |__I2C_MRSW         --主机读
    397           * 输出:
    398           *    无
    399           */

   \                                 In section .text, align 2, keep-with-next
    400          void I2C_SetMasterWR(I2C_Type *i2cx, uint8 mode)
    401          {
    402            if(mode==I2C_MRSW) 
   \                     I2C_SetMasterWR: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??I2C_SetMasterWR_0
    403              i2cx->C1 &= (~I2C_C1_TX_MASK);
   \   00000006   0x7882             LDRB     R2,[R0, #+2]
   \   00000008   0xF012 0x02EF      ANDS     R2,R2,#0xEF
   \   0000000C   0x7082             STRB     R2,[R0, #+2]
   \   0000000E   0xE003             B.N      ??I2C_SetMasterWR_1
    404            else
    405              i2cx->C1 |= ( I2C_C1_TX_MASK);
   \                     ??I2C_SetMasterWR_0: (+1)
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   00000016   0x7082             STRB     R2,[R0, #+2]
    406          }
   \                     ??I2C_SetMasterWR_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    407          
    408          /*
    409           * I2C_StartTrans
    410           * I2C开始传输函数，需要设置外围设备地址和读写模式
    411           * 
    412           * 参数:
    413           *    IICx--选择I2C模块的通道
    414           *      |__I2C0           --I2C通道0
    415           *      |__I2C1           --I2C通道1
    416           *    addr--外围设备地址     
    417           *    mode--读写模式选择
    418           *      |__I2C_MWSR         --主机写
    419           *      |__I2C_MRSW         --主机读
    420           * 输出:
    421           *    无
    422           */

   \                                 In section .text, align 2, keep-with-next
    423          void I2C_StartTrans(I2C_Type *i2cx, uint8 addr, uint8 mode)
    424          {
   \                     I2C_StartTrans: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    425            //I2C产生start信号
    426            I2C_Start(i2cx);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_Start
    427            //将从机地址和主机读写位合成一个字节写入
    428            I2C_WriteByte(i2cx, (addr<<1)|mode );
   \   0000000E   0xEA56 0x0145      ORRS     R1,R6,R5, LSL #+1
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       I2C_WriteByte
    429          }
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    430          
    431          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    432          void I2C0_IRQHandler(void)
    433          {
   \                     _Z15I2C0_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    434          #if (UCOS_II > 0u)
    435            OS_CPU_SR  cpu_sr = 0u;
    436            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    437            OSIntEnter();
    438            OS_EXIT_CRITICAL();
    439          #endif
    440            if(I2C0->S & I2C_S_IICIF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable8_19  ;; 0x40066003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD526             BPL.N    ??I2C0_IRQHandler_0
    441            {
    442              I2C_ISR[0]();
   \   0000000A   0x....             LDR.N    R0,??DataTable8_16
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    443              if(I2C0->SMB & I2C_SMB_SLTF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40066008
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD505             BPL.N    ??I2C0_IRQHandler_1
    444              {
    445                I2C0->SMB |= I2C_SMB_SLTF_MASK;
   \   00000018   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40066008
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000020   0x....             LDR.N    R1,??DataTable8_20  ;; 0x40066008
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    446              }
    447              if(I2C0->SMB & I2C_SMB_SHTF2_MASK)
   \                     ??I2C0_IRQHandler_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40066008
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xD505             BPL.N    ??I2C0_IRQHandler_2
    448              {
    449                I2C0->SMB |= I2C_SMB_SHTF2_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40066008
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable8_20  ;; 0x40066008
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    450              }
    451              if(I2C0->S & I2C_S_ARBL_MASK)
   \                     ??I2C0_IRQHandler_2: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable8_19  ;; 0x40066003
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD505             BPL.N    ??I2C0_IRQHandler_3
    452              {
    453                I2C0->S |= I2C_S_ARBL_MASK;
   \   00000040   0x....             LDR.N    R0,??DataTable8_19  ;; 0x40066003
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000048   0x....             LDR.N    R1,??DataTable8_19  ;; 0x40066003
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    454              }
    455              I2C0->S |= I2C_S_IICIF_MASK;
   \                     ??I2C0_IRQHandler_3: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable8_19  ;; 0x40066003
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable8_19  ;; 0x40066003
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    456            }
    457          #if (UCOS_II > 0u)
    458            OSIntExit();          //告知系统此时即将离开中断服务子函数
    459          #endif
    460          }
   \                     ??I2C0_IRQHandler_0: (+1)
   \                     ??I2C0_IRQHandler_4: (+1)
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
    461          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    462          void I2C1_IRQHandler(void)
    463          {
   \                     _Z15I2C1_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    464          
    465          #if (UCOS_II > 0u)
    466            OS_CPU_SR  cpu_sr = 0u;
    467            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    468            OSIntEnter();
    469            OS_EXIT_CRITICAL();
    470          #endif
    471          
    472            if(I2C1->S & I2C_S_IICIF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable8_21  ;; 0x40067003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD526             BPL.N    ??I2C1_IRQHandler_0
    473            {
    474              I2C_ISR[1]();
   \   0000000A   0x....             LDR.N    R0,??DataTable8_16
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x4780             BLX      R0
    475              if(I2C1->SMB & I2C_SMB_SLTF_MASK)
   \   00000010   0x....             LDR.N    R0,??DataTable8_22  ;; 0x40067008
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD505             BPL.N    ??I2C1_IRQHandler_1
    476              {
    477                I2C1->SMB |= I2C_SMB_SLTF_MASK;
   \   00000018   0x....             LDR.N    R0,??DataTable8_22  ;; 0x40067008
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000020   0x....             LDR.N    R1,??DataTable8_22  ;; 0x40067008
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    478              }
    479              if(I2C1->SMB & I2C_SMB_SHTF2_MASK)
   \                     ??I2C1_IRQHandler_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable8_22  ;; 0x40067008
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xD505             BPL.N    ??I2C1_IRQHandler_2
    480              {
    481                I2C1->SMB |= I2C_SMB_SHTF2_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable8_22  ;; 0x40067008
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable8_22  ;; 0x40067008
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    482              }
    483              if(I2C1->S & I2C_S_ARBL_MASK)
   \                     ??I2C1_IRQHandler_2: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable8_21  ;; 0x40067003
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD505             BPL.N    ??I2C1_IRQHandler_3
    484              {
    485                I2C1->S |= I2C_S_ARBL_MASK;
   \   00000040   0x....             LDR.N    R0,??DataTable8_21  ;; 0x40067003
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000048   0x....             LDR.N    R1,??DataTable8_21  ;; 0x40067003
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    486              }
    487              I2C1->S |= I2C_S_IICIF_MASK;
   \                     ??I2C1_IRQHandler_3: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable8_21  ;; 0x40067003
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable8_21  ;; 0x40067003
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    488            }
    489            
    490          #if (UCOS_II > 0u)
    491            OSIntExit();          //告知系统此时即将离开中断服务子函数
    492          #endif
    493          }
   \                     ??I2C1_IRQHandler_0: (+1)
   \                     ??I2C1_IRQHandler_4: (+1)
   \   00000058   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x4004C020         DC32     0x4004c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x4004A008         DC32     0x4004a008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x4004C024         DC32     0x4004c024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x4004A00C         DC32     0x4004a00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x40067000         DC32     0x40067000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x4004B028         DC32     0x4004b028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x4004B02C         DC32     0x4004b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     I2C_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x00013881         DC32     0x13881

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x........         DC32     I2C_Timeout_myCont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x40066003         DC32     0x40066003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x40066008         DC32     0x40066008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x40067003         DC32     0x40067003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x40067008         DC32     0x40067008

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x78          DC8 5CH, 78H, 73H, 6BH, 31H, 39H, 39H, 34H
   \              0x73 0x6B    
   \              0x31 0x39    
   \              0x39 0x34    
   \   00000010   0x30 0x39          DC8 30H, 39H, 31H, 30H, 5CH, 44H, 65H, 73H
   \              0x31 0x30    
   \              0x5C 0x44    
   \              0x65 0x73    
   \   00000018   0x6B 0x74          DC8 6BH, 74H, 6FH, 70H, 5CH, 66H, 6CH, 69H
   \              0x6F 0x70    
   \              0x5C 0x66    
   \              0x6C 0x69    
   \   00000020   0x67 0x68          DC8 67H, 68H, 74H, 43H, 6FH, 6EH, 74H, 72H
   \              0x74 0x43    
   \              0x6F 0x6E    
   \              0x74 0x72    
   \   00000028   0x6F 0x6C          DC8 6FH, 6CH, 6CH, 65H, 72H, 2DH, 31H, 5CH
   \              0x6C 0x65    
   \              0x72 0x2D    
   \              0x31 0x5C    
   \   00000030   0x66 0x6C          DC8 66H, 6CH, 69H, 67H, 68H, 74H, 43H, 6FH
   \              0x69 0x67    
   \              0x68 0x74    
   \              0x43 0x6F    
   \   00000038   0x6E 0x74          DC8 6EH, 74H, 72H, 6FH, 6CH, 6CH, 65H, 72H
   \              0x72 0x6F    
   \              0x6C 0x6C    
   \              0x65 0x72    
   \   00000040   0x2D 0x31          DC8 2DH, 31H, 5CH, 70H, 72H, 6FH, 67H, 72H
   \              0x5C 0x70    
   \              0x72 0x6F    
   \              0x67 0x72    
   \   00000048   0x61 0x6D          DC8 61H, 6DH, 5CH, 6CH, 69H, 62H, 5CH, 4CH
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \   00000050   0x50 0x4C          DC8 50H, 4CH, 44H, 5CH, 48H, 57H, 5CH, 49H
   \              0x44 0x5C    
   \              0x48 0x57    
   \              0x5C 0x49    
   \   00000058   0x32 0x43          DC8 32H, 43H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   0000005D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    494            

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   I2C0_IRQHandler()
         8   -- Indirect call
       8   I2C1_IRQHandler()
         8   -- Indirect call
      24   I2C_Deinit
        24   -> __NVIC_DisableIRQ(IRQn)
      24   I2C_DisableIrq
        24   -> __NVIC_DisableIRQ(IRQn)
      24   I2C_EnableIrq
        24   -> __NVIC_EnableIRQ(IRQn)
      48   I2C_Init
        48   -> assert_failed
       0   I2C_ReStart
       0   I2C_ReadByte
       0   I2C_SetMasterWR
       0   I2C_Start
      16   I2C_StartTrans
        16   -> I2C_Start
        16   -> I2C_WriteByte
       0   I2C_Stop
       4   I2C_WaitAck
       0   I2C_WriteByte
       0   __NVIC_DisableIRQ(IRQn)
       0   __NVIC_EnableIRQ(IRQn)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      96  ?_0
      90  I2C0_IRQHandler()
      90  I2C1_IRQHandler()
      74  I2C_Deinit
      44  I2C_DisableIrq
      36  I2C_EnableIrq
       8  I2C_ISR
     362  I2C_Init
      10  I2C_ReStart
       8  I2C_ReadByte
      26  I2C_SetMasterWR
      18  I2C_Start
      28  I2C_StartTrans
      18  I2C_Stop
       4  I2C_Timeout_myCont
      66  I2C_WaitAck
       4  I2C_WriteByte
      30  __NVIC_DisableIRQ(IRQn)
      30  __NVIC_EnableIRQ(IRQn)
      24  -- Other

 
    24 bytes in section .ARM.exidx
    12 bytes in section .bss
    96 bytes in section .rodata
 1 026 bytes in section .text
 
 1 026 bytes of CODE  memory
   120 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
