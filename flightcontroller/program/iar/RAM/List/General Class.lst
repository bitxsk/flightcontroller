###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       18/Jun/2018  19:47:56
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\General
#        Class.cpp
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW1726.tmp
#        ("C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\General
#        Class.cpp" -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List\General
#        Class.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj\General
#        Class.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\General Class.cpp
      1          #include "General Class.h"
      2          

   \                                 In section .text, align 2, keep-with-next
      3          float CJumpFilter::newData(float newData, float dataDerivate, int t)
      4          {
   \                     _ZN11CJumpFilter7newDataEffi: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0x0007             MOVS     R7,R0
   \   0000000A   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000000E   0xEEB0 0x8A60      VMOV.F32 S16,S1
   \   00000012   0x000E             MOVS     R6,R1
      5            //static float lastData;
      6            if(init)
   \   00000014   0xF897 0x0035      LDRB     R0,[R7, #+53]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD073             BEQ.N    ??newData_0
      7            {
      8              if(abs(newData - lastData) > maxRate + abs(dataDerivate) * (t - oldDataTime) * 0.001)
   \   0000001C   0xEEB0 0x9AC8      VABS.F32 S18,S16
   \   00000020   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000024   0xEE78 0x9AC0      VSUB.F32 S19,S17,S0
   \   00000028   0xEEB0 0x0AE9      VABS.F32 S0,S19
   \   0000002C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000030   0x.... 0x....      BL       __aeabi_f2d
   \   00000034   0x0002             MOVS     R2,R0
   \   00000036   0x000B             MOVS     R3,R1
   \   00000038   0x4690             MOV      R8,R2
   \   0000003A   0x4699             MOV      R9,R3
   \   0000003C   0x68B8             LDR      R0,[R7, #+8]
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x0004             MOVS     R4,R0
   \   00000044   0x000D             MOVS     R5,R1
   \   00000046   0x69F8             LDR      R0,[R7, #+28]
   \   00000048   0x1A30             SUBS     R0,R6,R0
   \   0000004A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000004E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000052   0xEE20 0x0A09      VMUL.F32 S0,S0,S18
   \   00000056   0xEE10 0x0A10      VMOV     R0,S0
   \   0000005A   0x.... 0x....      BL       __aeabi_f2d
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable4  ;; 0xd2f1a9fc
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable4_1  ;; 0x3f50624d
   \   00000066   0x.... 0x....      BL       __aeabi_dmul
   \   0000006A   0x0022             MOVS     R2,R4
   \   0000006C   0x002B             MOVS     R3,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_dadd
   \   00000072   0x4642             MOV      R2,R8
   \   00000074   0x464B             MOV      R3,R9
   \   00000076   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000007A   0xD208             BCS.N    ??newData_1
      9              {
     10                if(valid)
   \   0000007C   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD00C             BEQ.N    ??newData_2
     11                {
     12                  valid = false;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF887 0x0034      STRB     R0,[R7, #+52]
     13                  invalidTime = t;
   \   0000008A   0x617E             STR      R6,[R7, #+20]
   \   0000008C   0xE007             B.N      ??newData_2
     14                }
     15              }
     16              else
     17              {
     18                if(!valid)
   \                     ??newData_1: (+1)
   \   0000008E   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD103             BNE.N    ??newData_2
     19                {
     20                  valid = true;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF887 0x0034      STRB     R0,[R7, #+52]
     21                  validTime = t;
   \   0000009C   0x61BE             STR      R6,[R7, #+24]
     22                }
     23              }
     24              
     25              if(t - invalidTime > maxInvalidTime)
   \                     ??newData_2: (+1)
   \   0000009E   0x6AB8             LDR      R0,[R7, #+40]
   \   000000A0   0x6979             LDR      R1,[R7, #+20]
   \   000000A2   0x1A71             SUBS     R1,R6,R1
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xDA07             BGE.N    ??newData_3
     26              {
     27                if(!valid)
   \   000000A8   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD103             BNE.N    ??newData_3
     28                {
     29                  valid = true;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF887 0x0034      STRB     R0,[R7, #+52]
     30                  validTime = t;
   \   000000B6   0x61BE             STR      R6,[R7, #+24]
     31                }
     32              }
     33              
     34              if(!valid)
   \                     ??newData_3: (+1)
   \   000000B8   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD11E             BNE.N    ??newData_4
     35              {
     36                lastData += dataDerivate * (t - oldDataTime) * 0.001;
   \   000000C0   0x6838             LDR      R0,[R7, #+0]
   \   000000C2   0x.... 0x....      BL       __aeabi_f2d
   \   000000C6   0x0004             MOVS     R4,R0
   \   000000C8   0x000D             MOVS     R5,R1
   \   000000CA   0x69F8             LDR      R0,[R7, #+28]
   \   000000CC   0x1A30             SUBS     R0,R6,R0
   \   000000CE   0xEE00 0x0A10      VMOV     S0,R0
   \   000000D2   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000D6   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   000000DA   0xEE10 0x0A10      VMOV     R0,S0
   \   000000DE   0x.... 0x....      BL       __aeabi_f2d
   \   000000E2   0x.... 0x....      LDR.W    R2,??DataTable4  ;; 0xd2f1a9fc
   \   000000E6   0x.... 0x....      LDR.W    R3,??DataTable4_1  ;; 0x3f50624d
   \   000000EA   0x.... 0x....      BL       __aeabi_dmul
   \   000000EE   0x0022             MOVS     R2,R4
   \   000000F0   0x002B             MOVS     R3,R5
   \   000000F2   0x.... 0x....      BL       __aeabi_dadd
   \   000000F6   0x.... 0x....      BL       __aeabi_d2f
   \   000000FA   0x6038             STR      R0,[R7, #+0]
   \   000000FC   0xE007             B.N      ??newData_5
     37              }
     38              else
     39              {
     40                lastData = newData;
   \                     ??newData_4: (+1)
   \   000000FE   0xEDC7 0x8A00      VSTR     S17,[R7, #0]
   \   00000102   0xE004             B.N      ??newData_5
     41              }
     42            }
     43            else
     44            {
     45              lastData = newData;
   \                     ??newData_0: (+1)
   \   00000104   0xEDC7 0x8A00      VSTR     S17,[R7, #0]
     46              init = true;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xF887 0x0035      STRB     R0,[R7, #+53]
     47            }
     48            oldDataTime = t;
   \                     ??newData_5: (+1)
   \   0000010E   0x61FE             STR      R6,[R7, #+28]
     49            return lastData;
   \   00000110   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000114   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000118   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
     50          }
     51          

   \                                 In section .text, align 2, keep-with-next
     52          float CJumpFilter::newData(float newData, int t)
     53          {
   \                     _ZN11CJumpFilter7newDataEfi: (+1)
   \   00000000   0xEEF0 0x0A40      VMOV.F32 S1,S0
     54            //static float lastData;
     55            if(init)
   \   00000004   0xF890 0x2035      LDRB     R2,[R0, #+53]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD042             BEQ.N    ??newData_6
     56            {
     57              if(abs(newData - lastData) > maxRate + abs(intervalIntegral) * integralThresholdGain)
   \   0000000C   0xED90 0x0A0C      VLDR     S0,[R0, #+48]
   \   00000010   0xEEB0 0x1AC0      VABS.F32 S2,S0
   \   00000014   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   00000018   0xEE70 0x1AE1      VSUB.F32 S3,S1,S3
   \   0000001C   0xEEB0 0x2AE1      VABS.F32 S4,S3
   \   00000020   0xEDD0 0x2A0B      VLDR     S5,[R0, #+44]
   \   00000024   0xED90 0x3A02      VLDR     S6,[R0, #+8]
   \   00000028   0xEE01 0x3A22      VMLA.F32 S6,S2,S5
   \   0000002C   0xEEB4 0x3A42      VCMP.F32 S6,S4
   \   00000030   0xEEF1 0xFA10      FMSTAT   
   \   00000034   0xD508             BPL.N    ??newData_7
     58              {
     59                if(valid)
   \   00000036   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD00C             BEQ.N    ??newData_8
     60                {
     61                  valid = false;
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xF880 0x2034      STRB     R2,[R0, #+52]
     62                  invalidTime = t;
   \   00000044   0x6141             STR      R1,[R0, #+20]
   \   00000046   0xE007             B.N      ??newData_8
     63                }
     64              }
     65              else
     66              {
     67                if(!valid)
   \                     ??newData_7: (+1)
   \   00000048   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0xD103             BNE.N    ??newData_8
     68                {
     69                  valid = true;
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0xF880 0x2034      STRB     R2,[R0, #+52]
     70                  validTime = t;
   \   00000056   0x6181             STR      R1,[R0, #+24]
     71                }
     72              }
     73              
     74              if(t - invalidTime > maxInvalidTime)
   \                     ??newData_8: (+1)
   \   00000058   0x6A82             LDR      R2,[R0, #+40]
   \   0000005A   0x6943             LDR      R3,[R0, #+20]
   \   0000005C   0x1ACB             SUBS     R3,R1,R3
   \   0000005E   0x429A             CMP      R2,R3
   \   00000060   0xDA07             BGE.N    ??newData_9
     75              {
     76                if(!valid)
   \   00000062   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000066   0x2A00             CMP      R2,#+0
   \   00000068   0xD103             BNE.N    ??newData_9
     77                {
     78                  valid = true;
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0xF880 0x2034      STRB     R2,[R0, #+52]
     79                  validTime = t;
   \   00000070   0x6181             STR      R1,[R0, #+24]
     80                }
     81              }
     82              
     83              if(!valid)
   \                     ??newData_9: (+1)
   \   00000072   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xD108             BNE.N    ??newData_10
     84              {
     85                lastData += intervalIntegral;
   \   0000007A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000007E   0xED90 0x1A0C      VLDR     S2,[R0, #+48]
   \   00000082   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   00000086   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000008A   0xE007             B.N      ??newData_11
     86              }
     87              else
     88              {
     89                lastData = newData;
   \                     ??newData_10: (+1)
   \   0000008C   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000090   0xE004             B.N      ??newData_11
     90              }
     91            }
     92            else
     93            {
     94              lastData = newData;
   \                     ??newData_6: (+1)
   \   00000092   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
     95              init = true;
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0xF880 0x2035      STRB     R2,[R0, #+53]
     96            }
     97            oldDataTime = t;
   \                     ??newData_11: (+1)
   \   0000009C   0x61C1             STR      R1,[R0, #+28]
     98            intervalIntegral = 0;
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x6302             STR      R2,[R0, #+48]
     99            return lastData;
   \   000000A2   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000A6   0x4770             BX       LR               ;; return
    100          }
    101          

   \                                 In section .text, align 4, keep-with-next
    102          float CJumpFilter::newData1(float newData, int t)
    103          {
   \                     _ZN11CJumpFilter8newData1Efi: (+1)
   \   00000000   0xEEF0 0x0A40      VMOV.F32 S1,S0
    104            //static float lastData;
    105            if(init)
   \   00000004   0xF890 0x2035      LDRB     R2,[R0, #+53]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD049             BEQ.N    ??newData1_0
    106            {
    107              if(abs(newData - lastData) / ((t - lastDataTime) / 1000.0f) > abs(maxRate))
   \   0000000C   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000010   0xEEB0 0x1AC0      VABS.F32 S2,S0
   \   00000014   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   00000018   0xEE70 0x1AE1      VSUB.F32 S3,S1,S3
   \   0000001C   0xEEB0 0x2AE1      VABS.F32 S4,S3
   \   00000020   0x6A42             LDR      R2,[R0, #+36]
   \   00000022   0x1A8A             SUBS     R2,R1,R2
   \   00000024   0xEE02 0x2A90      VMOV     S5,R2
   \   00000028   0xEEF8 0x2AE2      VCVT.F32.S32 S5,S5
   \   0000002C   0xED9F 0x....      VLDR.W   S6,??DataTable3  ;; 0x447a0000
   \   00000030   0xEEC2 0x2A83      VDIV.F32 S5,S5,S6
   \   00000034   0xEE82 0x2A22      VDIV.F32 S4,S4,S5
   \   00000038   0xEEB4 0x1A42      VCMP.F32 S2,S4
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xD508             BPL.N    ??newData1_1
    108              {
    109                if(valid)
   \   00000042   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD00C             BEQ.N    ??newData1_2
    110                {
    111                  valid = false;
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF880 0x2034      STRB     R2,[R0, #+52]
    112                  invalidTime = t;
   \   00000050   0x6141             STR      R1,[R0, #+20]
   \   00000052   0xE007             B.N      ??newData1_2
    113                }
    114              }
    115              else
    116              {
    117                if(!valid)
   \                     ??newData1_1: (+1)
   \   00000054   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000058   0x2A00             CMP      R2,#+0
   \   0000005A   0xD103             BNE.N    ??newData1_2
    118                {
    119                  valid = true;
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0xF880 0x2034      STRB     R2,[R0, #+52]
    120                  validTime = t;
   \   00000062   0x6181             STR      R1,[R0, #+24]
    121                }
    122              }
    123              lastDataTime = t;
   \                     ??newData1_2: (+1)
   \   00000064   0x6241             STR      R1,[R0, #+36]
    124              
    125              if(t - invalidTime > maxInvalidTime)
   \   00000066   0x6A82             LDR      R2,[R0, #+40]
   \   00000068   0x6943             LDR      R3,[R0, #+20]
   \   0000006A   0x1ACB             SUBS     R3,R1,R3
   \   0000006C   0x429A             CMP      R2,R3
   \   0000006E   0xDA07             BGE.N    ??newData1_3
    126              {
    127                if(!valid)
   \   00000070   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD103             BNE.N    ??newData1_3
    128                {
    129                  valid = true;
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0xF880 0x2034      STRB     R2,[R0, #+52]
    130                  validTime = t;
   \   0000007E   0x6181             STR      R1,[R0, #+24]
    131                }
    132              }
    133              
    134              if(!valid)
   \                     ??newData1_3: (+1)
   \   00000080   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000084   0x2A00             CMP      R2,#+0
   \   00000086   0xD108             BNE.N    ??newData1_4
    135              {
    136                lastData += intervalIntegral;
   \   00000088   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000008C   0xED90 0x1A0C      VLDR     S2,[R0, #+48]
   \   00000090   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   00000094   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000098   0xE007             B.N      ??newData1_5
    137              }
    138              else
    139              {
    140                lastData = newData;
   \                     ??newData1_4: (+1)
   \   0000009A   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   0000009E   0xE004             B.N      ??newData1_5
    141              }
    142            }
    143            else
    144            {
    145              lastData = newData;
   \                     ??newData1_0: (+1)
   \   000000A0   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    146              init = true;
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0xF880 0x2035      STRB     R2,[R0, #+53]
    147            }
    148            oldDataTime = t;
   \                     ??newData1_5: (+1)
   \   000000AA   0x61C1             STR      R1,[R0, #+28]
    149            intervalIntegral = 0;
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x6302             STR      R2,[R0, #+48]
    150            return lastData;
   \   000000B0   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000B4   0x4770             BX       LR               ;; return
    151          }
    152          
    153          

   \                                 In section .text, align 2, keep-with-next
    154          float CJumpFilter::newData3(float newData, int t) 
    155          {
   \                     _ZN11CJumpFilter8newData3Efi: (+1)
   \   00000000   0xEEF0 0x0A40      VMOV.F32 S1,S0
    156            //static float lastData;
    157            if(init)
   \   00000004   0xF890 0x2035      LDRB     R2,[R0, #+53]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD056             BEQ.N    ??newData3_0
    158            {
    159              if(abs(newData - lastData) > maxRate || newData > maxValue || newData < minValue)
   \   0000000C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000010   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   00000014   0xEEB0 0x1AC0      VABS.F32 S2,S0
   \   00000018   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   0000001C   0xEEF4 0x1A41      VCMP.F32 S3,S2
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD40D             BMI.N    ??newData3_1
   \   00000026   0xED90 0x0A03      VLDR     S0,[R0, #+12]
   \   0000002A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000002E   0xEEF1 0xFA10      FMSTAT   
   \   00000032   0xD406             BMI.N    ??newData3_1
   \   00000034   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000038   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xD508             BPL.N    ??newData3_2
    160              {
    161                if(valid)
   \                     ??newData3_1: (+1)
   \   00000042   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD00C             BEQ.N    ??newData3_3
    162                {
    163                  valid = false;
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF880 0x2034      STRB     R2,[R0, #+52]
    164                  invalidTime = t;
   \   00000050   0x6141             STR      R1,[R0, #+20]
   \   00000052   0xE007             B.N      ??newData3_3
    165                }
    166              }
    167              else
    168              {
    169                if(!valid)
   \                     ??newData3_2: (+1)
   \   00000054   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000058   0x2A00             CMP      R2,#+0
   \   0000005A   0xD103             BNE.N    ??newData3_3
    170                {
    171                  valid = true;
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0xF880 0x2034      STRB     R2,[R0, #+52]
    172                  validTime = t;
   \   00000062   0x6181             STR      R1,[R0, #+24]
    173                }
    174              }
    175              
    176              if(t - invalidTime > maxInvalidTime && newData < maxValue && newData > minValue)
   \                     ??newData3_3: (+1)
   \   00000064   0x6A82             LDR      R2,[R0, #+40]
   \   00000066   0x6943             LDR      R3,[R0, #+20]
   \   00000068   0x1ACB             SUBS     R3,R1,R3
   \   0000006A   0x429A             CMP      R2,R3
   \   0000006C   0xDA15             BGE.N    ??newData3_4
   \   0000006E   0xED90 0x0A03      VLDR     S0,[R0, #+12]
   \   00000072   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000076   0xEEF1 0xFA10      FMSTAT   
   \   0000007A   0xD50E             BPL.N    ??newData3_4
   \   0000007C   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000080   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xD507             BPL.N    ??newData3_4
    177              {
    178                if(!valid)
   \   0000008A   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xD103             BNE.N    ??newData3_4
    179                {
    180                  valid = true;
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0xF880 0x2034      STRB     R2,[R0, #+52]
    181                  validTime = t;
   \   00000098   0x6181             STR      R1,[R0, #+24]
    182                }
    183              }
    184              
    185              if(!valid)
   \                     ??newData3_4: (+1)
   \   0000009A   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   0000009E   0x2A00             CMP      R2,#+0
   \   000000A0   0xD108             BNE.N    ??newData3_5
    186              {
    187                lastData += intervalIntegral;
   \   000000A2   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000A6   0xED90 0x1A0C      VLDR     S2,[R0, #+48]
   \   000000AA   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   000000AE   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000000B2   0xE007             B.N      ??newData3_6
    188              }
    189              else
    190              {
    191                lastData = newData;
   \                     ??newData3_5: (+1)
   \   000000B4   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   000000B8   0xE004             B.N      ??newData3_6
    192              }
    193            }
    194            else
    195            {
    196              lastData = newData;
   \                     ??newData3_0: (+1)
   \   000000BA   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    197              init = true;
   \   000000BE   0x2201             MOVS     R2,#+1
   \   000000C0   0xF880 0x2035      STRB     R2,[R0, #+53]
    198            }
    199            oldDataTime = t;
   \                     ??newData3_6: (+1)
   \   000000C4   0x61C1             STR      R1,[R0, #+28]
    200            intervalIntegral = 0;
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x6302             STR      R2,[R0, #+48]
    201            return lastData;
   \   000000CA   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000CE   0x4770             BX       LR               ;; return
    202          }
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void CJumpFilter::accumulate(float tmp)
    205          {
    206            intervalIntegral += tmp;
   \                     _ZN11CJumpFilter10accumulateEf: (+1)
   \   00000000   0xEDD0 0x0A0C      VLDR     S1,[R0, #+48]
   \   00000004   0xEE70 0x0A80      VADD.F32 S1,S1,S0
   \   00000008   0xEDC0 0x0A0C      VSTR     S1,[R0, #+48]
    207          }
   \   0000000C   0x4770             BX       LR               ;; return
    208          

   \                                 In section .text, align 2, keep-with-next
    209          void CJumpFilter::setParameter(float maxRate, int maxInvalidTime, float integralThresholdGain)
    210          {
    211            this->maxRate = maxRate;
   \                     _ZN11CJumpFilter12setParameterEfif: (+1)
   \   00000000   0xED80 0x0A02      VSTR     S0,[R0, #+8]
    212            this->maxInvalidTime = maxInvalidTime;
   \   00000004   0x6281             STR      R1,[R0, #+40]
    213            this->integralThresholdGain = integralThresholdGain;
   \   00000006   0xEDC0 0x0A0B      VSTR     S1,[R0, #+44]
    214          }
   \   0000000A   0x4770             BX       LR               ;; return
    215          

   \                                 In section .text, align 2, keep-with-next
    216          void CJumpFilter::setParameter(float maxRate, int maxInvalidTime)
    217          {
    218            this->maxRate = maxRate;
   \                     _ZN11CJumpFilter12setParameterEfi: (+1)
   \   00000000   0xED80 0x0A02      VSTR     S0,[R0, #+8]
    219            this->maxInvalidTime = maxInvalidTime;
   \   00000004   0x6281             STR      R1,[R0, #+40]
    220          }
   \   00000006   0x4770             BX       LR               ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          bool CJumpFilter::isValid()
    223          {
    224            return valid;
   \                     _ZN11CJumpFilter7isValidEv: (+1)
   \   00000000   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000004   0x4770             BX       LR               ;; return
    225          }
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void CJumpFilter::setNewDataTime(int t)
    228          {
    229            newDataTime = t;
   \                     _ZN11CJumpFilter14setNewDataTimeEi: (+1)
   \   00000000   0x6201             STR      R1,[R0, #+32]
    230          }
   \   00000002   0x4770             BX       LR               ;; return
    231          

   \                                 In section .text, align 2, keep-with-next
    232          int CJumpFilter::getNewDataTime()
    233          {
    234            return newDataTime;
   \                     _ZN11CJumpFilter14getNewDataTimeEv: (+1)
   \   00000000   0x6A00             LDR      R0,[R0, #+32]
   \   00000002   0x4770             BX       LR               ;; return
    235          }
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void CJumpFilter::checkIsNewData(int t)
    238          {
    239              if(t - oldDataTime > 300)
   \                     _ZN11CJumpFilter14checkIsNewDataEi: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0x1A8A             SUBS     R2,R1,R2
   \   00000004   0xF240 0x132D      MOVW     R3,#+301
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xDB02             BLT.N    ??checkIsNewData_0
    240              {
    241                valid = false;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xF880 0x2034      STRB     R2,[R0, #+52]
    242              }
    243          }
   \                     ??checkIsNewData_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    244          

   \                                 In section .text, align 2, keep-with-next
    245          void CJumpFilter::setValid(bool temp)
    246          {
    247            valid = temp;
   \                     _ZN11CJumpFilter8setValidEb: (+1)
   \   00000000   0xF880 0x1034      STRB     R1,[R0, #+52]
    248          }
   \   00000004   0x4770             BX       LR               ;; return
    249          
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void CoordinateElement::operator= (float newData)
    252          {
    253            this->data = newData;
   \                     _ZN17CoordinateElementaSEf: (+1)
   \   00000000   0xED80 0x0A00      VSTR     S0,[R0, #0]
    254          }
   \   00000004   0x4770             BX       LR               ;; return
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void CoordinateElement::operator+= (float newData)
    257          {
    258            this->data += newData;
   \                     _ZN17CoordinateElementpLEf: (+1)
   \   00000000   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000004   0xEE70 0x0A80      VADD.F32 S1,S1,S0
   \   00000008   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    259          }
   \   0000000C   0x4770             BX       LR               ;; return
    260          

   \                                 In section .text, align 2, keep-with-next
    261          void CoordinateElement::operator+= (CoordinateElement newData)
    262          {
   \                     _ZN17CoordinateElementpLES_: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    263            this->data += newData.data;
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000000A   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000000E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    264          }
   \   00000012   0xB003             ADD      SP,SP,#+12
   \   00000014   0x4770             BX       LR               ;; return
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void CoordinateElement::operator-= (float newData)
    267          {
    268            this->data -= newData;
   \                     _ZN17CoordinateElementmIEf: (+1)
   \   00000000   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000004   0xEE70 0x0AC0      VSUB.F32 S1,S1,S0
   \   00000008   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    269          }
   \   0000000C   0x4770             BX       LR               ;; return
    270          

   \                                 In section .text, align 2, keep-with-next
    271          void CoordinateElement::operator-= (CoordinateElement newData)
    272          {
   \                     _ZN17CoordinateElementmIES_: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    273            this->data -= newData.data;
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000000A   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000000E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    274          }
   \   00000012   0xB003             ADD      SP,SP,#+12
   \   00000014   0x4770             BX       LR               ;; return
    275          

   \                                 In section .text, align 2, keep-with-next
    276          void CoordinateElement::operator*= (float newData)
    277          {
    278            this->data *= newData;
   \                     _ZN17CoordinateElementmLEf: (+1)
   \   00000000   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000004   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000008   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    279          }
   \   0000000C   0x4770             BX       LR               ;; return
    280          

   \                                 In section .text, align 2, keep-with-next
    281          void CoordinateElement::operator*= (CoordinateElement newData)
    282          {
   \                     _ZN17CoordinateElementmLES_: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    283            this->data *= newData.data;
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000000A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000000E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    284          }
   \   00000012   0xB003             ADD      SP,SP,#+12
   \   00000014   0x4770             BX       LR               ;; return
    285          

   \                                 In section .text, align 2, keep-with-next
    286          void CoordinateElement::operator/= (float newData)
    287          {
    288            this->data /= newData;
   \                     _ZN17CoordinateElementdVEf: (+1)
   \   00000000   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000004   0xEEC0 0x0A80      VDIV.F32 S1,S1,S0
   \   00000008   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    289          }
   \   0000000C   0x4770             BX       LR               ;; return
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void CoordinateElement::operator/= (CoordinateElement newData)
    292          {
   \                     _ZN17CoordinateElementdVES_: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    293            this->data /= newData.data;
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000000A   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000000E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    294          }
   \   00000012   0xB003             ADD      SP,SP,#+12
   \   00000014   0x4770             BX       LR               ;; return
    295          
    296          

   \                                 In section .text, align 2, keep-with-next
    297          CoordinateElement::operator float()
    298          {
    299            return this->data;
   \                     _ZN17CoordinateElementcvfEv: (+1)
   \   00000000   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000004   0x4770             BX       LR               ;; return
    300          }
    301          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __vfp CoordinateElement::subobject CoordinateElement(float, float, float)
   \                     _ZN17CoordinateElementC2Efff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN17CoordinateElementC1Efff
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    302          CoordinateElement::CoordinateElement(float D_upperLimit, float D_lowerLimit, float D_smoother)
    303          {
    304            this->D_upperLimit = D_upperLimit;
   \                     _ZN17CoordinateElementC1Efff: (+1)
   \   00000000   0xED80 0x0A05      VSTR     S0,[R0, #+20]
    305            this->D_lowerLimit = D_lowerLimit;
   \   00000004   0xEDC0 0x0A06      VSTR     S1,[R0, #+24]
    306            this->D_smoother   = D_smoother;
   \   00000008   0xED80 0x1A04      VSTR     S2,[R0, #+16]
    307          }
   \   0000000C   0x4770             BX       LR               ;; return
    308          

   \                                 In section .text, align 4, keep-with-next
    309          void CoordinateElement::calculateD(int t)
    310          {
   \                     _ZN17CoordinateElement10calculateDEi: (+1)
   \   00000000   0xEE00 0x1A10      VMOV     S0,R1
    311             if(t != oldDataTime)
   \   00000004   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000008   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   0000000C   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000010   0xEEF1 0xFA10      FMSTAT   
   \   00000014   0xD021             BEQ.N    ??calculateD_0
    312             {
    313              D = D * D_smoother + (data - oldData) / (t - oldDataTime) * 1000 * (1 - D_smoother); 
   \   00000016   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   0000001A   0xED90 0x1A04      VLDR     S2,[R0, #+16]
   \   0000001E   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000022   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000026   0xEDD0 0x1A01      VLDR     S3,[R0, #+4]
   \   0000002A   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   0000002E   0xEEF8 0x1AC0      VCVT.F32.S32 S3,S0
   \   00000032   0xED90 0x2A02      VLDR     S4,[R0, #+8]
   \   00000036   0xEE71 0x1AC2      VSUB.F32 S3,S3,S4
   \   0000003A   0xEE81 0x1A21      VDIV.F32 S2,S2,S3
   \   0000003E   0xEDDF 0x....      VLDR.W   S3,??DataTable3  ;; 0x447a0000
   \   00000042   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   00000046   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   0000004A   0xED90 0x2A04      VLDR     S4,[R0, #+16]
   \   0000004E   0xEE71 0x1AC2      VSUB.F32 S3,S3,S4
   \   00000052   0xEE41 0x0A21      VMLA.F32 S1,S2,S3
   \   00000056   0xEDC0 0x0A03      VSTR     S1,[R0, #+12]
    314             }
    315             oldData = data;
   \                     ??calculateD_0: (+1)
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x6041             STR      R1,[R0, #+4]
    316             oldDataTime = t;
   \   0000005E   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000062   0xEDC0 0x0A02      VSTR     S1,[R0, #+8]
    317             if(D > D_upperLimit) 
   \   00000066   0xEDD0 0x0A05      VLDR     S1,[R0, #+20]
   \   0000006A   0xED90 0x1A03      VLDR     S2,[R0, #+12]
   \   0000006E   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000072   0xEEF1 0xFA10      FMSTAT   
   \   00000076   0xD502             BPL.N    ??calculateD_1
    318             {
    319               D = D_upperLimit;
   \   00000078   0x6941             LDR      R1,[R0, #+20]
   \   0000007A   0x60C1             STR      R1,[R0, #+12]
   \   0000007C   0xE00A             B.N      ??calculateD_2
    320             }
    321             else if(D < D_lowerLimit) 
   \                     ??calculateD_1: (+1)
   \   0000007E   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   00000082   0xED90 0x1A06      VLDR     S2,[R0, #+24]
   \   00000086   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   0000008A   0xEEF1 0xFA10      FMSTAT   
   \   0000008E   0xD501             BPL.N    ??calculateD_2
    322             {
    323               D = D_lowerLimit;
   \   00000090   0x6981             LDR      R1,[R0, #+24]
   \   00000092   0x60C1             STR      R1,[R0, #+12]
    324             }
    325          }
   \                     ??calculateD_2: (+1)
   \   00000094   0x4770             BX       LR               ;; return
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void timeWindowIntegral::update(float newData)
    328          {
   \                     _ZN18timeWindowIntegral6updateEf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    329            newData *= 0.002;
   \   00000004   0xEE10 0x0A10      VMOV     R0,S0
   \   00000008   0x.... 0x....      BL       __aeabi_f2d
   \   0000000C   0x....             LDR.N    R2,??DataTable4  ;; 0xd2f1a9fc
   \   0000000E   0x....             LDR.N    R3,??DataTable4_2  ;; 0x3f60624d
   \   00000010   0x.... 0x....      BL       __aeabi_dmul
   \   00000014   0x.... 0x....      BL       __aeabi_d2f
   \   00000018   0xEE00 0x0A10      VMOV     S0,R0
    330            sum -= data[index];
   \   0000001C   0xF8D4 0x07D4      LDR      R0,[R4, #+2004]
   \   00000020   0xEE00 0x0A90      VMOV     S1,R0
   \   00000024   0xF8D4 0x07D0      LDR      R0,[R4, #+2000]
   \   00000028   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000002C   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000030   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000034   0xF204 0x70D4      ADDW     R0,R4,#+2004
   \   00000038   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    331            sum += newData;
   \   0000003C   0xF8D4 0x07D4      LDR      R0,[R4, #+2004]
   \   00000040   0xEE00 0x0A90      VMOV     S1,R0
   \   00000044   0xEE70 0x0A80      VADD.F32 S1,S1,S0
   \   00000048   0xF204 0x70D4      ADDW     R0,R4,#+2004
   \   0000004C   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    332            data[index] = newData;
   \   00000050   0xF8D4 0x07D0      LDR      R0,[R4, #+2000]
   \   00000054   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000058   0xED80 0x0A00      VSTR     S0,[R0, #0]
    333            index++;
   \   0000005C   0xF8D4 0x07D0      LDR      R0,[R4, #+2000]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0xF8C4 0x07D0      STR      R0,[R4, #+2000]
    334            if(index > timeWindow/2) //2是控制周期
   \   00000066   0xF8D4 0x07D8      LDR      R0,[R4, #+2008]
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000070   0xF8D4 0x17D0      LDR      R1,[R4, #+2000]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xDA02             BGE.N    ??update_0
    335            {
    336              index = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF8C4 0x07D0      STR      R0,[R4, #+2000]
    337            }
    338          }
   \                     ??update_0: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x3F60624D         DC32     0x3f60624d

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CJumpFilter::accumulate(float)
       0   CJumpFilter::checkIsNewData(int)
       0   CJumpFilter::getNewDataTime()
       0   CJumpFilter::isValid()
      48   CJumpFilter::newData(float, float, int)
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48 __aeabi_cdcmple
       0   CJumpFilter::newData(float, int)
       0   CJumpFilter::newData1(float, int)
       0   CJumpFilter::newData3(float, int)
       0   CJumpFilter::setNewDataTime(int)
       0   CJumpFilter::setParameter(float, int)
       0   CJumpFilter::setParameter(float, int, float)
       0   CJumpFilter::setValid(bool)
       0   CoordinateElement::CoordinateElement(float, float, float)
       0   CoordinateElement::calculateD(int)
       0   CoordinateElement::operator float()
      12   CoordinateElement::operator*=(CoordinateElement)
       0   CoordinateElement::operator*=(float)
      12   CoordinateElement::operator+=(CoordinateElement)
       0   CoordinateElement::operator+=(float)
      12   CoordinateElement::operator-=(CoordinateElement)
       0   CoordinateElement::operator-=(float)
      12   CoordinateElement::operator/=(CoordinateElement)
       0   CoordinateElement::operator/=(float)
       0   CoordinateElement::operator=(float)
       8   CoordinateElement::subobject CoordinateElement(float, float, float)
         8   -> CoordinateElement::CoordinateElement(float, float, float)
       8   timeWindowIntegral::update(float)
         8   -> __aeabi_d2f
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      14  CJumpFilter::accumulate(float)
      20  CJumpFilter::checkIsNewData(int)
       4  CJumpFilter::getNewDataTime()
       6  CJumpFilter::isValid()
     284  CJumpFilter::newData(float, float, int)
     168  CJumpFilter::newData(float, int)
     182  CJumpFilter::newData1(float, int)
     208  CJumpFilter::newData3(float, int)
       4  CJumpFilter::setNewDataTime(int)
       8  CJumpFilter::setParameter(float, int)
      12  CJumpFilter::setParameter(float, int, float)
       6  CJumpFilter::setValid(bool)
      14  CoordinateElement::CoordinateElement(float, float, float)
     150  CoordinateElement::calculateD(int)
       6  CoordinateElement::operator float()
      22  CoordinateElement::operator*=(CoordinateElement)
      14  CoordinateElement::operator*=(float)
      22  CoordinateElement::operator+=(CoordinateElement)
      14  CoordinateElement::operator+=(float)
      22  CoordinateElement::operator-=(CoordinateElement)
      14  CoordinateElement::operator-=(float)
      22  CoordinateElement::operator/=(CoordinateElement)
      14  CoordinateElement::operator/=(float)
       6  CoordinateElement::operator=(float)
      12  CoordinateElement::subobject CoordinateElement(float, float, float)
     128  timeWindowIntegral::update(float)

 
 1 392 bytes in section .text
 
 1 392 bytes of CODE memory

Errors: none
Warnings: none
