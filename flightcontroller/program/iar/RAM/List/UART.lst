###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       18/Jun/2018  19:48:02
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW2FA1.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List\UART.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj\UART.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
      1          /**
      2           * @file UART.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief UART底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn)
   \                     _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0xe000e100
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0x095B             LSRS     R3,R3,#+5
   \   00000018   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn)
   \                     _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD40A             BMI.N    ??__NVIC_DisableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0xe000e180
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0x095B             LSRS     R3,R3,#+5
   \   00000018   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
     23          #include "UART.h"
     24          
     25          //用户接收中断函数入口地址数组

   \                                 In section .bss, align 4
     26          UART_ISR_CALLBACK UART_R_ISR[6];
   \                     UART_R_ISR:
   \   00000000                      DS8 24
     27          //用户发送中断函数入口地址数组

   \                                 In section .bss, align 4
     28          UART_ISR_CALLBACK UART_T_ISR[6];  
   \                     UART_T_ISR:
   \   00000000                      DS8 24
     29          
     30          
     31          /*
     32           * UART_Init
     33           * 初始化UART通道、波特率、发送接收引脚
     34           * 
     35           * 参数:
     36           *    uart_init_structure--UART初始化结构体，
     37           *                        具体定义见UART_InitTypeDef
     38           *
     39           * 输出:
     40           *    无
     41           *
     42           */

   \                                 In section .text, align 2, keep-with-next
     43          void UART_Init(UART_InitTypeDef uart_init_structure)
     44          {
   \                     UART_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
     45            register uint16 sbr, brfa;
     46            uint32 sysclk;
     47            uint8 temp, x ,len;
     48            UART_Type *uartx = uart_init_structure.UART_Uartx;
   \   00000006   0x9B09             LDR      R3,[SP, #+36]
     49            uint32 baud = uart_init_structure.UART_BaudRate;
   \   00000008   0x980A             LDR      R0,[SP, #+40]
     50            PortPinsEnum_Type tx_pin = uart_init_structure.UART_TxPin;
   \   0000000A   0xF89D 0x402C      LDRB     R4,[SP, #+44]
     51            PortPinsEnum_Type rx_pin = uart_init_structure.UART_RxPin;
   \   0000000E   0xF89D 0x502D      LDRB     R5,[SP, #+45]
     52            UART_ISR_CALLBACK rx_isr = uart_init_structure.UART_RxIsr;
   \   00000012   0x9E0E             LDR      R6,[SP, #+56]
     53            UART_ISR_CALLBACK tx_isr = uart_init_structure.UART_TxIsr;
   \   00000014   0x9F0F             LDR      R7,[SP, #+60]
     54            
     55            if(baud == NULL)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD102             BNE.N    ??UART_Init_0
     56            {
     57              baud = 9600;
   \   0000001A   0xF44F 0x5116      MOV      R1,#+9600
   \   0000001E   0x0008             MOVS     R0,R1
     58            }
     59            
     60            //使能选中的UART串口通道时钟，相应GPIO的UART复用功能   
     61            if(uartx == UART0)
   \                     ??UART_Init_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \   00000024   0x428B             CMP      R3,R1
   \   00000026   0xD143             BNE.N    ??UART_Init_1
     62            {
     63              x = 0;
   \   00000028   0xF05F 0x0E00      MOVS     LR,#+0
     64              sysclk = g_core_clock;
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000030   0xF8D1 0xC000      LDR      R12,[R1, #+0]
     65              SIM->SCGC4 |= SIM_SCGC4_UART0_MASK;
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   0000003E   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x40048034
   \   00000042   0xF8C8 0x1000      STR      R1,[R8, #+0]
     66              
     67              if(tx_pin == PTA2)
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C02             CMP      R4,#+2
   \   0000004A   0xD106             BNE.N    ??UART_Init_2
     68                PORTA->PCR[2] = PORT_PCR_MUX(2); 
   \   0000004C   0xF44F 0x7100      MOV      R1,#+512
   \   00000050   0x.... 0x....      LDR.W    R8,??DataTable13_5  ;; 0x40049008
   \   00000054   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000058   0xE00F             B.N      ??UART_Init_3
     69              else if(tx_pin == PTA14)
   \                     ??UART_Init_2: (+1)
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2C0E             CMP      R4,#+14
   \   0000005E   0xD106             BNE.N    ??UART_Init_4
     70                PORTA->PCR[14] = PORT_PCR_MUX(3); 
   \   00000060   0xF44F 0x7140      MOV      R1,#+768
   \   00000064   0x.... 0x....      LDR.W    R8,??DataTable13_6  ;; 0x40049038
   \   00000068   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000006C   0xE005             B.N      ??UART_Init_3
     71              else
     72                PORTB->PCR[17] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_4: (+1)
   \   0000006E   0xF44F 0x7140      MOV      R1,#+768
   \   00000072   0x.... 0x....      LDR.W    R8,??DataTable13_7  ;; 0x4004a044
   \   00000076   0xF8C8 0x1000      STR      R1,[R8, #+0]
     73              
     74              if(rx_pin == PTA1)
   \                     ??UART_Init_3: (+1)
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D01             CMP      R5,#+1
   \   0000007E   0xD106             BNE.N    ??UART_Init_5
     75                PORTA->PCR[1] = PORT_PCR_MUX(2); 
   \   00000080   0xF44F 0x7100      MOV      R1,#+512
   \   00000084   0x.... 0x....      LDR.W    R8,??DataTable13_8  ;; 0x40049004
   \   00000088   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000008C   0xE106             B.N      ??UART_Init_6
     76              else if(rx_pin == PTA15)
   \                     ??UART_Init_5: (+1)
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2D0F             CMP      R5,#+15
   \   00000092   0xD106             BNE.N    ??UART_Init_7
     77                PORTA->PCR[15] = PORT_PCR_MUX(3); 
   \   00000094   0xF44F 0x7140      MOV      R1,#+768
   \   00000098   0x.... 0x....      LDR.W    R8,??DataTable13_9  ;; 0x4004903c
   \   0000009C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000000A0   0xE0FC             B.N      ??UART_Init_6
     78              else
     79                PORTB->PCR[16] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_7: (+1)
   \   000000A2   0xF44F 0x7140      MOV      R1,#+768
   \   000000A6   0x.... 0x....      LDR.W    R8,??DataTable13_10  ;; 0x4004a040
   \   000000AA   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000000AE   0xE0F5             B.N      ??UART_Init_6
     80            }
     81            else
     82            {
     83              if (uartx == UART1)
   \                     ??UART_Init_1: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \   000000B4   0x428B             CMP      R3,R1
   \   000000B6   0xD12F             BNE.N    ??UART_Init_8
     84              {
     85                x = 1;
   \   000000B8   0xF05F 0x0E01      MOVS     LR,#+1
     86                sysclk = g_core_clock;
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000C0   0xF8D1 0xC000      LDR      R12,[R1, #+0]
     87                SIM->SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   000000CE   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x40048034
   \   000000D2   0xF8C8 0x1000      STR      R1,[R8, #+0]
     88                
     89                if(tx_pin == PTE0)   
   \   000000D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D8   0x2C7C             CMP      R4,#+124
   \   000000DA   0xD106             BNE.N    ??UART_Init_9
     90                  PORTE->PCR[0] = PORT_PCR_MUX(3); 
   \   000000DC   0xF44F 0x7140      MOV      R1,#+768
   \   000000E0   0x.... 0x....      LDR.W    R8,??DataTable13_12  ;; 0x4004d000
   \   000000E4   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000000E8   0xE005             B.N      ??UART_Init_10
     91                else
     92                  PORTC->PCR[4] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_9: (+1)
   \   000000EA   0xF44F 0x7140      MOV      R1,#+768
   \   000000EE   0x.... 0x....      LDR.W    R8,??DataTable13_13  ;; 0x4004b010
   \   000000F2   0xF8C8 0x1000      STR      R1,[R8, #+0]
     93                
     94                if(rx_pin == PTE1)
   \                     ??UART_Init_10: (+1)
   \   000000F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F8   0x2D7D             CMP      R5,#+125
   \   000000FA   0xD106             BNE.N    ??UART_Init_11
     95                  PORTE->PCR[1] = PORT_PCR_MUX(3); 
   \   000000FC   0xF44F 0x7140      MOV      R1,#+768
   \   00000100   0x.... 0x....      LDR.W    R8,??DataTable13_14  ;; 0x4004d004
   \   00000104   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000108   0xE0C8             B.N      ??UART_Init_6
     96                else
     97                  PORTC->PCR[3] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_11: (+1)
   \   0000010A   0xF44F 0x7140      MOV      R1,#+768
   \   0000010E   0x.... 0x....      LDR.W    R8,??DataTable13_15  ;; 0x4004b00c
   \   00000112   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000116   0xE0C1             B.N      ??UART_Init_6
     98                
     99          
    100              }
    101              else
    102              {
    103                sysclk = g_bus_clock;
   \                     ??UART_Init_8: (+1)
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable13_16
   \   0000011C   0xF8D1 0xC000      LDR      R12,[R1, #+0]
    104                if (uartx == UART2)
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \   00000124   0x428B             CMP      R3,R1
   \   00000126   0xD117             BNE.N    ??UART_Init_12
    105                {
    106                  x = 2;
   \   00000128   0xF05F 0x0E02      MOVS     LR,#+2
    107                  SIM->SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \   00000130   0x6809             LDR      R1,[R1, #+0]
   \   00000132   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   00000136   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x40048034
   \   0000013A   0xF8C8 0x1000      STR      R1,[R8, #+0]
    108                  
    109                  PORTD->PCR[3] = PORT_PCR_MUX(3); 
   \   0000013E   0xF44F 0x7140      MOV      R1,#+768
   \   00000142   0x.... 0x....      LDR.W    R8,??DataTable13_18  ;; 0x4004c00c
   \   00000146   0xF8C8 0x1000      STR      R1,[R8, #+0]
    110                  PORTD->PCR[2] = PORT_PCR_MUX(3);
   \   0000014A   0xF44F 0x7140      MOV      R1,#+768
   \   0000014E   0x.... 0x....      LDR.W    R8,??DataTable13_19  ;; 0x4004c008
   \   00000152   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000156   0xE0A1             B.N      ??UART_Init_6
    111                }
    112                else
    113                {
    114                  if(uartx == UART3)
   \                     ??UART_Init_12: (+1)
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \   0000015C   0x428B             CMP      R3,R1
   \   0000015E   0xD13F             BNE.N    ??UART_Init_13
    115                  {
    116                    x = 3;
   \   00000160   0xF05F 0x0E03      MOVS     LR,#+3
    117                    SIM->SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \   00000168   0x6809             LDR      R1,[R1, #+0]
   \   0000016A   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \   0000016E   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x40048034
   \   00000172   0xF8C8 0x1000      STR      R1,[R8, #+0]
    118                    
    119                    if(tx_pin == PTE4)
   \   00000176   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   0x2C80             CMP      R4,#+128
   \   0000017A   0xD106             BNE.N    ??UART_Init_14
    120                      PORTE->PCR[4] = PORT_PCR_MUX(3); 
   \   0000017C   0xF44F 0x7140      MOV      R1,#+768
   \   00000180   0x.... 0x....      LDR.W    R8,??DataTable13_21  ;; 0x4004d010
   \   00000184   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000188   0xE00F             B.N      ??UART_Init_15
    121                    else if(tx_pin == PTB11)
   \                     ??UART_Init_14: (+1)
   \   0000018A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000018C   0x2C2B             CMP      R4,#+43
   \   0000018E   0xD106             BNE.N    ??UART_Init_16
    122                      PORTB->PCR[11] = PORT_PCR_MUX(3); 
   \   00000190   0xF44F 0x7140      MOV      R1,#+768
   \   00000194   0x.... 0x....      LDR.W    R8,??DataTable13_22  ;; 0x4004a02c
   \   00000198   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000019C   0xE005             B.N      ??UART_Init_15
    123                    else 
    124                      PORTC->PCR[17] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_16: (+1)
   \   0000019E   0xF44F 0x7140      MOV      R1,#+768
   \   000001A2   0x.... 0x....      LDR.W    R8,??DataTable13_23  ;; 0x4004b044
   \   000001A6   0xF8C8 0x1000      STR      R1,[R8, #+0]
    125                    
    126                    if(rx_pin == PTE5)
   \                     ??UART_Init_15: (+1)
   \   000001AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AC   0x2D81             CMP      R5,#+129
   \   000001AE   0xD106             BNE.N    ??UART_Init_17
    127                      PORTE->PCR[5] = PORT_PCR_MUX(3); 
   \   000001B0   0xF44F 0x7140      MOV      R1,#+768
   \   000001B4   0x.... 0x....      LDR.W    R8,??DataTable13_24  ;; 0x4004d014
   \   000001B8   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000001BC   0xE06E             B.N      ??UART_Init_6
    128                    else if(rx_pin == PTB10)
   \                     ??UART_Init_17: (+1)
   \   000001BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C0   0x2D2A             CMP      R5,#+42
   \   000001C2   0xD106             BNE.N    ??UART_Init_18
    129                      PORTB->PCR[10] = PORT_PCR_MUX(3); 
   \   000001C4   0xF44F 0x7140      MOV      R1,#+768
   \   000001C8   0x.... 0x....      LDR.W    R8,??DataTable13_25  ;; 0x4004a028
   \   000001CC   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000001D0   0xE064             B.N      ??UART_Init_6
    130                    else
    131                      PORTC->PCR[16] = PORT_PCR_MUX(3);
   \                     ??UART_Init_18: (+1)
   \   000001D2   0xF44F 0x7140      MOV      R1,#+768
   \   000001D6   0x.... 0x....      LDR.W    R8,??DataTable13_26  ;; 0x4004b040
   \   000001DA   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   000001DE   0xE05D             B.N      ??UART_Init_6
    132                  }
    133                  else
    134                  {
    135                    if(uartx == UART4)
   \                     ??UART_Init_13: (+1)
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \   000001E4   0x428B             CMP      R3,R1
   \   000001E6   0xD12B             BNE.N    ??UART_Init_19
    136                    {
    137                      x = 4;
   \   000001E8   0xF05F 0x0E04      MOVS     LR,#+4
    138                      SIM->SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable13_28  ;; 0x40048028
   \   000001F0   0x6809             LDR      R1,[R1, #+0]
   \   000001F2   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   000001F6   0x.... 0x....      LDR.W    R8,??DataTable13_28  ;; 0x40048028
   \   000001FA   0xF8C8 0x1000      STR      R1,[R8, #+0]
    139                      
    140                      if(tx_pin == PTE24)
   \   000001FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000200   0x2C94             CMP      R4,#+148
   \   00000202   0xD106             BNE.N    ??UART_Init_20
    141                        PORTE->PCR[24] = PORT_PCR_MUX(3); 
   \   00000204   0xF44F 0x7140      MOV      R1,#+768
   \   00000208   0x.... 0x....      LDR.W    R8,??DataTable13_29  ;; 0x4004d060
   \   0000020C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000210   0xE005             B.N      ??UART_Init_21
    142                      else
    143                        PORTC->PCR[15] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_20: (+1)
   \   00000212   0xF44F 0x7140      MOV      R1,#+768
   \   00000216   0x.... 0x....      LDR.W    R8,??DataTable13_30  ;; 0x4004b03c
   \   0000021A   0xF8C8 0x1000      STR      R1,[R8, #+0]
    144                      
    145                      if(rx_pin == PTE25)
   \                     ??UART_Init_21: (+1)
   \   0000021E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000220   0x2D95             CMP      R5,#+149
   \   00000222   0xD106             BNE.N    ??UART_Init_22
    146                        PORTE->PCR[25] = PORT_PCR_MUX(3); 
   \   00000224   0xF44F 0x7140      MOV      R1,#+768
   \   00000228   0x.... 0x....      LDR.W    R8,??DataTable13_31  ;; 0x4004d064
   \   0000022C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000230   0xE034             B.N      ??UART_Init_6
    147                      else
    148                        PORTC->PCR[14] = PORT_PCR_MUX(3);
   \                     ??UART_Init_22: (+1)
   \   00000232   0xF44F 0x7140      MOV      R1,#+768
   \   00000236   0x.... 0x....      LDR.W    R8,??DataTable13_32  ;; 0x4004b038
   \   0000023A   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000023E   0xE02D             B.N      ??UART_Init_6
    149                    }
    150                    else
    151                    {
    152                      x = 5;
   \                     ??UART_Init_19: (+1)
   \   00000240   0xF05F 0x0E05      MOVS     LR,#+5
    153                      uartx = UART5;
   \   00000244   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \   00000248   0x000B             MOVS     R3,R1
    154                      SIM->SCGC1 |= SIM_SCGC1_UART5_MASK;
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable13_28  ;; 0x40048028
   \   0000024E   0x6809             LDR      R1,[R1, #+0]
   \   00000250   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   00000254   0x.... 0x....      LDR.W    R8,??DataTable13_28  ;; 0x40048028
   \   00000258   0xF8C8 0x1000      STR      R1,[R8, #+0]
    155                      
    156                      if(tx_pin == PTD9)
   \   0000025C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000025E   0x2C65             CMP      R4,#+101
   \   00000260   0xD106             BNE.N    ??UART_Init_23
    157                        PORTD->PCR[9] = PORT_PCR_MUX(3); 
   \   00000262   0xF44F 0x7140      MOV      R1,#+768
   \   00000266   0x.... 0x....      LDR.W    R8,??DataTable13_34  ;; 0x4004c024
   \   0000026A   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000026E   0xE005             B.N      ??UART_Init_24
    158                      else
    159                        PORTE->PCR[8] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_23: (+1)
   \   00000270   0xF44F 0x7140      MOV      R1,#+768
   \   00000274   0x.... 0x....      LDR.W    R8,??DataTable13_35  ;; 0x4004d020
   \   00000278   0xF8C8 0x1000      STR      R1,[R8, #+0]
    160                      
    161                      if(rx_pin == PTD8)
   \                     ??UART_Init_24: (+1)
   \   0000027C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000027E   0x2D64             CMP      R5,#+100
   \   00000280   0xD106             BNE.N    ??UART_Init_25
    162                        PORTD->PCR[8] = PORT_PCR_MUX(3); 
   \   00000282   0xF44F 0x7140      MOV      R1,#+768
   \   00000286   0x.... 0x....      LDR.W    R8,??DataTable13_36  ;; 0x4004c020
   \   0000028A   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   0000028E   0xE005             B.N      ??UART_Init_6
    163                      else
    164                        PORTE->PCR[9] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_25: (+1)
   \   00000290   0xF44F 0x7140      MOV      R1,#+768
   \   00000294   0x.... 0x....      LDR.W    R8,??DataTable13_37  ;; 0x4004d024
   \   00000298   0xF8C8 0x1000      STR      R1,[R8, #+0]
    165                    }
    166                  }
    167                }
    168              }
    169            }
    170            
    171            //在配置好其他寄存器前，先关闭发送器和接收器
    172            uartx->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
   \                     ??UART_Init_6: (+1)
   \   0000029C   0x78D9             LDRB     R1,[R3, #+3]
   \   0000029E   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   000002A2   0x70D9             STRB     R1,[R3, #+3]
    173            
    174            //配置UART为 8位, 无奇偶校验 */
    175            uartx->C1 = 0;	
   \   000002A4   0x2100             MOVS     R1,#+0
   \   000002A6   0x7099             STRB     R1,[R3, #+2]
    176            
    177            //计算波特率
    178            sbr = (uint16)((sysclk)/(baud * 16));
   \   000002A8   0x0101             LSLS     R1,R0,#+4
   \   000002AA   0xFBBC 0xF8F1      UDIV     R8,R12,R1
    179            
    180            //保存UARTx_BDH寄存器中除了SBR的值
    181            temp = uartx->BDH & ~(UART_BDH_SBR(0x1F));
   \   000002AE   0x7819             LDRB     R1,[R3, #+0]
   \   000002B0   0xF011 0x01E0      ANDS     R1,R1,#0xE0
    182            
    183            uartx->BDH = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   000002B4   0xF3C8 0x2904      UBFX     R9,R8,#+8,#+5
   \   000002B8   0xEA59 0x0901      ORRS     R9,R9,R1
   \   000002BC   0xF883 0x9000      STRB     R9,[R3, #+0]
    184            uartx->BDL = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   000002C0   0xF883 0x8001      STRB     R8,[R3, #+1]
    185            
    186            //配置波特率的微调分数
    187            brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
   \   000002C4   0xEA5F 0x194C      LSLS     R9,R12,#+5
   \   000002C8   0xEA5F 0x1A00      LSLS     R10,R0,#+4
   \   000002CC   0xFBB9 0xF9FA      UDIV     R9,R9,R10
   \   000002D0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000002D4   0xEBB9 0x1948      SUBS     R9,R9,R8, LSL #+5
    188            
    189            //保存UARTx_C4寄存器中除了BRFA的值
    190            temp = uartx->C4 & ~(UART_C4_BRFA(0x1F));
   \   000002D8   0xF893 0xA00A      LDRB     R10,[R3, #+10]
   \   000002DC   0xF01A 0x0AE0      ANDS     R10,R10,#0xE0
    191            
    192            uartx->C4 = temp |  UART_C4_BRFA(brfa);    
   \   000002E0   0xF019 0x0B1F      ANDS     R11,R9,#0x1F
   \   000002E4   0xEA5B 0x0B0A      ORRS     R11,R11,R10
   \   000002E8   0xF883 0xB00A      STRB     R11,[R3, #+10]
    193            
    194            //配置UART接收DMA方式
    195            if( uart_init_structure.UART_RxDMAEnable == TRUE 
    196              && uart_init_structure.UART_RxIntEnable == TRUE )
   \   000002EC   0xF89D 0xB031      LDRB     R11,[SP, #+49]
   \   000002F0   0xF1BB 0x0F01      CMP      R11,#+1
   \   000002F4   0xD10C             BNE.N    ??UART_Init_26
   \   000002F6   0xF89D 0x102E      LDRB     R1,[SP, #+46]
   \   000002FA   0x2901             CMP      R1,#+1
   \   000002FC   0xD108             BNE.N    ??UART_Init_26
    197            {
    198              //使能接收中断或者DMA
    199              uartx->C2 |= UART_C2_RIE_MASK;
   \   000002FE   0x78D9             LDRB     R1,[R3, #+3]
   \   00000300   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000304   0x70D9             STRB     R1,[R3, #+3]
    200              //使能接收DMA
    201              uartx->C5 |= UART_C5_RDMAS_MASK;
   \   00000306   0x7AD9             LDRB     R1,[R3, #+11]
   \   00000308   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000030C   0x72D9             STRB     R1,[R3, #+11]
   \   0000030E   0xE019             B.N      ??UART_Init_27
    202            }//配置UART接收中断方式
    203            else if(uart_init_structure.UART_RxIntEnable == TRUE 
    204                  && rx_isr != NULL)
   \                     ??UART_Init_26: (+1)
   \   00000310   0xF89D 0x102E      LDRB     R1,[SP, #+46]
   \   00000314   0x2901             CMP      R1,#+1
   \   00000316   0xD10D             BNE.N    ??UART_Init_28
   \   00000318   0x0031             MOVS     R1,R6
   \   0000031A   0x2900             CMP      R1,#+0
   \   0000031C   0xD00A             BEQ.N    ??UART_Init_28
    205            {
    206              //使能接收中断
    207              uartx->C2 |= UART_C2_RIE_MASK; 
   \   0000031E   0x78D9             LDRB     R1,[R3, #+3]
   \   00000320   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000324   0x70D9             STRB     R1,[R3, #+3]
    208              UART_R_ISR[x] = rx_isr;
   \   00000326   0x.... 0x....      LDR.W    R1,??DataTable13_38
   \   0000032A   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   0000032E   0xF841 0x602E      STR      R6,[R1, LR, LSL #+2]
   \   00000332   0xE007             B.N      ??UART_Init_27
    209            } 
    210            else
    211            {
    212              uartx->C2 &= ~(UART_C2_RIE_MASK); 
   \                     ??UART_Init_28: (+1)
   \   00000334   0x78D9             LDRB     R1,[R3, #+3]
   \   00000336   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   0000033A   0x70D9             STRB     R1,[R3, #+3]
    213              uartx->C5 &= ~(UART_C5_RDMAS_MASK);
   \   0000033C   0x7AD9             LDRB     R1,[R3, #+11]
   \   0000033E   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000342   0x72D9             STRB     R1,[R3, #+11]
    214            }
    215            
    216            //配置UART接收DMA方式
    217            if( uart_init_structure.UART_TxDMAEnable == TRUE 
    218              && uart_init_structure.UART_TxIntEnable == TRUE )
   \                     ??UART_Init_27: (+1)
   \   00000344   0xF89D 0x1030      LDRB     R1,[SP, #+48]
   \   00000348   0x2901             CMP      R1,#+1
   \   0000034A   0xD10C             BNE.N    ??UART_Init_29
   \   0000034C   0xF89D 0x102F      LDRB     R1,[SP, #+47]
   \   00000350   0x2901             CMP      R1,#+1
   \   00000352   0xD108             BNE.N    ??UART_Init_29
    219            {
    220              //使能发送中断或者DMA
    221              uartx->C2 |= UART_C2_TIE_MASK;
   \   00000354   0x78D9             LDRB     R1,[R3, #+3]
   \   00000356   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000035A   0x70D9             STRB     R1,[R3, #+3]
    222              //使能接收DMA
    223              uartx->C5 |= UART_C5_TDMAS_MASK;
   \   0000035C   0x7AD9             LDRB     R1,[R3, #+11]
   \   0000035E   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000362   0x72D9             STRB     R1,[R3, #+11]
   \   00000364   0xE019             B.N      ??UART_Init_30
    224            }//配置UART发送中断方式
    225            else if(uart_init_structure.UART_TxIntEnable == TRUE 
    226                  && tx_isr != NULL)
   \                     ??UART_Init_29: (+1)
   \   00000366   0xF89D 0x102F      LDRB     R1,[SP, #+47]
   \   0000036A   0x2901             CMP      R1,#+1
   \   0000036C   0xD10D             BNE.N    ??UART_Init_31
   \   0000036E   0x0039             MOVS     R1,R7
   \   00000370   0x2900             CMP      R1,#+0
   \   00000372   0xD00A             BEQ.N    ??UART_Init_31
    227            {
    228              //使能发送中断
    229              uartx->C2 |= UART_C2_TIE_MASK; 
   \   00000374   0x78D9             LDRB     R1,[R3, #+3]
   \   00000376   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000037A   0x70D9             STRB     R1,[R3, #+3]
    230              UART_T_ISR[x] = tx_isr;
   \   0000037C   0x.... 0x....      LDR.W    R1,??DataTable13_39
   \   00000380   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000384   0xF841 0x702E      STR      R7,[R1, LR, LSL #+2]
   \   00000388   0xE007             B.N      ??UART_Init_30
    231            } 
    232            else
    233            {
    234              uartx->C2 &= ~(UART_C2_TIE_MASK);
   \                     ??UART_Init_31: (+1)
   \   0000038A   0x78D9             LDRB     R1,[R3, #+3]
   \   0000038C   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000390   0x70D9             STRB     R1,[R3, #+3]
    235              uartx->C5 &= ~(UART_C5_TDMAS_MASK);
   \   00000392   0x7AD9             LDRB     R1,[R3, #+11]
   \   00000394   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000398   0x72D9             STRB     R1,[R3, #+11]
    236            }
    237            
    238            //配置UART FIFO 功能
    239            if( (uartx->C2 & UART_C2_RE_MASK) == 0 
    240               && uart_init_structure.RxFIFO.FIFO_Enable == TRUE)
   \                     ??UART_Init_30: (+1)
   \   0000039A   0x78D9             LDRB     R1,[R3, #+3]
   \   0000039C   0x0749             LSLS     R1,R1,#+29
   \   0000039E   0xD427             BMI.N    ??UART_Init_32
   \   000003A0   0xF89D 0x1035      LDRB     R1,[SP, #+53]
   \   000003A4   0x2901             CMP      R1,#+1
   \   000003A6   0xD123             BNE.N    ??UART_Init_32
    241            {
    242              //使能 UART 接收FIFO
    243              uartx->PFIFO |= UART_PFIFO_RXFE_MASK;
   \   000003A8   0x7C19             LDRB     R1,[R3, #+16]
   \   000003AA   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000003AE   0x7419             STRB     R1,[R3, #+16]
    244              
    245              if(uart_init_structure.RxFIFO.FIFO_BufFlow_IntEnable == TRUE)
   \   000003B0   0xF89D 0x1036      LDRB     R1,[SP, #+54]
   \   000003B4   0x2901             CMP      R1,#+1
   \   000003B6   0xD103             BNE.N    ??UART_Init_33
    246              {
    247                uartx->CFIFO |= UART_CFIFO_RXUFE_MASK;
   \   000003B8   0x7C59             LDRB     R1,[R3, #+17]
   \   000003BA   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   000003BE   0x7459             STRB     R1,[R3, #+17]
    248              }
    249              //  UART1->PFIFO = 0x99;//TX and RX
    250              //  UART1->CFIFO |= 0xC0;
    251              //读取 FIFO buffer 深度
    252              len = (uint8)( uartx->PFIFO & UART_PFIFO_RXFIFOSIZE_MASK ) >> UART_PFIFO_RXFIFOSIZE_SHIFT;
   \                     ??UART_Init_33: (+1)
   \   000003C0   0x7C19             LDRB     R1,[R3, #+16]
   \   000003C2   0xF011 0x0107      ANDS     R1,R1,#0x7
    253              len = len > 0 ? 1 << (len + 1) : 1;
   \   000003C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003C8   0x2900             CMP      R1,#+0
   \   000003CA   0xD005             BEQ.N    ??UART_Init_34
   \   000003CC   0x2201             MOVS     R2,#+1
   \   000003CE   0x1C49             ADDS     R1,R1,#+1
   \   000003D0   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000003D4   0x000A             MOVS     R2,R1
   \   000003D6   0xE000             B.N      ??UART_Init_35
   \                     ??UART_Init_34: (+1)
   \   000003D8   0x2201             MOVS     R2,#+1
    254              //如果Rx FIFO buffer中的DataWords 大于等于 UART_FIFOWaterMark
    255              //将产生中断或者DMA信号，取决C2_RIE和C5_RDMAS的状态
    256              if( uart_init_structure.RxFIFO.FIFO_WaterMark > len )
   \                     ??UART_Init_35: (+1)
   \   000003DA   0x0011             MOVS     R1,R2
   \   000003DC   0xF89D 0xB037      LDRB     R11,[SP, #+55]
   \   000003E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003E2   0x4559             CMP      R1,R11
   \   000003E4   0xD201             BCS.N    ??UART_Init_36
    257              {
    258                uartx->RWFIFO = UART_RWFIFO_RXWATER(len);
   \   000003E6   0x755A             STRB     R2,[R3, #+21]
   \   000003E8   0xE002             B.N      ??UART_Init_32
    259              }
    260              else
    261              {
    262                uartx->RWFIFO = UART_RWFIFO_RXWATER(uart_init_structure.RxFIFO.FIFO_WaterMark);
   \                     ??UART_Init_36: (+1)
   \   000003EA   0xF89D 0x1037      LDRB     R1,[SP, #+55]
   \   000003EE   0x7559             STRB     R1,[R3, #+21]
    263              }  
    264            }
    265            
    266            if( (uartx->C2 & UART_C2_TE_MASK) == 0 
    267               && uart_init_structure.TxFIFO.FIFO_Enable == TRUE)
   \                     ??UART_Init_32: (+1)
   \   000003F0   0x78D9             LDRB     R1,[R3, #+3]
   \   000003F2   0x0709             LSLS     R1,R1,#+28
   \   000003F4   0xD427             BMI.N    ??UART_Init_37
   \   000003F6   0xF89D 0x1032      LDRB     R1,[SP, #+50]
   \   000003FA   0x2901             CMP      R1,#+1
   \   000003FC   0xD123             BNE.N    ??UART_Init_37
    268            {
    269              //使能 UART 发送FIFO
    270              uartx->PFIFO |= UART_PFIFO_TXFE_MASK;
   \   000003FE   0x7C19             LDRB     R1,[R3, #+16]
   \   00000400   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000404   0x7419             STRB     R1,[R3, #+16]
    271              
    272              if(uart_init_structure.TxFIFO.FIFO_BufFlow_IntEnable == TRUE)
   \   00000406   0xF89D 0x1033      LDRB     R1,[SP, #+51]
   \   0000040A   0x2901             CMP      R1,#+1
   \   0000040C   0xD103             BNE.N    ??UART_Init_38
    273              {
    274                uartx->CFIFO |= UART_CFIFO_TXOFE_MASK;
   \   0000040E   0x7C59             LDRB     R1,[R3, #+17]
   \   00000410   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000414   0x7459             STRB     R1,[R3, #+17]
    275              }
    276              
    277              //读取 FIFO buffer 深度
    278              len = (uint8)( uartx->PFIFO & UART_PFIFO_TXFIFOSIZE_MASK ) >> UART_PFIFO_TXFIFOSIZE_SHIFT;
   \                     ??UART_Init_38: (+1)
   \   00000416   0x7C19             LDRB     R1,[R3, #+16]
   \   00000418   0xF3C1 0x1102      UBFX     R1,R1,#+4,#+3
    279              len = len > 0 ? 1 << (len + 1) : 1;
   \   0000041C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000041E   0x2900             CMP      R1,#+0
   \   00000420   0xD005             BEQ.N    ??UART_Init_39
   \   00000422   0x2201             MOVS     R2,#+1
   \   00000424   0x1C49             ADDS     R1,R1,#+1
   \   00000426   0xFA12 0xF101      LSLS     R1,R2,R1
   \   0000042A   0x000A             MOVS     R2,R1
   \   0000042C   0xE000             B.N      ??UART_Init_40
   \                     ??UART_Init_39: (+1)
   \   0000042E   0x2201             MOVS     R2,#+1
    280              //如果Tx FIFO buffer中的DataWords 小于等于 UART_FIFOWaterMark
    281              //将产生中断或者DMA信号，取决C2_TIE和C5_TDMAS的状态
    282              if( uart_init_structure.TxFIFO.FIFO_WaterMark > len )
   \                     ??UART_Init_40: (+1)
   \   00000430   0x0011             MOVS     R1,R2
   \   00000432   0xF89D 0xB034      LDRB     R11,[SP, #+52]
   \   00000436   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000438   0x4559             CMP      R1,R11
   \   0000043A   0xD201             BCS.N    ??UART_Init_41
    283              {
    284                uartx->TWFIFO = UART_TWFIFO_TXWATER(len);
   \   0000043C   0x74DA             STRB     R2,[R3, #+19]
   \   0000043E   0xE002             B.N      ??UART_Init_37
    285              }
    286              else
    287              {
    288                uartx->TWFIFO = UART_TWFIFO_TXWATER(uart_init_structure.TxFIFO.FIFO_WaterMark);
   \                     ??UART_Init_41: (+1)
   \   00000440   0xF89D 0x1034      LDRB     R1,[SP, #+52]
   \   00000444   0x74D9             STRB     R1,[R3, #+19]
    289              }
    290            }
    291            //使能 UART 发送器
    292            uartx->C2 |= UART_C2_TE_MASK | UART_C2_RE_MASK;  
   \                     ??UART_Init_37: (+1)
   \   00000446   0x78D9             LDRB     R1,[R3, #+3]
   \   00000448   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   0000044C   0x70D9             STRB     R1,[R3, #+3]
    293          }
   \   0000044E   0xE8BD 0x0FF0      POP      {R4-R11}
   \   00000452   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    294          
    295          
    296          /*
    297           * UART_RxFIFO_Flush
    298           * 清空UART Rx FIFO
    299           * 
    300           * 参数:
    301           *    uartx--UART模块号
    302           *      |__UART0          --UART0
    303           *      |__UART1          --UART1
    304           *      |__UART2          --UART2
    305           *      |__UART3          --UART3
    306           *      |__UART4          --UART4
    307           *      |__UART5          --UART5
    308           *
    309           */

   \                                 In section .text, align 2, keep-with-next
    310          void UART_RxFIFO_Flush(UART_Type *uartx)
    311          {
    312            //清空接收 FIFO
    313            if( uartx->PFIFO & UART_PFIFO_RXFE_MASK )
   \                     UART_RxFIFO_Flush: (+1)
   \   00000000   0x7C01             LDRB     R1,[R0, #+16]
   \   00000002   0x0709             LSLS     R1,R1,#+28
   \   00000004   0xD503             BPL.N    ??UART_RxFIFO_Flush_0
    314            {
    315              uartx->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \   00000006   0x7C41             LDRB     R1,[R0, #+17]
   \   00000008   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000000C   0x7441             STRB     R1,[R0, #+17]
    316            }
    317          }
   \                     ??UART_RxFIFO_Flush_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    318          
    319          /*
    320           * UART_TxFIFO_Flush
    321           * 清空UART Tx FIFO
    322           * 
    323           * 参数:
    324           *    uartx--UART模块号
    325           *      |__UART0          --UART0
    326           *      |__UART1          --UART1
    327           *      |__UART2          --UART2
    328           *      |__UART3          --UART3
    329           *      |__UART4          --UART4
    330           *      |__UART5          --UART5
    331           *
    332           */

   \                                 In section .text, align 2, keep-with-next
    333          void UART_TxFIFO_Flush(UART_Type *uartx)
    334          {
    335            //清空发送 FIFO
    336            if( uartx->PFIFO & UART_PFIFO_TXFE_MASK )
   \                     UART_TxFIFO_Flush: (+1)
   \   00000000   0x7C01             LDRB     R1,[R0, #+16]
   \   00000002   0x0609             LSLS     R1,R1,#+24
   \   00000004   0xD503             BPL.N    ??UART_TxFIFO_Flush_0
    337            {
    338              uartx->CFIFO |= UART_CFIFO_TXFLUSH_MASK;
   \   00000006   0x7C41             LDRB     R1,[R0, #+17]
   \   00000008   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000000C   0x7441             STRB     R1,[R0, #+17]
    339            }
    340          }
   \                     ??UART_TxFIFO_Flush_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    341          
    342          /*
    343           * UART_GetChar
    344           * 串口查询方式读取一个字节
    345           * 
    346           * 参数:
    347           *    uartx--UART模块号
    348           *      |__UART0          --UART0
    349           *      |__UART1          --UART1
    350           *      |__UART2          --UART2
    351           *      |__UART3          --UART3
    352           *      |__UART4          --UART4
    353           *      |__UART5          --UART5
    354           *
    355           * 输出:
    356           *    串口接收的1个字节
    357           *
    358           */

   \                                 In section .text, align 2, keep-with-next
    359          char UART_GetChar(UART_Type *uartx)
    360          {
    361            //等待数据接收
    362            while (!(uartx->S1 & UART_S1_RDRF_MASK));
   \                     UART_GetChar: (+1)
   \                     ??UART_GetChar_0: (+1)
   \   00000000   0x7901             LDRB     R1,[R0, #+4]
   \   00000002   0x0689             LSLS     R1,R1,#+26
   \   00000004   0xD5FC             BPL.N    ??UART_GetChar_0
    363            
    364            //返回接收的1个字节数据
    365            return uartx->D;
   \   00000006   0x79C0             LDRB     R0,[R0, #+7]
   \   00000008   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /********************************************************************/
    369          /*
    370           * UART_GetChar_Present
    371           * 检查是否接收到字符
    372           * 
    373           * 参数:
    374           *    uartx--UART模块号
    375           *      |__UART0          --UART0
    376           *      |__UART1          --UART1
    377           *      |__UART2          --UART2
    378           *      |__UART3          --UART3
    379           *      |__UART4          --UART4
    380           *      |__UART5          --UART5
    381           *
    382           * 输出:
    383           *  0       没有接收到字符
    384           *  1       已经接收到字符
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          int32 UART_GetChar_Present(UART_Type *uartx)
    387          {
    388              return (uartx->S1 & UART_S1_RDRF_MASK);
   \                     UART_GetChar_Present: (+1)
   \   00000000   0x7900             LDRB     R0,[R0, #+4]
   \   00000002   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   00000006   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /*
    392           * UART_PutChar
    393           * 串口查询方式发送一个字节
    394           * 
    395           * 参数:
    396           *    uartx--UART模块号
    397           *      |__UART0          --UART0
    398           *      |__UART1          --UART1
    399           *      |__UART2          --UART2
    400           *      |__UART3          --UART3
    401           *      |__UART4          --UART4
    402           *      |__UART5          --UART5
    403           *    ch--待发送的1个字节
    404           *
    405           * 输出:
    406           *    无
    407           *
    408           */

   \                                 In section .text, align 2, keep-with-next
    409          void UART_PutChar(UART_Type *uartx, char ch)
    410          {
    411            //等待FIFO准备就绪
    412            while(!(uartx->S1 & UART_S1_TDRE_MASK));
   \                     UART_PutChar: (+1)
   \                     ??UART_PutChar_0: (+1)
   \   00000000   0x7902             LDRB     R2,[R0, #+4]
   \   00000002   0x0612             LSLS     R2,R2,#+24
   \   00000004   0xD5FC             BPL.N    ??UART_PutChar_0
    413            
    414            //将要发送的1个字节发给UART数据寄存器
    415            uartx->D = (uint8)ch;
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    416          }
   \   00000008   0x4770             BX       LR               ;; return
    417          
    418          
    419          /*
    420           * UART_PutCharArr
    421           * 串口查询方式发送字节型数组
    422           * 
    423           * 参数:
    424           *    uartx--UART模块号
    425           *      |__UART0          --UART0
    426           *      |__UART1          --UART1
    427           *      |__UART2          --UART2
    428           *      |__UART3          --UART3
    429           *      |__UART4          --UART4
    430           *      |__UART5          --UART5
    431           *    *ch--待发送的字节数组头地址
    432           *    len--字节数组长度
    433           *
    434           * 输出:
    435           *    无
    436           *
    437           */

   \                                 In section .text, align 2, keep-with-next
    438          void UART_PutCharArr(UART_Type *uartx, char *ch, int32 len)
    439          {
   \                     UART_PutCharArr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    440            while(len--)
   \                     ??UART_PutCharArr_0: (+1)
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??UART_PutCharArr_1
    441            {
    442              UART_PutChar(uartx, *(ch++));
   \   00000010   0x7829             LDRB     R1,[R5, #+0]
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       UART_PutChar
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \   0000001A   0xE7F5             B.N      ??UART_PutCharArr_0
    443            }
    444          }
   \                     ??UART_PutCharArr_1: (+1)
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    445          
    446          /*
    447           * UART_EnableIrq
    448           * 使能串口数据接收中断
    449           * 
    450           * 参数:
    451           *    uart_init_structure--UART初始化结构体，
    452           *                        具体定义见UART_InitTypeDef
    453           *
    454           * 输出:
    455           *    无
    456           *
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          void UART_EnableIrq(UART_InitTypeDef uart_init_structure)
    459          {
   \                     UART_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    460            if(uart_init_structure.UART_Uartx == UART0)
   \   00000004   0x9802             LDR      R0,[SP, #+8]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD106             BNE.N    ??UART_EnableIrq_0
    461            {
    462              enable_irq(UART0_RX_TX_IRQn);
   \   0000000E   0x202D             MOVS     R0,#+45
   \   00000010   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    463              enable_irq(UART0_ERR_IRQn);
   \   00000014   0x202E             MOVS     R0,#+46
   \   00000016   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \   0000001A   0xE03A             B.N      ??UART_EnableIrq_1
    464            }
    465            else if(uart_init_structure.UART_Uartx == UART1)
   \                     ??UART_EnableIrq_0: (+1)
   \   0000001C   0x9802             LDR      R0,[SP, #+8]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD106             BNE.N    ??UART_EnableIrq_2
    466            {
    467              enable_irq(UART1_RX_TX_IRQn);
   \   00000026   0x202F             MOVS     R0,#+47
   \   00000028   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    468              enable_irq(UART1_ERR_IRQn);
   \   0000002C   0x2030             MOVS     R0,#+48
   \   0000002E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \   00000032   0xE02E             B.N      ??UART_EnableIrq_1
    469            }
    470            else if(uart_init_structure.UART_Uartx == UART2)
   \                     ??UART_EnableIrq_2: (+1)
   \   00000034   0x9802             LDR      R0,[SP, #+8]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD106             BNE.N    ??UART_EnableIrq_3
    471            {
    472              enable_irq(UART2_RX_TX_IRQn);
   \   0000003E   0x2031             MOVS     R0,#+49
   \   00000040   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    473              enable_irq(UART2_ERR_IRQn);
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \   0000004A   0xE022             B.N      ??UART_EnableIrq_1
    474            }
    475            else if(uart_init_structure.UART_Uartx == UART3)
   \                     ??UART_EnableIrq_3: (+1)
   \   0000004C   0x9802             LDR      R0,[SP, #+8]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD106             BNE.N    ??UART_EnableIrq_4
    476            {
    477              enable_irq(UART3_RX_TX_IRQn);
   \   00000056   0x2033             MOVS     R0,#+51
   \   00000058   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    478              enable_irq(UART3_ERR_IRQn);
   \   0000005C   0x2034             MOVS     R0,#+52
   \   0000005E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \   00000062   0xE016             B.N      ??UART_EnableIrq_1
    479            }
    480            else if(uart_init_structure.UART_Uartx == UART4)
   \                     ??UART_EnableIrq_4: (+1)
   \   00000064   0x9802             LDR      R0,[SP, #+8]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD106             BNE.N    ??UART_EnableIrq_5
    481            {
    482              enable_irq(UART4_RX_TX_IRQn);
   \   0000006E   0x2035             MOVS     R0,#+53
   \   00000070   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    483              enable_irq(UART4_ERR_IRQn);
   \   00000074   0x2036             MOVS     R0,#+54
   \   00000076   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \   0000007A   0xE00A             B.N      ??UART_EnableIrq_1
    484            }
    485            else if(uart_init_structure.UART_Uartx == UART5)
   \                     ??UART_EnableIrq_5: (+1)
   \   0000007C   0x9802             LDR      R0,[SP, #+8]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD105             BNE.N    ??UART_EnableIrq_1
    486            {
    487              enable_irq(UART5_RX_TX_IRQn);
   \   00000086   0x2037             MOVS     R0,#+55
   \   00000088   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    488              enable_irq(UART5_ERR_IRQn);
   \   0000008C   0x2038             MOVS     R0,#+56
   \   0000008E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    489            }
    490          }
   \                     ??UART_EnableIrq_1: (+1)
   \   00000092   0xBC01             POP      {R0}
   \   00000094   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    491          
    492          /*
    493           * UART_DisableIrq
    494           * 禁用串口数据接收中断
    495           * 
    496           * 参数:
    497           *    uart_init_structure--UART初始化结构体，
    498           *                        具体定义见UART_InitTypeDef
    499           *
    500           * 输出:
    501           *    无
    502           *
    503           */

   \                                 In section .text, align 2, keep-with-next
    504          void UART_DisableIrq(UART_InitTypeDef uart_init_structure)
    505          {
   \                     UART_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    506            //根据中断请求号使能相应中断
    507            if(uart_init_structure.UART_Uartx == UART0)
   \   00000004   0x9802             LDR      R0,[SP, #+8]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD106             BNE.N    ??UART_DisableIrq_0
    508            {
    509              disable_irq(UART0_RX_TX_IRQn);
   \   0000000E   0x202D             MOVS     R0,#+45
   \   00000010   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    510              disable_irq(UART0_ERR_IRQn);
   \   00000014   0x202E             MOVS     R0,#+46
   \   00000016   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \   0000001A   0xE03A             B.N      ??UART_DisableIrq_1
    511            }
    512            else if(uart_init_structure.UART_Uartx == UART1)
   \                     ??UART_DisableIrq_0: (+1)
   \   0000001C   0x9802             LDR      R0,[SP, #+8]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD106             BNE.N    ??UART_DisableIrq_2
    513            {
    514              disable_irq(UART1_RX_TX_IRQn);
   \   00000026   0x202F             MOVS     R0,#+47
   \   00000028   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    515              disable_irq(UART1_ERR_IRQn);
   \   0000002C   0x2030             MOVS     R0,#+48
   \   0000002E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \   00000032   0xE02E             B.N      ??UART_DisableIrq_1
    516            }
    517            else if(uart_init_structure.UART_Uartx == UART2)
   \                     ??UART_DisableIrq_2: (+1)
   \   00000034   0x9802             LDR      R0,[SP, #+8]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD106             BNE.N    ??UART_DisableIrq_3
    518            {
    519              disable_irq(UART2_RX_TX_IRQn);
   \   0000003E   0x2031             MOVS     R0,#+49
   \   00000040   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    520              disable_irq(UART2_ERR_IRQn);
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \   0000004A   0xE022             B.N      ??UART_DisableIrq_1
    521            }
    522            else if(uart_init_structure.UART_Uartx == UART3)
   \                     ??UART_DisableIrq_3: (+1)
   \   0000004C   0x9802             LDR      R0,[SP, #+8]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD106             BNE.N    ??UART_DisableIrq_4
    523            {
    524              disable_irq(UART3_RX_TX_IRQn);
   \   00000056   0x2033             MOVS     R0,#+51
   \   00000058   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    525              disable_irq(UART3_ERR_IRQn);
   \   0000005C   0x2034             MOVS     R0,#+52
   \   0000005E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \   00000062   0xE016             B.N      ??UART_DisableIrq_1
    526            }
    527            else if(uart_init_structure.UART_Uartx == UART4)
   \                     ??UART_DisableIrq_4: (+1)
   \   00000064   0x9802             LDR      R0,[SP, #+8]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD106             BNE.N    ??UART_DisableIrq_5
    528            {
    529              disable_irq(UART4_RX_TX_IRQn);
   \   0000006E   0x2035             MOVS     R0,#+53
   \   00000070   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    530              disable_irq(UART4_ERR_IRQn);
   \   00000074   0x2036             MOVS     R0,#+54
   \   00000076   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \   0000007A   0xE00A             B.N      ??UART_DisableIrq_1
    531            }
    532            else if(uart_init_structure.UART_Uartx == UART5)
   \                     ??UART_DisableIrq_5: (+1)
   \   0000007C   0x9802             LDR      R0,[SP, #+8]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD105             BNE.N    ??UART_DisableIrq_1
    533            {
    534              disable_irq(UART5_RX_TX_IRQn);
   \   00000086   0x2037             MOVS     R0,#+55
   \   00000088   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    535              disable_irq(UART5_ERR_IRQn);
   \   0000008C   0x2038             MOVS     R0,#+56
   \   0000008E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    536            }
    537          }
   \                     ??UART_DisableIrq_1: (+1)
   \   00000092   0xBC01             POP      {R0}
   \   00000094   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    538          
    539          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    540          void UART0_IRQHandler(void)
    541          {
   \                     _Z16UART0_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    542          #if (UCOS_II > 0u)
    543            OS_CPU_SR  cpu_sr = 0u;
    544            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    545            OSIntEnter();
    546            OS_EXIT_CRITICAL();
    547          #endif
    548            //判断Rx FIFO是否 Under flow
    549            if( UART0->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_40  ;; 0x4006a012
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD507             BPL.N    ??UART0_IRQHandler_0
    550            {
    551              UART0->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable13_40  ;; 0x4006a012
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable13_40  ;; 0x4006a012
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    552            }
    553            //判断Tx FIFO是否 Over flow
    554            if( UART0->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART0_IRQHandler_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_40  ;; 0x4006a012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD507             BPL.N    ??UART0_IRQHandler_1
    555            {
    556              UART0->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_40  ;; 0x4006a012
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable13_40  ;; 0x4006a012
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    557            }
    558            //进入接收中断函数
    559            if((UART0->S1 & UART_S1_RDRF_MASK) && (UART0->C2 & UART_C2_RIE_MASK))
   \                     ??UART0_IRQHandler_1: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable13_41  ;; 0x4006a004
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x0680             LSLS     R0,R0,#+26
   \   0000003E   0xD508             BPL.N    ??UART0_IRQHandler_2
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_42  ;; 0x4006a003
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x0680             LSLS     R0,R0,#+26
   \   00000048   0xD503             BPL.N    ??UART0_IRQHandler_2
    560            {
    561              UART_R_ISR[0]();
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable13_38
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x4780             BLX      R0
    562            }
    563            //进入发送中断函数
    564            if((UART0->S1 & UART_S1_TDRE_MASK) && (UART0->C2 & UART_C2_TIE_MASK))
   \                     ??UART0_IRQHandler_2: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable13_41  ;; 0x4006a004
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x0600             LSLS     R0,R0,#+24
   \   0000005A   0xD508             BPL.N    ??UART0_IRQHandler_3
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable13_42  ;; 0x4006a003
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x0600             LSLS     R0,R0,#+24
   \   00000064   0xD503             BPL.N    ??UART0_IRQHandler_3
    565            {
    566              UART_T_ISR[0]();
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable13_39
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x4780             BLX      R0
    567            }
    568            
    569          #if (UCOS_II > 0u)
    570            OSIntExit();          //告知系统此时即将离开中断服务子函数
    571          #endif
    572          }
   \                     ??UART0_IRQHandler_3: (+1)
   \                     ??UART0_IRQHandler_4: (+1)
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
    573          
    574          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    575          void UART1_IRQHandler(void)
    576          {
   \                     _Z16UART1_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    577          #if (UCOS_II > 0u)
    578            OS_CPU_SR  cpu_sr = 0u;
    579            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    580            OSIntEnter();
    581            OS_EXIT_CRITICAL();
    582          #endif
    583            //判断Rx FIFO是否 Under flow
    584            if( UART1->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_43  ;; 0x4006b012
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD507             BPL.N    ??UART1_IRQHandler_0
    585            {
    586              UART1->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable13_43  ;; 0x4006b012
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable13_43  ;; 0x4006b012
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    587            }
    588            //判断Tx FIFO是否 Over flow
    589            if( UART1->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART1_IRQHandler_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_43  ;; 0x4006b012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD507             BPL.N    ??UART1_IRQHandler_1
    590            {
    591              UART1->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_43  ;; 0x4006b012
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable13_43  ;; 0x4006b012
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    592            }  
    593            //进入接收中断函数
    594            if((UART1->S1 & UART_S1_RDRF_MASK) && (UART1->C2 & UART_C2_RIE_MASK))
   \                     ??UART1_IRQHandler_1: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable13_44  ;; 0x4006b004
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x0680             LSLS     R0,R0,#+26
   \   0000003E   0xD507             BPL.N    ??UART1_IRQHandler_2
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_45  ;; 0x4006b003
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x0680             LSLS     R0,R0,#+26
   \   00000048   0xD502             BPL.N    ??UART1_IRQHandler_2
    595            {
    596              UART_R_ISR[1]();
   \   0000004A   0x....             LDR.N    R0,??DataTable13_38
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0x4780             BLX      R0
    597            }
    598            //进入发送中断函数
    599            if((UART1->S1 & UART_S1_TDRE_MASK) && (UART1->C2 & UART_C2_TIE_MASK))
   \                     ??UART1_IRQHandler_2: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable13_44  ;; 0x4006b004
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x0600             LSLS     R0,R0,#+24
   \   00000056   0xD506             BPL.N    ??UART1_IRQHandler_3
   \   00000058   0x....             LDR.N    R0,??DataTable13_45  ;; 0x4006b003
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x0600             LSLS     R0,R0,#+24
   \   0000005E   0xD502             BPL.N    ??UART1_IRQHandler_3
    600            {
    601              UART_T_ISR[1]();
   \   00000060   0x....             LDR.N    R0,??DataTable13_39
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x4780             BLX      R0
    602            }
    603            
    604          #if (UCOS_II > 0u)
    605            OSIntExit();          //告知系统此时即将离开中断服务子函数
    606          #endif
    607          }
   \                     ??UART1_IRQHandler_3: (+1)
   \                     ??UART1_IRQHandler_4: (+1)
   \   00000066   0xBD01             POP      {R0,PC}          ;; return
    608          
    609          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    610          void UART2_IRQHandler(void)
    611          {
   \                     _Z16UART2_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    612          #if (UCOS_II > 0u)
    613            OS_CPU_SR  cpu_sr = 0u;
    614            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    615            OSIntEnter();
    616            OS_EXIT_CRITICAL();
    617          #endif
    618            //判断Rx FIFO是否 Under flow
    619            if( UART2->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable13_46  ;; 0x4006c012
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??UART2_IRQHandler_0
    620            {
    621              UART2->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000A   0x....             LDR.N    R0,??DataTable13_46  ;; 0x4006c012
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable13_46  ;; 0x4006c012
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    622            }
    623            //判断Tx FIFO是否 Over flow
    624            if( UART2->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART2_IRQHandler_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable13_46  ;; 0x4006c012
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD505             BPL.N    ??UART2_IRQHandler_1
    625            {
    626              UART2->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable13_46  ;; 0x4006c012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable13_46  ;; 0x4006c012
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    627            }    
    628            //进入接收中断函数
    629            if((UART2->S1 & UART_S1_RDRF_MASK) && (UART2->C2 & UART_C2_RIE_MASK))
   \                     ??UART2_IRQHandler_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable13_47  ;; 0x4006c004
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD506             BPL.N    ??UART2_IRQHandler_2
   \   00000032   0x....             LDR.N    R0,??DataTable13_48  ;; 0x4006c003
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD502             BPL.N    ??UART2_IRQHandler_2
    630            {
    631              UART_R_ISR[2]();
   \   0000003A   0x....             LDR.N    R0,??DataTable13_38
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x4780             BLX      R0
    632            }
    633            //进入发送中断函数
    634            if((UART2->S1 & UART_S1_TDRE_MASK) && (UART2->C2 & UART_C2_TIE_MASK))
   \                     ??UART2_IRQHandler_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable13_47  ;; 0x4006c004
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0xD506             BPL.N    ??UART2_IRQHandler_3
   \   00000048   0x....             LDR.N    R0,??DataTable13_48  ;; 0x4006c003
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0600             LSLS     R0,R0,#+24
   \   0000004E   0xD502             BPL.N    ??UART2_IRQHandler_3
    635            {
    636              UART_T_ISR[2]();
   \   00000050   0x....             LDR.N    R0,??DataTable13_39
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x4780             BLX      R0
    637            }
    638            
    639          #if (UCOS_II > 0u)
    640            OSIntExit();          //告知系统此时即将离开中断服务子函数
    641          #endif
    642          }
   \                     ??UART2_IRQHandler_3: (+1)
   \                     ??UART2_IRQHandler_4: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    643          
    644          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    645          void UART3_IRQHandler(void)
    646          {
   \                     _Z16UART3_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    647          #if (UCOS_II > 0u)
    648            OS_CPU_SR  cpu_sr = 0u;
    649            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    650            OSIntEnter();
    651            OS_EXIT_CRITICAL();
    652          #endif
    653            //判断Rx FIFO是否 Under flow
    654            if( UART3->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable13_49  ;; 0x4006d012
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??UART3_IRQHandler_0
    655            {
    656              UART3->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000A   0x....             LDR.N    R0,??DataTable13_49  ;; 0x4006d012
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable13_49  ;; 0x4006d012
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    657            }
    658            //判断Tx FIFO是否 Over flow
    659            if( UART3->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART3_IRQHandler_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable13_49  ;; 0x4006d012
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD505             BPL.N    ??UART3_IRQHandler_1
    660            {
    661              UART3->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable13_49  ;; 0x4006d012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable13_49  ;; 0x4006d012
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    662            }   
    663            //进入接收中断函数
    664            if((UART3->S1 & UART_S1_RDRF_MASK) && (UART3->C2 & UART_C2_RIE_MASK))
   \                     ??UART3_IRQHandler_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable13_50  ;; 0x4006d004
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD506             BPL.N    ??UART3_IRQHandler_2
   \   00000032   0x....             LDR.N    R0,??DataTable13_51  ;; 0x4006d003
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD502             BPL.N    ??UART3_IRQHandler_2
    665            {
    666              UART_R_ISR[3]();
   \   0000003A   0x....             LDR.N    R0,??DataTable13_38
   \   0000003C   0x68C0             LDR      R0,[R0, #+12]
   \   0000003E   0x4780             BLX      R0
    667            }
    668            //进入发送中断函数
    669            if((UART3->S1 & UART_S1_TDRE_MASK) && (UART3->C2 & UART_C2_TIE_MASK))
   \                     ??UART3_IRQHandler_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable13_50  ;; 0x4006d004
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0xD506             BPL.N    ??UART3_IRQHandler_3
   \   00000048   0x....             LDR.N    R0,??DataTable13_51  ;; 0x4006d003
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0600             LSLS     R0,R0,#+24
   \   0000004E   0xD502             BPL.N    ??UART3_IRQHandler_3
    670            {
    671              UART_T_ISR[3]();
   \   00000050   0x....             LDR.N    R0,??DataTable13_39
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0x4780             BLX      R0
    672            }
    673            
    674          #if (UCOS_II > 0u)
    675            OSIntExit();          //告知系统此时即将离开中断服务子函数
    676          #endif
    677          }
   \                     ??UART3_IRQHandler_3: (+1)
   \                     ??UART3_IRQHandler_4: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    678          
    679          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    680          void UART4_IRQHandler(void)
    681          {
   \                     _Z16UART4_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    682          #if (UCOS_II > 0u)
    683            OS_CPU_SR  cpu_sr = 0u;
    684            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    685            OSIntEnter();
    686            OS_EXIT_CRITICAL();
    687          #endif
    688            //判断Rx FIFO是否 Under flow
    689            if( UART4->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable13_52  ;; 0x400ea012
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??UART4_IRQHandler_0
    690            {
    691              UART4->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000A   0x....             LDR.N    R0,??DataTable13_52  ;; 0x400ea012
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable13_52  ;; 0x400ea012
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    692            }
    693            //判断Tx FIFO是否 Over flow
    694            if( UART4->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART4_IRQHandler_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable13_52  ;; 0x400ea012
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD505             BPL.N    ??UART4_IRQHandler_1
    695            {
    696              UART4->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable13_52  ;; 0x400ea012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable13_52  ;; 0x400ea012
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    697            }  
    698            //进入接收中断函数
    699            if((UART4->S1 & UART_S1_RDRF_MASK) && (UART4->C2 & UART_C2_RIE_MASK))
   \                     ??UART4_IRQHandler_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable13_53  ;; 0x400ea004
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD506             BPL.N    ??UART4_IRQHandler_2
   \   00000032   0x....             LDR.N    R0,??DataTable13_54  ;; 0x400ea003
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD502             BPL.N    ??UART4_IRQHandler_2
    700            {
    701              UART_R_ISR[4]();
   \   0000003A   0x....             LDR.N    R0,??DataTable13_38
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0x4780             BLX      R0
    702            }
    703            //进入发送中断函数
    704            if((UART4->S1 & UART_S1_TDRE_MASK) && (UART4->C2 & UART_C2_TIE_MASK))
   \                     ??UART4_IRQHandler_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable13_53  ;; 0x400ea004
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0xD506             BPL.N    ??UART4_IRQHandler_3
   \   00000048   0x....             LDR.N    R0,??DataTable13_54  ;; 0x400ea003
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0600             LSLS     R0,R0,#+24
   \   0000004E   0xD502             BPL.N    ??UART4_IRQHandler_3
    705            {
    706              UART_T_ISR[4]();
   \   00000050   0x....             LDR.N    R0,??DataTable13_39
   \   00000052   0x6900             LDR      R0,[R0, #+16]
   \   00000054   0x4780             BLX      R0
    707            }
    708            
    709          #if (UCOS_II > 0u)
    710            OSIntExit();          //告知系统此时即将离开中断服务子函数
    711          #endif
    712          }
   \                     ??UART4_IRQHandler_3: (+1)
   \                     ??UART4_IRQHandler_4: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    713          
    714          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    715          void UART5_IRQHandler(void)
    716          {
   \                     _Z16UART5_IRQHandlerv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    717          #if (UCOS_II > 0u)
    718            OS_CPU_SR  cpu_sr = 0u;
    719            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    720            OSIntEnter();
    721            OS_EXIT_CRITICAL();
    722          #endif
    723            //判断Rx FIFO是否 Under flow
    724            if( UART5->SFIFO & UART_SFIFO_RXUF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable13_55  ;; 0x400eb012
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??UART5_IRQHandler_0
    725            {
    726              UART5->SFIFO |= UART_SFIFO_RXUF_MASK;
   \   0000000A   0x....             LDR.N    R0,??DataTable13_55  ;; 0x400eb012
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable13_55  ;; 0x400eb012
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    727            }
    728            //判断Tx FIFO是否 Over flow
    729            if( UART5->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART5_IRQHandler_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable13_55  ;; 0x400eb012
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD505             BPL.N    ??UART5_IRQHandler_1
    730            {
    731              UART5->SFIFO |= UART_SFIFO_TXOF_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable13_55  ;; 0x400eb012
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable13_55  ;; 0x400eb012
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    732            }   
    733            //进入接收中断函数
    734            if((UART5->S1 & UART_S1_RDRF_MASK) && (UART5->C2 & UART_C2_RIE_MASK))
   \                     ??UART5_IRQHandler_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable13_56  ;; 0x400eb004
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD506             BPL.N    ??UART5_IRQHandler_2
   \   00000032   0x....             LDR.N    R0,??DataTable13_57  ;; 0x400eb003
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD502             BPL.N    ??UART5_IRQHandler_2
    735            {
    736              UART_R_ISR[5]();
   \   0000003A   0x....             LDR.N    R0,??DataTable13_38
   \   0000003C   0x6940             LDR      R0,[R0, #+20]
   \   0000003E   0x4780             BLX      R0
    737            }
    738            //进入发送中断函数
    739            if((UART5->S1 & UART_S1_TDRE_MASK) && (UART5->C2 & UART_C2_TIE_MASK))
   \                     ??UART5_IRQHandler_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable13_56  ;; 0x400eb004
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0xD506             BPL.N    ??UART5_IRQHandler_3
   \   00000048   0x....             LDR.N    R0,??DataTable13_57  ;; 0x400eb003
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0600             LSLS     R0,R0,#+24
   \   0000004E   0xD502             BPL.N    ??UART5_IRQHandler_3
    740            {
    741              UART_T_ISR[5]();
   \   00000050   0x....             LDR.N    R0,??DataTable13_39
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0x4780             BLX      R0
    742            }
    743            
    744          #if (UCOS_II > 0u)
    745            OSIntExit();          //告知系统此时即将离开中断服务子函数
    746          #endif
    747          }
   \                     ??UART5_IRQHandler_3: (+1)
   \                     ??UART5_IRQHandler_4: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    748          

   \                                 In section .text, align 2, keep-with-next
    749          void UART0_ERR_IRQHandler(void)
    750          {
    751          }
   \                     _Z20UART0_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    752          

   \                                 In section .text, align 2, keep-with-next
    753          void UART1_ERR_IRQHandler(void)
    754          {
    755          }
   \                     _Z20UART1_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    756          

   \                                 In section .text, align 2, keep-with-next
    757          void UART2_ERR_IRQHandler(void)
    758          {
    759          }
   \                     _Z20UART2_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    760          

   \                                 In section .text, align 2, keep-with-next
    761          void UART3_ERR_IRQHandler(void)
    762          {
    763          }
   \                     _Z20UART3_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    764          

   \                                 In section .text, align 2, keep-with-next
    765          void UART4_ERR_IRQHandler(void)
    766          {
    767          }
   \                     _Z20UART4_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    768          

   \                                 In section .text, align 2, keep-with-next
    769          void UART5_ERR_IRQHandler(void)
    770          {
    771          }
   \                     _Z20UART5_ERR_IRQHandlerv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    772          

   \                                 In section .text, align 2, keep-with-next
    773          void SendUNum_3(int32 num){
   \                     SendUNum_3: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    774              uart_putchar(num/1000000);
   \   00000004   0x....             LDR.N    R0,??DataTable13_58  ;; 0xf4240
   \   00000006   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       uart_putchar
    775              uart_putchar(num/10000%100);
   \   00000010   0xF242 0x7010      MOVW     R0,#+10000
   \   00000014   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   00000018   0x2164             MOVS     R1,#+100
   \   0000001A   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000001E   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       uart_putchar
    776              uart_putchar(num/100%100);
   \   00000028   0x2064             MOVS     R0,#+100
   \   0000002A   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000002E   0x2164             MOVS     R1,#+100
   \   00000030   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000034   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       uart_putchar
    777          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    778          void SendUNum_2(int32 num){
   \                     SendUNum_2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    779              uart_putchar(num/100);
   \   00000004   0x2064             MOVS     R0,#+100
   \   00000006   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       uart_putchar
    780              uart_putchar(num%100);
   \   00000010   0x2064             MOVS     R0,#+100
   \   00000012   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   00000016   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       uart_putchar
    781          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    782          void SendUNum_1(int32 num){
   \                     SendUNum_1: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    783              uart_putchar(num);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       uart_putchar
    784          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    785          

   \                                 In section .text, align 2, keep-with-next
    786          void SendSNum_3(int32 num){
   \                     SendSNum_3: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    787            if(num<0){
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD504             BPL.N    ??SendSNum_3_0
    788              num = -num;
   \   00000008   0x4264             RSBS     R4,R4,#+0
    789              uart_putchar('-');
   \   0000000A   0x202D             MOVS     R0,#+45
   \   0000000C   0x.... 0x....      BL       uart_putchar
   \   00000010   0xE002             B.N      ??SendSNum_3_1
    790            }
    791            else{
    792              uart_putchar('+');
   \                     ??SendSNum_3_0: (+1)
   \   00000012   0x202B             MOVS     R0,#+43
   \   00000014   0x.... 0x....      BL       uart_putchar
    793            }
    794              uart_putchar(num/100);
   \                     ??SendSNum_3_1: (+1)
   \   00000018   0x2064             MOVS     R0,#+100
   \   0000001A   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       uart_putchar
    795              uart_putchar(num%100);
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   0000002A   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       uart_putchar
    796          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    797          

   \                                 In section .text, align 2, keep-with-next
    798          void uart_putchar(uint8 ch){
   \                     uart_putchar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    799              UART_PutChar(UART0, ch);
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4006a000
   \   0000000A   0x.... 0x....      BL       UART_PutChar
    800          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    801          

   \                                 In section .text, align 2, keep-with-next
    802          void SCI_TXD(u8 ch)
    803          {
   \                     SCI_TXD: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    804              UART_PutChar(UART3, ch);
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x....             LDR.N    R0,??DataTable13_20  ;; 0x4006d000
   \   0000000A   0x.... 0x....      BL       UART_PutChar
    805          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     g_core_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40049008         DC32     0x40049008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40049038         DC32     0x40049038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40049004         DC32     0x40049004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x4004903C         DC32     0x4004903c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   0x4004A02C         DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \   00000000   0x4004A028         DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_29:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_30:
   \   00000000   0x4004B03C         DC32     0x4004b03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_31:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_32:
   \   00000000   0x4004B038         DC32     0x4004b038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_33:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_34:
   \   00000000   0x4004C024         DC32     0x4004c024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_35:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_36:
   \   00000000   0x4004C020         DC32     0x4004c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_37:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_38:
   \   00000000   0x........         DC32     UART_R_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_39:
   \   00000000   0x........         DC32     UART_T_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_40:
   \   00000000   0x4006A012         DC32     0x4006a012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_41:
   \   00000000   0x4006A004         DC32     0x4006a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_42:
   \   00000000   0x4006A003         DC32     0x4006a003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_43:
   \   00000000   0x4006B012         DC32     0x4006b012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_44:
   \   00000000   0x4006B004         DC32     0x4006b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_45:
   \   00000000   0x4006B003         DC32     0x4006b003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_46:
   \   00000000   0x4006C012         DC32     0x4006c012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_47:
   \   00000000   0x4006C004         DC32     0x4006c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_48:
   \   00000000   0x4006C003         DC32     0x4006c003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_49:
   \   00000000   0x4006D012         DC32     0x4006d012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_50:
   \   00000000   0x4006D004         DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_51:
   \   00000000   0x4006D003         DC32     0x4006d003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_52:
   \   00000000   0x400EA012         DC32     0x400ea012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_53:
   \   00000000   0x400EA004         DC32     0x400ea004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_54:
   \   00000000   0x400EA003         DC32     0x400ea003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_55:
   \   00000000   0x400EB012         DC32     0x400eb012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_56:
   \   00000000   0x400EB004         DC32     0x400eb004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_57:
   \   00000000   0x400EB003         DC32     0x400eb003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_58:
   \   00000000   0x000F4240         DC32     0xf4240

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SCI_TXD
         8   -> UART_PutChar
       8   SendSNum_3
         8   -> uart_putchar
       8   SendUNum_1
         8   -> uart_putchar
       8   SendUNum_2
         8   -> uart_putchar
       8   SendUNum_3
         8   -> uart_putchar
       0   UART0_ERR_IRQHandler()
       8   UART0_IRQHandler()
         8   -- Indirect call
       0   UART1_ERR_IRQHandler()
       8   UART1_IRQHandler()
         8   -- Indirect call
       0   UART2_ERR_IRQHandler()
       8   UART2_IRQHandler()
         8   -- Indirect call
       0   UART3_ERR_IRQHandler()
       8   UART3_IRQHandler()
         8   -- Indirect call
       0   UART4_ERR_IRQHandler()
       8   UART4_IRQHandler()
         8   -- Indirect call
       0   UART5_ERR_IRQHandler()
       8   UART5_IRQHandler()
         8   -- Indirect call
      24   UART_DisableIrq
        24   -> __NVIC_DisableIRQ(IRQn)
      24   UART_EnableIrq
        24   -> __NVIC_EnableIRQ(IRQn)
       0   UART_GetChar
       0   UART_GetChar_Present
      52   UART_Init
       0   UART_PutChar
      16   UART_PutCharArr
        16   -> UART_PutChar
       0   UART_RxFIFO_Flush
       0   UART_TxFIFO_Flush
       0   __NVIC_DisableIRQ(IRQn)
       0   __NVIC_EnableIRQ(IRQn)
       8   uart_putchar
         8   -> UART_PutChar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_57
       4  ??DataTable13_58
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      16  SCI_TXD
      54  SendSNum_3
      14  SendUNum_1
      34  SendUNum_2
      64  SendUNum_3
       2  UART0_ERR_IRQHandler()
     112  UART0_IRQHandler()
       2  UART1_ERR_IRQHandler()
     104  UART1_IRQHandler()
       2  UART2_ERR_IRQHandler()
      88  UART2_IRQHandler()
       2  UART3_ERR_IRQHandler()
      88  UART3_IRQHandler()
       2  UART4_ERR_IRQHandler()
      88  UART4_IRQHandler()
       2  UART5_ERR_IRQHandler()
      88  UART5_IRQHandler()
     152  UART_DisableIrq
     152  UART_EnableIrq
      10  UART_GetChar
       8  UART_GetChar_Present
    1110  UART_Init
      10  UART_PutChar
      30  UART_PutCharArr
      24  UART_R_ISR
      16  UART_RxFIFO_Flush
      24  UART_T_ISR
      16  UART_TxFIFO_Flush
      30  __NVIC_DisableIRQ(IRQn)
      30  __NVIC_EnableIRQ(IRQn)
      16  uart_putchar
      48  -- Other

 
    48 bytes in section .ARM.exidx
    48 bytes in section .bss
 2 578 bytes in section .text
 
 2 578 bytes of CODE  memory
    48 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: none
