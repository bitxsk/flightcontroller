###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       18/Jun/2018  19:48:01
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\NvidiaTX1.cpp
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW28B6.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\NvidiaTX1.cpp
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\List\NvidiaTX1.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\RAM\Obj\NvidiaTX1.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\app\NvidiaTX1.cpp
      1          #include "NvidiaTX1.h"

   \                                 In section .text, align 4
   \   __code __interwork __softfp CJumpFilter::CJumpFilter()
   \                     _ZN11CJumpFilterC1Ev: (+1)
   \   00000000   0x4904             LDR.N    R1,??CJumpFilter_0  ;; 0x42c80000
   \   00000002   0x6081             STR      R1,[R0, #+8]
   \   00000004   0xF44F 0x7196      MOV      R1,#+300
   \   00000008   0x6281             STR      R1,[R0, #+40]
   \   0000000A   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   0000000E   0x62C1             STR      R1,[R0, #+44]
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??CJumpFilter_0:
   \   00000014   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4
   \   __code __interwork __softfp CoordinateElement::CoordinateElement()
   \                     _ZN17CoordinateElementC1Ev: (+1)
   \   00000000   0x4903             LDR.N    R1,??CoordinateElement_0  ;; 0x3f4ccccd
   \   00000002   0x6101             STR      R1,[R0, #+16]
   \   00000004   0x4903             LDR.N    R1,??CoordinateElement_0+0x4  ;; 0x461c4000
   \   00000006   0x6141             STR      R1,[R0, #+20]
   \   00000008   0x4903             LDR.N    R1,??CoordinateElement_0+0x8  ;; 0xc61c4000
   \   0000000A   0x6181             STR      R1,[R0, #+24]
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??CoordinateElement_0:
   \   00000010   0x3F4CCCCD         DC32     0x3f4ccccd
   \   00000014   0x461C4000         DC32     0x461c4000
   \   00000018   0xC61C4000         DC32     0xc61c4000

   \                                 In section .text, align 2
   \   __code __interwork __softfp Coordinate::Coordinate()
   \                     _ZN10CoordinateC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN17CoordinateElementC1Ev
   \   0000000A   0xF114 0x001C      ADDS     R0,R4,#+28
   \   0000000E   0x.... 0x....      BL       _ZN17CoordinateElementC1Ev
   \   00000012   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000016   0x.... 0x....      BL       _ZN17CoordinateElementC1Ev
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __code __interwork __softfp NvidiaTX1__::NvidiaTX1__()
   \                     _ZN11NvidiaTX1__C1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xF204 0x70F4      ADDW     R0,R4,#+2036
   \   00000008   0x.... 0x....      BL       _ZN11CJumpFilterC1Ev
   \   0000000C   0xF604 0x002C      ADDW     R0,R4,#+2092
   \   00000010   0x.... 0x....      BL       _ZN11CJumpFilterC1Ev
   \   00000014   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   00000018   0x.... 0x....      BL       _ZN11CJumpFilterC1Ev
   \   0000001C   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   00000020   0x.... 0x....      BL       _ZN11CJumpFilterC1Ev
   \   00000024   0xF604 0x00D4      ADDW     R0,R4,#+2260
   \   00000028   0x.... 0x....      BL       _ZN10CoordinateC1Ev
   \   0000002C   0xF604 0x1028      ADDW     R0,R4,#+2344
   \   00000030   0x.... 0x....      BL       _ZN10CoordinateC1Ev
   \   00000034   0xF604 0x107C      ADDW     R0,R4,#+2428
   \   00000038   0x.... 0x....      BL       _ZN10CoordinateC1Ev
   \   0000003C   0xEEF3 0x0A04      VMOV.F32 S1,#20.0
   \   00000040   0x2164             MOVS     R1,#+100
   \   00000042   0xED9F 0x0A10      VLDR.W   S0,??NvidiaTX1___0  ;; 0x3e19999a
   \   00000046   0xF204 0x70F4      ADDW     R0,R4,#+2036
   \   0000004A   0x.... 0x....      BL       _ZN11CJumpFilter12setParameterEfif
   \   0000004E   0xEEF3 0x0A04      VMOV.F32 S1,#20.0
   \   00000052   0x2164             MOVS     R1,#+100
   \   00000054   0xED9F 0x0A0B      VLDR.W   S0,??NvidiaTX1___0  ;; 0x3e19999a
   \   00000058   0xF604 0x002C      ADDW     R0,R4,#+2092
   \   0000005C   0x.... 0x....      BL       _ZN11CJumpFilter12setParameterEfif
   \   00000060   0xF44F 0x717A      MOV      R1,#+1000
   \   00000064   0xED9F 0x0A08      VLDR.W   S0,??NvidiaTX1___0+0x4  ;; 0x42c80000
   \   00000068   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   0000006C   0x.... 0x....      BL       _ZN11CJumpFilter12setParameterEfi
   \   00000070   0xF44F 0x717A      MOV      R1,#+1000
   \   00000074   0xED9F 0x0A04      VLDR.W   S0,??NvidiaTX1___0+0x4  ;; 0x42c80000
   \   00000078   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   0000007C   0x.... 0x....      BL       _ZN11CJumpFilter12setParameterEfi
   \   00000080   0x0020             MOVS     R0,R4
   \                     ??NvidiaTX1___1: (+1)
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   \                     ??NvidiaTX1___0:
   \   00000084   0x3E19999A         DC32     0x3e19999a
   \   00000088   0x42C80000         DC32     0x42c80000
      2          

   \                                 In section .bss, align 4
      3          NvidiaTX1__ *NvidiaTX1;
   \                     NvidiaTX1:
   \   00000000                      DS8 4
      4          
      5          

   \                                 In section .text, align 2, keep-with-next
      6          void NvidiaTX1_Init()
      7          {
   \                     _Z14NvidiaTX1_Initv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??NvidiaTX1_Init_0
      8            static NvidiaTX1__ NvidiaTX1_0;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000010   0x.... 0x....      BL       _ZN11NvidiaTX1__C1Ev
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
      9            NvidiaTX1 = &NvidiaTX1_0;
   \                     ??NvidiaTX1_Init_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable3_3
   \   00000024   0x6008             STR      R0,[R1, #+0]
     10          }
   \                     ??NvidiaTX1_Init_1: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     `NvidiaTX1_Init()::NvidiaTX1_0`:
   \   00000000                      DS8 2820
     11          
     12          

   \                                 In section .text, align 4, keep-with-next
     13          void NvidiaTX1__::updateUart()
     14          {
   \                     _ZN11NvidiaTX1__10updateUartEv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB086             SUB      SP,SP,#+24
   \   0000000A   0x0004             MOVS     R4,R0
     15            bool newPackage = false, newCircle = false;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
     16            int i = 0, i0 = 0;
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
     17            int address0 = (DMA0->TCD[DMA_CH0].DADDR) - (uint32)(&uartData[0]);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3_4  ;; 0x40009010
   \   00000020   0x6805             LDR      R5,[R0, #+0]
   \   00000022   0x1B2D             SUBS     R5,R5,R4
     18            int moveLength = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9004             STR      R0,[SP, #+16]
     19            int validcircleNum = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9001             STR      R0,[SP, #+4]
     20            const int packageLength = 11;
   \   0000002C   0x200B             MOVS     R0,#+11
   \   0000002E   0x9003             STR      R0,[SP, #+12]
     21            
     22          
     23            byteInterval = t - byte_lastTime;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xF8D4 0x07D4      LDR      R0,[R4, #+2004]
   \   0000003A   0x1A09             SUBS     R1,R1,R0
   \   0000003C   0xF8C4 0x17D0      STR      R1,[R4, #+2000]
     24            if(byte_lastAddress != address0)
   \   00000040   0xF8D4 0x07D8      LDR      R0,[R4, #+2008]
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD006             BEQ.N    ??updateUart_0
     25            {
     26              byte_lastTime = t;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF8C4 0x07D4      STR      R0,[R4, #+2004]
     27              byte_lastAddress = address0;
   \   00000052   0xF8C4 0x57D8      STR      R5,[R4, #+2008]
     28            }
     29            for(; i < address0; i++)
   \                     ??updateUart_0: (+1)
   \   00000056   0x42AE             CMP      R6,R5
   \   00000058   0xF280 0x80D9      BGE.W    ??updateUart_1
     30            {
     31              for(; uartData[i] != 'e' && i < address0; i++)
   \                     ??updateUart_2: (+1)
   \   0000005C   0x5DA0             LDRB     R0,[R4, R6]
   \   0000005E   0x2865             CMP      R0,#+101
   \   00000060   0xD003             BEQ.N    ??updateUart_3
   \   00000062   0x42AE             CMP      R6,R5
   \   00000064   0xDA01             BGE.N    ??updateUart_3
   \   00000066   0x1C76             ADDS     R6,R6,#+1
   \   00000068   0xE7F8             B.N      ??updateUart_2
     32              {
     33              }
     34              if(i - i0 < packageLength - 1)
   \                     ??updateUart_3: (+1)
   \   0000006A   0xEBB6 0x0008      SUBS     R0,R6,R8
   \   0000006E   0x280A             CMP      R0,#+10
   \   00000070   0xF2C0 0x80CB      BLT.W    ??updateUart_4
     35              {
     36                continue;
     37              }
     38              
     39              char checkSum = 0; //注意每个包的checkSum都要清零
   \                     ??updateUart_5: (+1)
   \   00000074   0x2700             MOVS     R7,#+0
     40              for(int k = i - (packageLength - 1); k < i - 1; k++)
   \   00000076   0xF1B6 0x010A      SUBS     R1,R6,#+10
   \                     ??updateUart_6: (+1)
   \   0000007A   0x1E70             SUBS     R0,R6,#+1
   \   0000007C   0x4281             CMP      R1,R0
   \   0000007E   0xDA03             BGE.N    ??updateUart_7
     41              {
     42                checkSum += uartData[k];
   \   00000080   0x5C60             LDRB     R0,[R4, R1]
   \   00000082   0x19C7             ADDS     R7,R0,R7
     43              }
   \   00000084   0x1C49             ADDS     R1,R1,#+1
   \   00000086   0xE7F8             B.N      ??updateUart_6
     44              if(checkSum != uartData[i-1])
   \                     ??updateUart_7: (+1)
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0xEB04 0x0106      ADD      R1,R4,R6
   \   0000008E   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xF040 0x80B8      BNE.W    ??updateUart_4
     45              {
     46                continue;
     47              }
     48              byte_lastTime = t;
   \                     ??updateUart_8: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable3_5
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0xF8C4 0x07D4      STR      R0,[R4, #+2004]
     49              byte_lastAddress = address0;
   \   000000A2   0xF8C4 0x57D8      STR      R5,[R4, #+2008]
     50              i0 = i;    
   \   000000A6   0x46B0             MOV      R8,R6
     51              
     52              int packageTop = i - packageLength + 1;
   \   000000A8   0xF1B6 0x000A      SUBS     R0,R6,#+10
     53              
     54              validcircleNum = uartData[packageTop];
   \   000000AC   0x5C21             LDRB     R1,[R4, R0]
   \   000000AE   0x9101             STR      R1,[SP, #+4]
     55              packageTop += 1;
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
     56              positionX_raw = (int16)(uartData[packageTop] << 8 | uartData[packageTop + 1]); //x坐标 单位像素
   \   000000B2   0x5C21             LDRB     R1,[R4, R0]
   \   000000B4   0xEB04 0x0200      ADD      R2,R4,R0
   \   000000B8   0x7852             LDRB     R2,[R2, #+1]
   \   000000BA   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   000000BE   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   000000C0   0xEE00 0x2A10      VMOV     S0,R2
   \   000000C4   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000C8   0xF204 0x71E4      ADDW     R1,R4,#+2020
   \   000000CC   0xED81 0x0A00      VSTR     S0,[R1, #0]
     57              packageTop += 2;
   \   000000D0   0x1C80             ADDS     R0,R0,#+2
     58              positionY_raw = (int16)(uartData[packageTop] << 8 | uartData[packageTop + 1]); //y坐标
   \   000000D2   0x5C21             LDRB     R1,[R4, R0]
   \   000000D4   0xEB04 0x0200      ADD      R2,R4,R0
   \   000000D8   0x7852             LDRB     R2,[R2, #+1]
   \   000000DA   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   000000DE   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   000000E0   0xEE00 0x2A10      VMOV     S0,R2
   \   000000E4   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000E8   0xF204 0x71E8      ADDW     R1,R4,#+2024
   \   000000EC   0xED81 0x0A00      VSTR     S0,[R1, #0]
     59              packageTop += 2;
   \   000000F0   0x1C80             ADDS     R0,R0,#+2
     60              velX_raw = (int16)(uartData[packageTop] << 8 | uartData[packageTop + 1]) / 3000.0f;
   \   000000F2   0x5C21             LDRB     R1,[R4, R0]
   \   000000F4   0xEB04 0x0200      ADD      R2,R4,R0
   \   000000F8   0x7852             LDRB     R2,[R2, #+1]
   \   000000FA   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   000000FE   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000100   0xEE00 0x2A10      VMOV     S0,R2
   \   00000104   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000108   0xEDDF 0x....      VLDR.W   S1,??DataTable3  ;; 0x453b8000
   \   0000010C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000110   0xF204 0x71EC      ADDW     R1,R4,#+2028
   \   00000114   0xED81 0x0A00      VSTR     S0,[R1, #0]
     61              packageTop += 2;
   \   00000118   0x1C80             ADDS     R0,R0,#+2
   \   0000011A   0x9002             STR      R0,[SP, #+8]
     62              velY_raw = (int16)(uartData[packageTop] << 8 | uartData[packageTop + 1]) / 3000.0f;
   \   0000011C   0x9802             LDR      R0,[SP, #+8]
   \   0000011E   0x5C20             LDRB     R0,[R4, R0]
   \   00000120   0x9902             LDR      R1,[SP, #+8]
   \   00000122   0x4421             ADD      R1,R4,R1
   \   00000124   0x7849             LDRB     R1,[R1, #+1]
   \   00000126   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \   0000012A   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000012C   0xEE00 0x1A10      VMOV     S0,R1
   \   00000130   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000134   0xEDDF 0x....      VLDR.W   S1,??DataTable3  ;; 0x453b8000
   \   00000138   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000013C   0xF204 0x70F0      ADDW     R0,R4,#+2032
   \   00000140   0xED80 0x0A00      VSTR     S0,[R0, #0]
     63              
     64              
     65              if(newCircle == false)
   \   00000144   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD102             BNE.N    ??updateUart_9
     66              {
     67                circleNum = 0;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0xF8C4 0x07E0      STR      R0,[R4, #+2016]
     68              }
     69              if(validcircleNum == 0)
   \                     ??updateUart_9: (+1)
   \   00000152   0x9801             LDR      R0,[SP, #+4]
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD10A             BNE.N    ??updateUart_10
     70              {
     71                circleFilter_x.setValid(false);
   \   00000158   0x2100             MOVS     R1,#+0
   \   0000015A   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   0000015E   0x.... 0x....      BL       _ZN11CJumpFilter8setValidEb
     72                circleFilter_y.setValid(false);
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   00000168   0x.... 0x....      BL       _ZN11CJumpFilter8setValidEb
   \   0000016C   0xE005             B.N      ??updateUart_11
     73              }
     74              else
     75              {
     76                circleNum = validcircleNum;
   \                     ??updateUart_10: (+1)
   \   0000016E   0x9801             LDR      R0,[SP, #+4]
   \   00000170   0xF8C4 0x07E0      STR      R0,[R4, #+2016]
     77          #if SENSOR_LIDARLITE == SENSOR_USED
     78                position.x = (circleFilter_x.newData(positionX_raw, vel.x, t) - 320) * 0.147  * LidarLite->position.z / 100;//640
     79                position.y = (circleFilter_y.newData(positionY_raw, vel.y, t) - 240) * 0.1418 * LidarLite->position.z / 100;//360
     80          #endif
     81                newCircle = true;
   \   00000174   0x2001             MOVS     R0,#+1
   \   00000176   0xF88D 0x0000      STRB     R0,[SP, #+0]
     82              }
     83              
     84             // vel.x = (circleFilter_x.newData(velX_raw, IMU_acc_E.x, t)) * 0.147  * LidarLite->position.z / 100;
     85             // vel.y = (circleFilter_y.newData(velY_raw, IMU_acc_E.y, t)) * 0.1418 * LidarLite->position.z / 100;
     86              float tempX, tempY;
     87          #if SENSOR_LIDARLITE == SENSOR_USED
     88              tempX = velFilter_x.newData(velX_raw * LidarLite->position.z, t);//  * scale_test; //0.147
     89              tempY = velFilter_y.newData(velY_raw * LidarLite->position.z, t);//  * scale_test; //0.1418
     90          #endif
     91          
     92          
     93              vel.x = vel.x * 0.4 + tempX * 0.6;
   \                     ??updateUart_11: (+1)
   \   0000017A   0xF604 0x1028      ADDW     R0,R4,#+2344
   \   0000017E   0x.... 0x....      BL       _ZN17CoordinateElementcvfEv
   \   00000182   0xEE10 0x0A10      VMOV     R0,S0
   \   00000186   0x.... 0x....      BL       __aeabi_f2d
   \   0000018A   0x....             LDR.N    R2,??DataTable3_6  ;; 0x9999999a
   \   0000018C   0x....             LDR.N    R3,??DataTable3_7  ;; 0x3fd99999
   \   0000018E   0x.... 0x....      BL       __aeabi_dmul
   \   00000192   0x4682             MOV      R10,R0
   \   00000194   0x468B             MOV      R11,R1
   \   00000196   0xEE18 0x0A10      VMOV     R0,S16
   \   0000019A   0x.... 0x....      BL       __aeabi_f2d
   \   0000019E   0xF05F 0x3233      MOVS     R2,#+858993459
   \   000001A2   0x....             LDR.N    R3,??DataTable3_8  ;; 0x3fe33333
   \   000001A4   0x.... 0x....      BL       __aeabi_dmul
   \   000001A8   0x4652             MOV      R2,R10
   \   000001AA   0x465B             MOV      R3,R11
   \   000001AC   0x.... 0x....      BL       __aeabi_dadd
   \   000001B0   0x.... 0x....      BL       __aeabi_d2f
   \   000001B4   0xEE00 0x0A10      VMOV     S0,R0
   \   000001B8   0xF604 0x1028      ADDW     R0,R4,#+2344
   \   000001BC   0x.... 0x....      BL       _ZN17CoordinateElementaSEf
     94              vel.y = vel.y * 0.4 + tempY * 0.6;
   \   000001C0   0xF604 0x1044      ADDW     R0,R4,#+2372
   \   000001C4   0x.... 0x....      BL       _ZN17CoordinateElementcvfEv
   \   000001C8   0xEE10 0x0A10      VMOV     R0,S0
   \   000001CC   0x.... 0x....      BL       __aeabi_f2d
   \   000001D0   0x....             LDR.N    R2,??DataTable3_6  ;; 0x9999999a
   \   000001D2   0x....             LDR.N    R3,??DataTable3_7  ;; 0x3fd99999
   \   000001D4   0x.... 0x....      BL       __aeabi_dmul
   \   000001D8   0x4682             MOV      R10,R0
   \   000001DA   0x468B             MOV      R11,R1
   \   000001DC   0xEE18 0x0A90      VMOV     R0,S17
   \   000001E0   0x.... 0x....      BL       __aeabi_f2d
   \   000001E4   0xF05F 0x3233      MOVS     R2,#+858993459
   \   000001E8   0x....             LDR.N    R3,??DataTable3_8  ;; 0x3fe33333
   \   000001EA   0x.... 0x....      BL       __aeabi_dmul
   \   000001EE   0x4652             MOV      R2,R10
   \   000001F0   0x465B             MOV      R3,R11
   \   000001F2   0x.... 0x....      BL       __aeabi_dadd
   \   000001F6   0x.... 0x....      BL       __aeabi_d2f
   \   000001FA   0xEE00 0x0A10      VMOV     S0,R0
   \   000001FE   0xF604 0x1044      ADDW     R0,R4,#+2372
   \   00000202   0x.... 0x....      BL       _ZN17CoordinateElementaSEf
     95              
     96          //    float temp = velFilter.newData(velX_raw, vel_z_CF, t);
     97          //    temp_111 = temp;
     98          //    if(!(temp == temp)) //对于NaN temp == temp 返回false
     99          //    {
    100          //      while(1){}
    101          //    }
    102          //    if(NvidiaTX1->velFilter.isValid())
    103          //    {
    104          //      position.z = (0) * (position.z + vel_z_CF * 0.002) + (1)*(temp); 
    105          //    }
    106          //    else
    107          //    {
    108          //    //  position.z = (1) * (position.z + vel_z_CF * 0.002) + (0)*(temp);
    109          //    }
    110          
    111              newPackage = true;
   \   00000206   0x2001             MOVS     R0,#+1
   \   00000208   0x4681             MOV      R9,R0
    112            }
   \                     ??updateUart_4: (+1)
   \   0000020A   0x1C76             ADDS     R6,R6,#+1
   \   0000020C   0xE723             B.N      ??updateUart_0
    113            
    114            if(newPackage)
   \                     ??updateUart_1: (+1)
   \   0000020E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000212   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000216   0xD037             BEQ.N    ??updateUart_12
    115            {
    116              position.z.calculateD(t); //注意每个周期只应调用一次 否则delta t是0
   \   00000218   0x....             LDR.N    R0,??DataTable3_5
   \   0000021A   0x6801             LDR      R1,[R0, #+0]
   \   0000021C   0xF604 0x100C      ADDW     R0,R4,#+2316
   \   00000220   0x.... 0x....      BL       _ZN17CoordinateElement10calculateDEi
    117              velFilter_x.setNewDataTime(t);    
   \   00000224   0x....             LDR.N    R0,??DataTable3_5
   \   00000226   0x6801             LDR      R1,[R0, #+0]
   \   00000228   0xF204 0x70F4      ADDW     R0,R4,#+2036
   \   0000022C   0x.... 0x....      BL       _ZN11CJumpFilter14setNewDataTimeEi
    118              velFilter_y.setNewDataTime(t);   
   \   00000230   0x....             LDR.N    R0,??DataTable3_5
   \   00000232   0x6801             LDR      R1,[R0, #+0]
   \   00000234   0xF604 0x002C      ADDW     R0,R4,#+2092
   \   00000238   0x.... 0x....      BL       _ZN11CJumpFilter14setNewDataTimeEi
    119              if(newCircle)
   \   0000023C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000240   0x2800             CMP      R0,#+0
   \   00000242   0xD021             BEQ.N    ??updateUart_12
    120              {
    121                position.x.calculateD(t);
   \   00000244   0x....             LDR.N    R0,??DataTable3_5
   \   00000246   0x6801             LDR      R1,[R0, #+0]
   \   00000248   0xF604 0x00D4      ADDW     R0,R4,#+2260
   \   0000024C   0x.... 0x....      BL       _ZN17CoordinateElement10calculateDEi
    122                position.y.calculateD(t);
   \   00000250   0x....             LDR.N    R0,??DataTable3_5
   \   00000252   0x6801             LDR      R1,[R0, #+0]
   \   00000254   0xF514 0x600F      ADDS     R0,R4,#+2288
   \   00000258   0x.... 0x....      BL       _ZN17CoordinateElement10calculateDEi
    123                circleFilter_x.setNewDataTime(t); 
   \   0000025C   0x....             LDR.N    R0,??DataTable3_5
   \   0000025E   0x6801             LDR      R1,[R0, #+0]
   \   00000260   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   00000264   0x.... 0x....      BL       _ZN11CJumpFilter14setNewDataTimeEi
    124                circleFilter_y.setNewDataTime(t); 
   \   00000268   0x....             LDR.N    R0,??DataTable3_5
   \   0000026A   0x6801             LDR      R1,[R0, #+0]
   \   0000026C   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   00000270   0x.... 0x....      BL       _ZN11CJumpFilter14setNewDataTimeEi
    125                
    126                circleFilter_x.setValid(true);
   \   00000274   0x2101             MOVS     R1,#+1
   \   00000276   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   0000027A   0x.... 0x....      BL       _ZN11CJumpFilter8setValidEb
    127                circleFilter_y.setValid(true);
   \   0000027E   0x2101             MOVS     R1,#+1
   \   00000280   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   00000284   0x.... 0x....      BL       _ZN11CJumpFilter8setValidEb
    128              }
    129            }
    130            newPackage = false;
   \                     ??updateUart_12: (+1)
   \   00000288   0x2000             MOVS     R0,#+0
   \   0000028A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    131            
    132            moveLength = (DMA0->TCD[DMA_CH0].DADDR - (uint32)&uartData[0]) - i0;
   \   0000028E   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40009010
   \   00000290   0x6807             LDR      R7,[R0, #+0]
   \   00000292   0x1B3F             SUBS     R7,R7,R4
   \   00000294   0xEBB7 0x0708      SUBS     R7,R7,R8
    133            if(moveLength < 0) moveLength = 0;
   \   00000298   0x2F00             CMP      R7,#+0
   \   0000029A   0xD501             BPL.N    ??updateUart_13
   \   0000029C   0x2000             MOVS     R0,#+0
   \   0000029E   0x0007             MOVS     R7,R0
    134             
    135            DMA_LoadDstAddr(DMA_CH0, (uint32)&uartData[0] + moveLength);
   \                     ??updateUart_13: (+1)
   \   000002A0   0x1938             ADDS     R0,R7,R4
   \   000002A2   0x....             LDR.N    R1,??DataTable3_4  ;; 0x40009010
   \   000002A4   0x6008             STR      R0,[R1, #+0]
    136            for(i = 0; i < moveLength; i++)
   \   000002A6   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??updateUart_14: (+1)
   \   000002AA   0x45B9             CMP      R9,R7
   \   000002AC   0xDA07             BGE.N    ??updateUart_15
    137            {
    138              uartData[i] = uartData[i0 + i];
   \   000002AE   0xEB19 0x0008      ADDS     R0,R9,R8
   \   000002B2   0x5C20             LDRB     R0,[R4, R0]
   \   000002B4   0xF804 0x0009      STRB     R0,[R4, R9]
    139            }
   \   000002B8   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000002BC   0xE7F5             B.N      ??updateUart_14
    140            memset(uartData + moveLength, 0, 150 * sizeof(char));
   \                     ??updateUart_15: (+1)
   \   000002BE   0x2696             MOVS     R6,#+150
   \   000002C0   0xF05F 0x0A00      MOVS     R10,#+0
   \   000002C4   0xEB04 0x0B07      ADD      R11,R4,R7
   \   000002C8   0x4652             MOV      R2,R10
   \   000002CA   0x0031             MOVS     R1,R6
   \   000002CC   0x4658             MOV      R0,R11
   \   000002CE   0x.... 0x....      BL       __aeabi_memset
    141            if(address0 > 100)
   \   000002D2   0x2D65             CMP      R5,#+101
   \   000002D4   0xDB01             BLT.N    ??updateUart_16
    142            {
    143              DMA_LoadDstAddr(DMA_CH0, (uint32)&uartData[0]);
   \   000002D6   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40009010
   \   000002D8   0x6004             STR      R4,[R0, #+0]
    144            }
    145          }
   \                     ??updateUart_16: (+1)
   \                     ??updateUart_17: (+1)
   \   000002DA   0xB006             ADD      SP,SP,#+24
   \   000002DC   0xECBD 0x8B02      VPOP     {D8}
   \   000002E0   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    146          
    147          

   \                                 In section .text, align 2, keep-with-next
    148          void NvidiaTX1__::PIT_isr()
    149          {
   \                     _ZN11NvidiaTX1__7PIT_isrEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    150            this->velFilter_x.checkIsNewData(t);
   \   00000004   0x....             LDR.N    R0,??DataTable3_5
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF204 0x70F4      ADDW     R0,R4,#+2036
   \   0000000C   0x.... 0x....      BL       _ZN11CJumpFilter14checkIsNewDataEi
    151            this->velFilter_y.checkIsNewData(t);
   \   00000010   0x....             LDR.N    R0,??DataTable3_5
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF604 0x002C      ADDW     R0,R4,#+2092
   \   00000018   0x.... 0x....      BL       _ZN11CJumpFilter14checkIsNewDataEi
    152            velFilter_x.accumulate(IMU_acc_E.x * 0.002);
   \   0000001C   0x....             LDR.N    R0,??DataTable3_9
   \   0000001E   0x.... 0x....      BL       _ZN17CoordinateElementcvfEv
   \   00000022   0xEE10 0x0A10      VMOV     R0,S0
   \   00000026   0x.... 0x....      BL       __aeabi_f2d
   \   0000002A   0x....             LDR.N    R2,??DataTable3_10  ;; 0xd2f1a9fc
   \   0000002C   0x....             LDR.N    R3,??DataTable3_11  ;; 0x3f60624d
   \   0000002E   0x.... 0x....      BL       __aeabi_dmul
   \   00000032   0x.... 0x....      BL       __aeabi_d2f
   \   00000036   0xEE00 0x0A10      VMOV     S0,R0
   \   0000003A   0xF204 0x70F4      ADDW     R0,R4,#+2036
   \   0000003E   0x.... 0x....      BL       _ZN11CJumpFilter10accumulateEf
    153            velFilter_y.accumulate(IMU_acc_E.y * 0.002);
   \   00000042   0x....             LDR.N    R0,??DataTable3_12
   \   00000044   0x.... 0x....      BL       _ZN17CoordinateElementcvfEv
   \   00000048   0xEE10 0x0A10      VMOV     R0,S0
   \   0000004C   0x.... 0x....      BL       __aeabi_f2d
   \   00000050   0x....             LDR.N    R2,??DataTable3_10  ;; 0xd2f1a9fc
   \   00000052   0x....             LDR.N    R3,??DataTable3_11  ;; 0x3f60624d
   \   00000054   0x.... 0x....      BL       __aeabi_dmul
   \   00000058   0x.... 0x....      BL       __aeabi_d2f
   \   0000005C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000060   0xF604 0x002C      ADDW     R0,R4,#+2092
   \   00000064   0x.... 0x....      BL       _ZN11CJumpFilter10accumulateEf
    154            this->circleFilter_x.checkIsNewData(t);
   \   00000068   0x....             LDR.N    R0,??DataTable3_5
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF604 0x0064      ADDW     R0,R4,#+2148
   \   00000070   0x.... 0x....      BL       _ZN11CJumpFilter14checkIsNewDataEi
    155            this->circleFilter_y.checkIsNewData(t);
   \   00000074   0x....             LDR.N    R0,??DataTable3_5
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF604 0x009C      ADDW     R0,R4,#+2204
   \   0000007C   0x.... 0x....      BL       _ZN11CJumpFilter14checkIsNewDataEi
    156          }
   \                     ??PIT_isr_0: (+1)
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
    157          
    158          
    159          
    160          
    161          

   \                                 In section .text, align 2, keep-with-next
    162          void NvidiaTX1__::TX_::startDMA_Transmit()
    163          { 
    164            //调整源地址
    165            DMA0->TCD[DMA_CH3].SADDR = DMA_SADDR_SADDR(NvidiaTX1->TX.data);
   \                     _ZN11NvidiaTX1__3TX_17startDMA_TransmitEv: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3_3
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF511 0x611D      ADDS     R1,R1,#+2512
   \   00000008   0x....             LDR.N    R2,??DataTable3_13  ;; 0x40009060
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    166            
    167            //设置主循环计数器 current major loop count
    168            DMA0->TCD[DMA_CH3].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(NvidiaTX1->TX.index);
   \   0000000C   0x....             LDR.N    R1,??DataTable3_3
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xF8D1 0x1AFC      LDR      R1,[R1, #+2812]
   \   00000014   0x0449             LSLS     R1,R1,#+17       ;; ZeroExtS R1,R1,#+17,#+17
   \   00000016   0x0C49             LSRS     R1,R1,#+17
   \   00000018   0x....             LDR.N    R2,??DataTable3_14  ;; 0x40009076
   \   0000001A   0x8011             STRH     R1,[R2, #+0]
    169            
    170            //起始循环计数器，当主循环计数器为零的时候，将装载起始循环计数器的值
    171            DMA0->TCD[DMA_CH3].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(NvidiaTX1->TX.index);
   \   0000001C   0x....             LDR.N    R1,??DataTable3_3
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF8D1 0x1AFC      LDR      R1,[R1, #+2812]
   \   00000024   0x0449             LSLS     R1,R1,#+17       ;; ZeroExtS R1,R1,#+17,#+17
   \   00000026   0x0C49             LSRS     R1,R1,#+17
   \   00000028   0x....             LDR.N    R2,??DataTable3_15  ;; 0x4000907e
   \   0000002A   0x8011             STRH     R1,[R2, #+0]
    172              
    173            DMA_EnableReq(DMA_CH3);
   \   0000002C   0x....             LDR.N    R1,??DataTable3_16  ;; 0x4000800c
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000034   0x....             LDR.N    R2,??DataTable3_16  ;; 0x4000800c
   \   00000036   0x6011             STR      R1,[R2, #+0]
    174          }
   \   00000038   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x453B8000         DC32     0x453b8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     `NvidiaTX1_Init()::static guard for NvidiaTX1_0`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     `NvidiaTX1_Init()::NvidiaTX1_0`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     NvidiaTX1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40009010         DC32     0x40009010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     t

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x3FD99999         DC32     0x3fd99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     IMU_acc_E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x3F60624D         DC32     0x3f60624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     IMU_acc_E+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x40009060         DC32     0x40009060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x40009076         DC32     0x40009076

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x4000907E         DC32     0x4000907e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x4000800C         DC32     0x4000800c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CJumpFilter::CJumpFilter()
       8   Coordinate::Coordinate()
         8   -> CoordinateElement::CoordinateElement()
       0   CoordinateElement::CoordinateElement()
       8   NvidiaTX1_Init()
         8   -> NvidiaTX1__::NvidiaTX1__()
       8   NvidiaTX1__::NvidiaTX1__()
         8   -> CJumpFilter::CJumpFilter()
         8   -> CJumpFilter::setParameter(float, int)
         8   -> CJumpFilter::setParameter(float, int, float)
         8   -> Coordinate::Coordinate()
       8   NvidiaTX1__::PIT_isr()
         8   -> CJumpFilter::accumulate(float)
         8   -> CJumpFilter::checkIsNewData(int)
         8   -> CoordinateElement::operator float()
         8   -> __aeabi_d2f
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
       0   NvidiaTX1__::TX_::startDMA_Transmit()
      72   NvidiaTX1__::updateUart()
        72   -> CJumpFilter::setNewDataTime(int)
        72   -> CJumpFilter::setValid(bool)
        72   -> CoordinateElement::calculateD(int)
        72   -> CoordinateElement::operator float()
        72   -> CoordinateElement::operator=(float)
        72   -> __aeabi_d2f
        72   -> __aeabi_dadd
        72   -> __aeabi_dmul
        72   -> __aeabi_f2d
        72   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      24  CJumpFilter::CJumpFilter()
      30  Coordinate::Coordinate()
      28  CoordinateElement::CoordinateElement()
       4  NvidiaTX1
    2820  NvidiaTX1_0
      40  NvidiaTX1_Init()
     140  NvidiaTX1__::NvidiaTX1__()
     130  NvidiaTX1__::PIT_isr()
      58  NvidiaTX1__::TX_::startDMA_Transmit()
     740  NvidiaTX1__::updateUart()
      45  -- Other

 
    32 bytes in section .ARM.exidx
    12 bytes in section .ARM.extab
 2 825 bytes in section .bss
 1 258 bytes in section .text
 
 1 036 bytes of CODE  memory (+ 222 bytes shared)
    44 bytes of CONST memory
 2 825 bytes of DATA  memory

Errors: none
Warnings: 2
