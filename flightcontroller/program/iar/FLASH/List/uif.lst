###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         31/Aug/2018  16:57:01
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\common\uif.c
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW8BC5.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\common\uif.c
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\inc\c\DLib_Config_Full.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Core\Include\ -I
#        D:\iar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List\uif.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj\uif.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\common\uif.c
      1          /**
      2           * @file uif.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief 提供简单的交互接口
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * The commands, set/show parameters, and prompt are configured 
     10           * at the project level
     11           *
     12           * 版权所有:北京拉普兰德电子技术有限公司
     13           * http://www.lpld.cn
     14           * mail:support@lpld.cn
     15           *
     16           * @par
     17           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     18           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     19           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     20           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     21           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     22           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     23           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     24           */
     25          
     26          #include "common.h"
     27          #include "uif.h"
     28          #include <string.h>
     29          #include <stdlib.h>
     30          
     31          /********************************************************************/
     32          /*
     33           * Global messages -- constant strings
     34           */

   \                                 In section .rodata, align 4
     35          const char HELPMSG[] =
   \                     HELPMSG:
   \        0x0   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     36              "Enter 'help' for help.\n";
     37          

   \                                 In section .rodata, align 4
     38          const char INVARG[] =
   \                     INVARG:
   \        0x0   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     39              "Error: Invalid argument: %s\n";
     40          

   \                                 In section .rodata, align 4
     41          const char INVALUE[] = 
   \                     INVALUE:
   \        0x0   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \       0x1A   0x00 0x00          DC8 0, 0
     42              "Error: Invalid value: %s\n";
     43          
     44          /*
     45           * Strings used by this file only
     46           */

   \                                 In section .rodata, align 4
     47          static const char INVCMD[] =
   \                     INVCMD:
   \        0x0   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     48              "Error: No such command: %s\n";
     49          

   \                                 In section .rodata, align 4
     50          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \        0x0   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \       0x12   0x00 0x00          DC8 0, 0
     51              "%8s  %-25s %s %s\n";
     52          

   \                                 In section .rodata, align 4
     53          static const char SYNTAX[] = 
   \                     SYNTAX:
   \        0x0   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x1F   0x00               DC8 0
     54              "Error: Invalid syntax for: %s\n";
     55          

   \                                 In section .rodata, align 4
     56          static const char INVOPT[] = 
   \                     INVOPT:
   \        0x0   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x25   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     57              "Error:  Invalid set/show option: %s\n";
     58          

   \                                 In section .rodata, align 4
     59          static const char OPTFMT[] = 
   \                     OPTFMT:
   \        0x0   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \        0x7   0x00               DC8 0
     60              "%12s: ";
     61          

   \                                 In section .bss, align 4
     62          static char cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \        0x0                      DS8 80

   \                                 In section .bss, align 4
     63          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \        0x0                      DS8 80
     64          
     65          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     66          char *get_line (char *line)
     67          {
   \                     get_line: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
     68              int32 pos;
     69              int32 ch;
     70          
     71              pos = 0;
   \        0x4   0x2500             MOVS     R5,#+0
     72              ch = (int32)in_char();
   \        0x6   0x.... 0x....      BL       in_char
   \        0xA   0x0006             MOVS     R6,R0
     73              while ( (ch != 0x0D /* CR */) &&
     74                      (ch != 0x0A /* LF/NL */) &&
     75                      (pos < UIF_MAX_LINE))
   \                     ??get_line_0: (+1)
   \        0xC   0x2E0D             CMP      R6,#+13
   \        0xE   0xD026             BEQ.N    ??get_line_1
   \       0x10   0x2E0A             CMP      R6,#+10
   \       0x12   0xD024             BEQ.N    ??get_line_1
   \       0x14   0x2D50             CMP      R5,#+80
   \       0x16   0xDA22             BGE.N    ??get_line_1
     76              {
     77                  switch (ch)
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x2808             CMP      R0,#+8
   \       0x1C   0xD001             BEQ.N    ??get_line_2
   \       0x1E   0x287F             CMP      R0,#+127
   \       0x20   0xD10C             BNE.N    ??get_line_3
     78                  {
     79                      case 0x08:      /* Backspace */
     80                      case 0x7F:      /* Delete */
     81                          if (pos > 0)
   \                     ??get_line_2: (+1)
   \       0x22   0x2D01             CMP      R5,#+1
   \       0x24   0xDB09             BLT.N    ??get_line_4
     82                          {
     83                              pos -= 1;
   \       0x26   0x1E6D             SUBS     R5,R5,#+1
     84                              out_char(0x08);    /* backspace */
   \       0x28   0x2008             MOVS     R0,#+8
   \       0x2A   0x.... 0x....      BL       out_char
     85                              out_char(' ');
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0x.... 0x....      BL       out_char
     86                              out_char(0x08);    /* backspace */
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0x.... 0x....      BL       out_char
     87                          }
     88                          break;
   \                     ??get_line_4: (+1)
   \       0x3A   0xE00C             B.N      ??get_line_5
     89                      default:
     90                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_3: (+1)
   \       0x3C   0x1C68             ADDS     R0,R5,#+1
   \       0x3E   0x2850             CMP      R0,#+80
   \       0x40   0xDA09             BGE.N    ??get_line_6
     91                          {
     92                              if ((ch > 0x1f) && (ch < 0x80))
   \       0x42   0x2E20             CMP      R6,#+32
   \       0x44   0xDB07             BLT.N    ??get_line_6
   \       0x46   0x2E80             CMP      R6,#+128
   \       0x48   0xDA05             BGE.N    ??get_line_6
     93                              {
     94                                  line[pos++] = (char)ch;
   \       0x4A   0x5566             STRB     R6,[R4, R5]
   \       0x4C   0x1C6D             ADDS     R5,R5,#+1
     95                                  out_char((char)ch);
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x52   0x.... 0x....      BL       out_char
     96                              }
     97                          }
     98                          break;
     99                  }
    100                  ch = (int32)in_char();
   \                     ??get_line_6: (+1)
   \                     ??get_line_5: (+1)
   \       0x56   0x.... 0x....      BL       in_char
   \       0x5A   0x0006             MOVS     R6,R0
   \       0x5C   0xE7D6             B.N      ??get_line_0
    101              }
    102              line[pos] = '\0';
   \                     ??get_line_1: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x5560             STRB     R0,[R4, R5]
    103              out_char(0x0D);    /* CR */
   \       0x62   0x200D             MOVS     R0,#+13
   \       0x64   0x.... 0x....      BL       out_char
    104              out_char(0x0A);    /* LF */
   \       0x68   0x200A             MOVS     R0,#+10
   \       0x6A   0x.... 0x....      BL       out_char
    105          
    106              return line;
   \       0x6E   0x0020             MOVS     R0,R4
   \                     ??get_line_7: (+1)
   \       0x70   0xBD70             POP      {R4-R6,PC}       ;; return
    107          }
    108          
    109          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    110          int32 make_argv (char *cmdline, char *argv[])
    111          {
   \                     make_argv: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0004             MOVS     R4,R0
    112              int32 argc, i, in_text;
    113          
    114              /* 
    115               * Break cmdline into strings and argv
    116               * It is permissible for argv to be NULL, in which case
    117               * the purpose of this routine becomes to count args
    118               */
    119              argc = 0;
   \        0x4   0x2300             MOVS     R3,#+0
    120              i = 0;
   \        0x6   0x2500             MOVS     R5,#+0
    121              in_text = FALSE;
   \        0x8   0x2200             MOVS     R2,#+0
    122              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
   \                     ??make_argv_0: (+1)
   \        0xA   0x5D60             LDRB     R0,[R4, R5]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD01D             BEQ.N    ??make_argv_1
    123              {
    124                  if (((cmdline[i] == ' ')   ||
    125                       (cmdline[i] == '\t')) )
   \       0x10   0x5D60             LDRB     R0,[R4, R5]
   \       0x12   0x2820             CMP      R0,#+32
   \       0x14   0xD002             BEQ.N    ??make_argv_2
   \       0x16   0x5D60             LDRB     R0,[R4, R5]
   \       0x18   0x2809             CMP      R0,#+9
   \       0x1A   0xD106             BNE.N    ??make_argv_3
    126                  {
    127                      if (in_text)
   \                     ??make_argv_2: (+1)
   \       0x1C   0x2A00             CMP      R2,#+0
   \       0x1E   0xD013             BEQ.N    ??make_argv_4
    128                      {
    129                          /* end of command line argument */
    130                          cmdline[i] = '\0';
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x5560             STRB     R0,[R4, R5]
    131                          in_text = FALSE;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0002             MOVS     R2,R0
   \       0x28   0xE00E             B.N      ??make_argv_4
    132                      }
    133                      else
    134                      {
    135                          /* still looking for next argument */
    136                          
    137                      }
    138                  }
    139                  else
    140                  {
    141                      /* got non-whitespace character */
    142                      if (in_text)
   \                     ??make_argv_3: (+1)
   \       0x2A   0x2A00             CMP      R2,#+0
   \       0x2C   0xD10C             BNE.N    ??make_argv_4
    143                      {
    144                      }
    145                      else
    146                      {
    147                          /* start of an argument */
    148                          in_text = TRUE;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x0002             MOVS     R2,R0
    149                          if (argc < UIF_MAX_ARGS)
   \       0x32   0x2B0A             CMP      R3,#+10
   \       0x34   0xDA07             BGE.N    ??make_argv_5
    150                          {
    151                              if (argv != NULL)
   \       0x36   0x2900             CMP      R1,#+0
   \       0x38   0xD003             BEQ.N    ??make_argv_6
    152                                  argv[argc] = &cmdline[i];
   \       0x3A   0xEB04 0x0005      ADD      R0,R4,R5
   \       0x3E   0xF841 0x0023      STR      R0,[R1, R3, LSL #+2]
    153                              argc++;
   \                     ??make_argv_6: (+1)
   \       0x42   0x1C5B             ADDS     R3,R3,#+1
   \       0x44   0xE000             B.N      ??make_argv_4
    154                          }
    155                          else
    156                              /*return argc;*/
    157                              break;
   \                     ??make_argv_5: (+1)
   \       0x46   0xE001             B.N      ??make_argv_1
    158                      }
    159          
    160                  }
    161                  i++;    /* proceed to next character */
   \                     ??make_argv_4: (+1)
   \       0x48   0x1C6D             ADDS     R5,R5,#+1
   \       0x4A   0xE7DE             B.N      ??make_argv_0
    162              }
    163              if (argv != NULL)
   \                     ??make_argv_1: (+1)
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD002             BEQ.N    ??make_argv_7
    164                  argv[argc] = NULL;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xF841 0x0023      STR      R0,[R1, R3, LSL #+2]
    165              return argc;
   \                     ??make_argv_7: (+1)
   \       0x56   0x0018             MOVS     R0,R3
   \       0x58   0xBC30             POP      {R4,R5}
   \       0x5A   0x4770             BX       LR               ;; return
    166          }
    167          
    168          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          void run_cmd (void)
    170          {
   \                     run_cmd: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
    171              /*
    172               * Global array of pointers to emulate C argc,argv interface
    173               */
    174              int32 argc;
    175              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    176          
    177              get_line(cmdline1);
   \        0x6   0x....             LDR.N    R5,??DataTable4_3
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       get_line
    178          
    179              if (!(argc = make_argv(cmdline1,argv)))
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       make_argv
   \       0x16   0x0004             MOVS     R4,R0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD101             BNE.N    ??run_cmd_0
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??run_cmd_1
   \                     ??run_cmd_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??run_cmd_1: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD007             BEQ.N    ??run_cmd_2
    180              {
    181                  /* no command entered, just a blank line */
    182                  strcpy(cmdline1,cmdline2);
   \       0x28   0x....             LDR.N    R1,??DataTable4_4
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       strcpy
    183                  argc = make_argv(cmdline1,argv);
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x.... 0x....      BL       make_argv
   \       0x36   0x0004             MOVS     R4,R0
    184              }
    185              cmdline2[0] = '\0';
   \                     ??run_cmd_2: (+1)
   \       0x38   0x....             LDR.N    R5,??DataTable4_4
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x7028             STRB     R0,[R5, #+0]
    186          
    187              if (argc)
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD03F             BEQ.N    ??run_cmd_3
    188              {
    189                  int32 i;
    190                  for (i = 0; i < UIF_NUM_CMD; i++)
   \       0x42   0x2600             MOVS     R6,#+0
   \                     ??run_cmd_4: (+1)
   \       0x44   0x....             LDR.N    R0,??DataTable4_5
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0x4286             CMP      R6,R0
   \       0x4A   0xDA33             BGE.N    ??run_cmd_5
    191                  {
    192                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \       0x4C   0x271C             MOVS     R7,#+28
   \       0x4E   0x.... 0x....      LDR.W    R8,??DataTable4_6
   \       0x52   0x9900             LDR      R1,[SP, #+0]
   \       0x54   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x58   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x5C   0x.... 0x....      BL       strcasecmp
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD125             BNE.N    ??run_cmd_6
    193                      {
    194                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    195                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \       0x64   0x1E60             SUBS     R0,R4,#+1
   \       0x66   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x6A   0x4441             ADD      R1,R8,R1
   \       0x6C   0x6849             LDR      R1,[R1, #+4]
   \       0x6E   0x4288             CMP      R0,R1
   \       0x70   0xDB19             BLT.N    ??run_cmd_7
   \       0x72   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x76   0x4440             ADD      R0,R8,R0
   \       0x78   0x6880             LDR      R0,[R0, #+8]
   \       0x7A   0x1E61             SUBS     R1,R4,#+1
   \       0x7C   0x4288             CMP      R0,R1
   \       0x7E   0xDB12             BLT.N    ??run_cmd_7
    196                          {
    197                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \       0x80   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x84   0x4440             ADD      R0,R8,R0
   \       0x86   0x7B00             LDRB     R0,[R0, #+12]
   \       0x88   0x07C0             LSLS     R0,R0,#+31
   \       0x8A   0xD503             BPL.N    ??run_cmd_8
    198                              {
    199                                  strcpy(cmdline2,argv[0]);
   \       0x8C   0x9900             LDR      R1,[SP, #+0]
   \       0x8E   0x0028             MOVS     R0,R5
   \       0x90   0x.... 0x....      BL       strcpy
    200                              }
    201                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_8: (+1)
   \       0x94   0x4669             MOV      R1,SP
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0xFB07 0xF706      MUL      R7,R7,R6
   \       0x9C   0xEB08 0x0207      ADD      R2,R8,R7
   \       0xA0   0x6912             LDR      R2,[R2, #+16]
   \       0xA2   0x4790             BLX      R2
    202                              return;
   \       0xA4   0xE00D             B.N      ??run_cmd_9
    203                          }
    204                          else
    205                          {
    206                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_7: (+1)
   \       0xA6   0x9900             LDR      R1,[SP, #+0]
   \       0xA8   0x....             LDR.N    R0,??DataTable4_7
   \       0xAA   0x.... 0x....      BL       printf
    207                              return;
   \       0xAE   0xE008             B.N      ??run_cmd_9
    208                          }
    209                      }
    210                  }
   \                     ??run_cmd_6: (+1)
   \       0xB0   0x1C76             ADDS     R6,R6,#+1
   \       0xB2   0xE7C7             B.N      ??run_cmd_4
    211                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_5: (+1)
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x....             LDR.N    R0,??DataTable4_8
   \       0xB8   0x.... 0x....      BL       printf
    212                  printf(HELPMSG);
   \       0xBC   0x....             LDR.N    R0,??DataTable4_9
   \       0xBE   0x.... 0x....      BL       printf
    213              }
    214          }
   \                     ??run_cmd_3: (+1)
   \                     ??run_cmd_9: (+1)
   \       0xC2   0xB00C             ADD      SP,SP,#+48
   \       0xC4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    215          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    216          uint32 get_value (char *s, int32 *success, int32 base)
    217          {
   \                     get_value: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    218              uint32 value;
    219              char *p;
    220          
    221              value = strtoul(s,&p,base);
   \        0x8   0x0032             MOVS     R2,R6
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       strtoul
   \       0x12   0x0001             MOVS     R1,R0
    222              if ((value == 0) && (p == s))
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD106             BNE.N    ??get_value_0
   \       0x18   0x9800             LDR      R0,[SP, #+0]
   \       0x1A   0x42A0             CMP      R0,R4
   \       0x1C   0xD103             BNE.N    ??get_value_0
    223              {
    224                  *success = FALSE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6028             STR      R0,[R5, #+0]
    225                  return 0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE002             B.N      ??get_value_1
    226              }
    227              else
    228              {
    229                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x6028             STR      R0,[R5, #+0]
    230                  return value;
   \       0x2A   0x0008             MOVS     R0,R1
   \                     ??get_value_1: (+1)
   \       0x2C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    231              }
    232          }
    233          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          void uif_cmd_help (int32 argc, char **argv)
    235          {
   \                     uif_cmd_help: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    236              int32 index;
    237              
    238              (void)argc;
    239              (void)argv;
    240              
    241              printf("\n");
   \        0x6   0x....             ADR.N    R6,??DataTable4  ;; "\n"
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0x.... 0x....      BL       printf
    242              for (index = 0; index < UIF_NUM_CMD; index++)
   \        0xE   0x2700             MOVS     R7,#+0
   \                     ??uif_cmd_help_0: (+1)
   \       0x10   0x....             LDR.N    R0,??DataTable4_5
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4287             CMP      R7,R0
   \       0x16   0xDA15             BGE.N    ??uif_cmd_help_1
    243              {
    244                  printf(HELPFORMAT,
    245                      UIF_CMDTAB[index].cmd,
    246                      UIF_CMDTAB[index].description,
    247                      UIF_CMDTAB[index].cmd,
    248                      UIF_CMDTAB[index].syntax);
   \       0x18   0x201C             MOVS     R0,#+28
   \       0x1A   0x....             LDR.N    R1,??DataTable4_6
   \       0x1C   0xFB00 0xF207      MUL      R2,R0,R7
   \       0x20   0x440A             ADD      R2,R1,R2
   \       0x22   0x6992             LDR      R2,[R2, #+24]
   \       0x24   0x9200             STR      R2,[SP, #+0]
   \       0x26   0xFB00 0xF207      MUL      R2,R0,R7
   \       0x2A   0x588B             LDR      R3,[R1, R2]
   \       0x2C   0xFB00 0xF207      MUL      R2,R0,R7
   \       0x30   0x440A             ADD      R2,R1,R2
   \       0x32   0x6952             LDR      R2,[R2, #+20]
   \       0x34   0xFB00 0xF007      MUL      R0,R0,R7
   \       0x38   0x5809             LDR      R1,[R1, R0]
   \       0x3A   0x....             LDR.N    R0,??DataTable4_10
   \       0x3C   0x.... 0x....      BL       printf
    249              }
   \       0x40   0x1C7F             ADDS     R7,R7,#+1
   \       0x42   0xE7E5             B.N      ??uif_cmd_help_0
    250              printf("\n");
   \                     ??uif_cmd_help_1: (+1)
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0x.... 0x....      BL       printf
    251          }
   \                     ??uif_cmd_help_2: (+1)
   \       0x4A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    252          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void uif_cmd_set (int32 argc, char **argv)
    254          {
   \                     uif_cmd_set: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    255              int32 index;
    256          
    257              printf("\n");
   \        0x8   0x....             ADR.N    R6,??DataTable4  ;; "\n"
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       printf
    258              if (argc == 1)
   \       0x10   0x2C01             CMP      R4,#+1
   \       0x12   0xD120             BNE.N    ??uif_cmd_set_0
    259              {
    260                  printf("Valid 'set' options:\n");
   \       0x14   0x....             LDR.N    R0,??DataTable4_11
   \       0x16   0x.... 0x....      BL       printf
    261                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??uif_cmd_set_1: (+1)
   \       0x1C   0x....             LDR.N    R0,??DataTable4_12
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x4287             CMP      R7,R0
   \       0x22   0xDA14             BGE.N    ??uif_cmd_set_2
    262                  {
    263                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \       0x24   0xF05F 0x0814      MOVS     R8,#+20
   \       0x28   0x.... 0x....      LDR.W    R9,??DataTable4_13
   \       0x2C   0xFB08 0xF007      MUL      R0,R8,R7
   \       0x30   0xF859 0x1000      LDR      R1,[R9, R0]
   \       0x34   0x....             LDR.N    R0,??DataTable4_14
   \       0x36   0x.... 0x....      BL       printf
    264                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \       0x3A   0xFB08 0xF807      MUL      R8,R8,R7
   \       0x3E   0xEB09 0x0008      ADD      R0,R9,R8
   \       0x42   0x6901             LDR      R1,[R0, #+16]
   \       0x44   0x....             ADR.N    R0,??DataTable4_1  ;; "%s\n"
   \       0x46   0x.... 0x....      BL       printf
    265                  }
   \       0x4A   0x1C7F             ADDS     R7,R7,#+1
   \       0x4C   0xE7E6             B.N      ??uif_cmd_set_1
    266                  printf("\n");
   \                     ??uif_cmd_set_2: (+1)
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0x.... 0x....      BL       printf
    267                  return;
   \       0x54   0xE038             B.N      ??uif_cmd_set_3
    268              }
    269          
    270              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \       0x56   0x2C03             CMP      R4,#+3
   \       0x58   0xD003             BEQ.N    ??uif_cmd_set_4
    271              {
    272                  printf("Error: Invalid argument list\n");
   \       0x5A   0x....             LDR.N    R0,??DataTable4_15
   \       0x5C   0x.... 0x....      BL       printf
    273                  return;
   \       0x60   0xE032             B.N      ??uif_cmd_set_3
    274              }
    275          
    276              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \       0x62   0x2600             MOVS     R6,#+0
   \                     ??uif_cmd_set_5: (+1)
   \       0x64   0x....             LDR.N    R0,??DataTable4_12
   \       0x66   0x6800             LDR      R0,[R0, #+0]
   \       0x68   0x4286             CMP      R6,R0
   \       0x6A   0xDA29             BGE.N    ??uif_cmd_set_6
    277              {
    278                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \       0x6C   0x2714             MOVS     R7,#+20
   \       0x6E   0x.... 0x....      LDR.W    R8,??DataTable4_13
   \       0x72   0x6869             LDR      R1,[R5, #+4]
   \       0x74   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x78   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x7C   0x.... 0x....      BL       strcasecmp
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD11B             BNE.N    ??uif_cmd_set_7
    279                  {
    280                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    281                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \       0x84   0x1EA0             SUBS     R0,R4,#+2
   \       0x86   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x8A   0x4441             ADD      R1,R8,R1
   \       0x8C   0x6849             LDR      R1,[R1, #+4]
   \       0x8E   0x4288             CMP      R0,R1
   \       0x90   0xDB0F             BLT.N    ??uif_cmd_set_8
   \       0x92   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x96   0x4440             ADD      R0,R8,R0
   \       0x98   0x6880             LDR      R0,[R0, #+8]
   \       0x9A   0x1EA1             SUBS     R1,R4,#+2
   \       0x9C   0x4288             CMP      R0,R1
   \       0x9E   0xDB08             BLT.N    ??uif_cmd_set_8
    282                      {
    283                          UIF_SETCMDTAB[index].func(argc,argv);
   \       0xA0   0x0029             MOVS     R1,R5
   \       0xA2   0x0020             MOVS     R0,R4
   \       0xA4   0xFB07 0xF706      MUL      R7,R7,R6
   \       0xA8   0xEB08 0x0207      ADD      R2,R8,R7
   \       0xAC   0x68D2             LDR      R2,[R2, #+12]
   \       0xAE   0x4790             BLX      R2
    284                          return;
   \       0xB0   0xE00A             B.N      ??uif_cmd_set_3
    285                      }
    286                      else
    287                      {
    288                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \       0xB2   0x6869             LDR      R1,[R5, #+4]
   \       0xB4   0x....             LDR.N    R0,??DataTable4_16
   \       0xB6   0x.... 0x....      BL       printf
    289                          return;
   \       0xBA   0xE005             B.N      ??uif_cmd_set_3
    290                      }
    291                  }
    292              }
   \                     ??uif_cmd_set_7: (+1)
   \       0xBC   0x1C76             ADDS     R6,R6,#+1
   \       0xBE   0xE7D1             B.N      ??uif_cmd_set_5
    293              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_6: (+1)
   \       0xC0   0x6869             LDR      R1,[R5, #+4]
   \       0xC2   0x....             LDR.N    R0,??DataTable4_17
   \       0xC4   0x.... 0x....      BL       printf
    294          }
   \                     ??uif_cmd_set_3: (+1)
   \       0xC8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    295          
    296          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    297          void uif_cmd_show (int32 argc, char **argv)
    298          {
   \                     uif_cmd_show: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
    299              int32 index;
    300          
    301              printf("\n");
   \        0x8   0x....             ADR.N    R6,??DataTable4  ;; "\n"
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       printf
    302              if (argc == 1)
   \       0x10   0x2D01             CMP      R5,#+1
   \       0x12   0xD124             BNE.N    ??uif_cmd_show_0
    303              {
    304                  /*
    305                   * Show all Option settings
    306                   */
    307                  argc = 2;
   \       0x14   0x2702             MOVS     R7,#+2
    308                  argv[2] = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
    309                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \       0x1A   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??uif_cmd_show_1: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable4_12
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x4580             CMP      R8,R0
   \       0x24   0xDA17             BGE.N    ??uif_cmd_show_2
    310                  {
    311                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \       0x26   0x2514             MOVS     R5,#+20
   \       0x28   0x.... 0x....      LDR.W    R9,??DataTable4_13
   \       0x2C   0xFB05 0xF008      MUL      R0,R5,R8
   \       0x30   0xF859 0x1000      LDR      R1,[R9, R0]
   \       0x34   0x....             LDR.N    R0,??DataTable4_14
   \       0x36   0x.... 0x....      BL       printf
    312                      UIF_SETCMDTAB[index].func(argc,argv);
   \       0x3A   0x0021             MOVS     R1,R4
   \       0x3C   0x0038             MOVS     R0,R7
   \       0x3E   0xFB05 0xF508      MUL      R5,R5,R8
   \       0x42   0xEB09 0x0205      ADD      R2,R9,R5
   \       0x46   0x68D2             LDR      R2,[R2, #+12]
   \       0x48   0x4790             BLX      R2
    313                      printf("\n");
   \       0x4A   0x0030             MOVS     R0,R6
   \       0x4C   0x.... 0x....      BL       printf
    314                  }
   \       0x50   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x54   0xE7E3             B.N      ??uif_cmd_show_1
    315                  printf("\n");
   \                     ??uif_cmd_show_2: (+1)
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0x.... 0x....      BL       printf
    316                  return;
   \       0x5C   0xE03C             B.N      ??uif_cmd_show_3
    317              }
    318          
    319              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \       0x5E   0x2600             MOVS     R6,#+0
   \                     ??uif_cmd_show_4: (+1)
   \       0x60   0x....             LDR.N    R0,??DataTable4_12
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0x4286             CMP      R6,R0
   \       0x66   0xDA33             BGE.N    ??uif_cmd_show_5
    320              {
    321                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \       0x68   0x2714             MOVS     R7,#+20
   \       0x6A   0x.... 0x....      LDR.W    R8,??DataTable4_13
   \       0x6E   0x6861             LDR      R1,[R4, #+4]
   \       0x70   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x74   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x78   0x.... 0x....      BL       strcasecmp
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD125             BNE.N    ??uif_cmd_show_6
    322                  {
    323                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    324                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \       0x80   0x1EA8             SUBS     R0,R5,#+2
   \       0x82   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x86   0x4441             ADD      R1,R8,R1
   \       0x88   0x6849             LDR      R1,[R1, #+4]
   \       0x8A   0x4288             CMP      R0,R1
   \       0x8C   0xDB19             BLT.N    ??uif_cmd_show_7
   \       0x8E   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x92   0x4440             ADD      R0,R8,R0
   \       0x94   0x6880             LDR      R0,[R0, #+8]
   \       0x96   0x1EA9             SUBS     R1,R5,#+2
   \       0x98   0x4288             CMP      R0,R1
   \       0x9A   0xDB12             BLT.N    ??uif_cmd_show_7
    325                      {
    326                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \       0x9C   0xFB07 0xF006      MUL      R0,R7,R6
   \       0xA0   0xF858 0x1000      LDR      R1,[R8, R0]
   \       0xA4   0x....             LDR.N    R0,??DataTable4_14
   \       0xA6   0x.... 0x....      BL       printf
    327                          UIF_SETCMDTAB[index].func(argc,argv);
   \       0xAA   0x0021             MOVS     R1,R4
   \       0xAC   0x0028             MOVS     R0,R5
   \       0xAE   0xFB07 0xF706      MUL      R7,R7,R6
   \       0xB2   0xEB08 0x0207      ADD      R2,R8,R7
   \       0xB6   0x68D2             LDR      R2,[R2, #+12]
   \       0xB8   0x4790             BLX      R2
    328                          printf("\n\n");
   \       0xBA   0x....             ADR.N    R0,??DataTable4_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \       0xBC   0x.... 0x....      BL       printf
    329                          return;
   \       0xC0   0xE00A             B.N      ??uif_cmd_show_3
    330                      }
    331                      else
    332                      {
    333                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \       0xC2   0x6861             LDR      R1,[R4, #+4]
   \       0xC4   0x....             LDR.N    R0,??DataTable4_16
   \       0xC6   0x.... 0x....      BL       printf
    334                          return;
   \       0xCA   0xE005             B.N      ??uif_cmd_show_3
    335                      }
    336                  }
    337              }
   \                     ??uif_cmd_show_6: (+1)
   \       0xCC   0x1C76             ADDS     R6,R6,#+1
   \       0xCE   0xE7C7             B.N      ??uif_cmd_show_4
    338              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_5: (+1)
   \       0xD0   0x6861             LDR      R1,[R4, #+4]
   \       0xD2   0x....             LDR.N    R0,??DataTable4_17
   \       0xD4   0x.... 0x....      BL       printf
    339          }
   \                     ??uif_cmd_show_3: (+1)
   \       0xD8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x....'....        DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x....'....        DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x....'....        DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x....'....        DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x....'....        DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x....'....        DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \        0x0   0x....'....        DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \        0x0   0x....'....        DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \        0x0   0x....'....        DC32     INVOPT

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \        0x3   0x00               DC8 0
    340          
    341          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      24   get_value
        24   -> strtoul
       8   make_argv
      72   run_cmd
        72   -- Indirect call
        72   -> get_line
        72   -> make_argv
        72   -> printf
        72   -> strcasecmp
        72   -> strcpy
      24   uif_cmd_help
        24   -> printf
      32   uif_cmd_set
        32   -- Indirect call
        32   -> printf
        32   -> strcasecmp
      32   uif_cmd_show
        32   -- Indirect call
        32   -> printf
        32   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     114  get_line
      46  get_value
      92  make_argv
     200  run_cmd
      76  uif_cmd_help
     204  uif_cmd_set
     220  uif_cmd_show
      40  -- Other

 
    40 bytes in section .ARM.exidx
   160 bytes in section .bss
   278 bytes in section .rodata
 1 024 bytes in section .text
 
 1 024 bytes of CODE  memory
   318 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: none
