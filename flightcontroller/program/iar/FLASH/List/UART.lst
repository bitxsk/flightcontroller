###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         31/Aug/2018  16:57:01
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW8B47.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\inc\c\DLib_Config_Full.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Core\Include\ -I
#        D:\iar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List\UART.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj\UART.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\UART.c
      1          /**
      2           * @file UART.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief UART底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn)
   \                     _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0xe000e100
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn)
   \                     _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40E             BMI.N    ??__NVIC_DisableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0xe000e180
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x26   0x4770             BX       LR               ;; return
     23          #include "UART.h"
     24          
     25          //用户接收中断函数入口地址数组

   \                                 In section .bss, align 4
     26          UART_ISR_CALLBACK UART_R_ISR[6];
   \                     UART_R_ISR:
   \        0x0                      DS8 24
     27          //用户发送中断函数入口地址数组

   \                                 In section .bss, align 4
     28          UART_ISR_CALLBACK UART_T_ISR[6];  
   \                     UART_T_ISR:
   \        0x0                      DS8 24
     29          
     30          
     31          /*
     32           * UART_Init
     33           * 初始化UART通道、波特率、发送接收引脚
     34           * 
     35           * 参数:
     36           *    uart_init_structure--UART初始化结构体，
     37           *                        具体定义见UART_InitTypeDef
     38           *
     39           * 输出:
     40           *    无
     41           *
     42           */

   \                                 In section .text, align 2, keep-with-next
     43          void UART_Init(UART_InitTypeDef uart_init_structure)
     44          {
   \                     UART_Init: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
     45            register uint16 sbr, brfa;
     46            uint32 sysclk;
     47            uint8 temp, x ,len;
     48            UART_Type *uartx = uart_init_structure.UART_Uartx;
   \        0x6   0x9B09             LDR      R3,[SP, #+36]
     49            uint32 baud = uart_init_structure.UART_BaudRate;
   \        0x8   0x980A             LDR      R0,[SP, #+40]
     50            PortPinsEnum_Type tx_pin = uart_init_structure.UART_TxPin;
   \        0xA   0xF89D 0x402C      LDRB     R4,[SP, #+44]
     51            PortPinsEnum_Type rx_pin = uart_init_structure.UART_RxPin;
   \        0xE   0xF89D 0x502D      LDRB     R5,[SP, #+45]
     52            UART_ISR_CALLBACK rx_isr = uart_init_structure.UART_RxIsr;
   \       0x12   0x9E0E             LDR      R6,[SP, #+56]
     53            UART_ISR_CALLBACK tx_isr = uart_init_structure.UART_TxIsr;
   \       0x14   0x9F0F             LDR      R7,[SP, #+60]
     54            
     55            if(baud == NULL)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??UART_Init_0
     56            {
     57              baud = 9600;
   \       0x1A   0xF44F 0x5116      MOV      R1,#+9600
   \       0x1E   0x0008             MOVS     R0,R1
     58            }
     59            
     60            //使能选中的UART串口通道时钟，相应GPIO的UART复用功能   
     61            if(uartx == UART0)
   \                     ??UART_Init_0: (+1)
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \       0x24   0x428B             CMP      R3,R1
   \       0x26   0xD146             BNE.N    ??UART_Init_1
     62            {
     63              x = 0;
   \       0x28   0xF05F 0x0E00      MOVS     LR,#+0
     64              sysclk = g_core_clock;
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x30   0xF8D1 0xC000      LDR      R12,[R1, #+0]
     65              SIM->SCGC4 |= SIM_SCGC4_UART0_MASK;
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \       0x38   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \       0x3C   0xF458 0x6880      ORRS     R8,R8,#0x400
   \       0x40   0xF8C1 0x8000      STR      R8,[R1, #+0]
     66              
     67              if(tx_pin == PTA2)
   \       0x44   0x0021             MOVS     R1,R4
   \       0x46   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x48   0x2902             CMP      R1,#+2
   \       0x4A   0xD106             BNE.N    ??UART_Init_2
     68                PORTA->PCR[2] = PORT_PCR_MUX(2); 
   \       0x4C   0xF44F 0x7100      MOV      R1,#+512
   \       0x50   0x.... 0x....      LDR.W    R8,??DataTable13_5  ;; 0x40049008
   \       0x54   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0x58   0xE010             B.N      ??UART_Init_3
     69              else if(tx_pin == PTA14)
   \                     ??UART_Init_2: (+1)
   \       0x5A   0x0021             MOVS     R1,R4
   \       0x5C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x5E   0x290E             CMP      R1,#+14
   \       0x60   0xD106             BNE.N    ??UART_Init_4
     70                PORTA->PCR[14] = PORT_PCR_MUX(3); 
   \       0x62   0xF44F 0x7140      MOV      R1,#+768
   \       0x66   0x.... 0x....      LDR.W    R8,??DataTable13_6  ;; 0x40049038
   \       0x6A   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0x6E   0xE005             B.N      ??UART_Init_3
     71              else
     72                PORTB->PCR[17] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_4: (+1)
   \       0x70   0xF44F 0x7140      MOV      R1,#+768
   \       0x74   0x.... 0x....      LDR.W    R8,??DataTable13_7  ;; 0x4004a044
   \       0x78   0xF8C8 0x1000      STR      R1,[R8, #+0]
     73              
     74              if(rx_pin == PTA1)
   \                     ??UART_Init_3: (+1)
   \       0x7C   0x0029             MOVS     R1,R5
   \       0x7E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x80   0x2901             CMP      R1,#+1
   \       0x82   0xD106             BNE.N    ??UART_Init_5
     75                PORTA->PCR[1] = PORT_PCR_MUX(2); 
   \       0x84   0xF44F 0x7100      MOV      R1,#+512
   \       0x88   0x.... 0x....      LDR.W    R8,??DataTable13_8  ;; 0x40049004
   \       0x8C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0x90   0xE10A             B.N      ??UART_Init_6
     76              else if(rx_pin == PTA15)
   \                     ??UART_Init_5: (+1)
   \       0x92   0x0029             MOVS     R1,R5
   \       0x94   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x96   0x290F             CMP      R1,#+15
   \       0x98   0xD106             BNE.N    ??UART_Init_7
     77                PORTA->PCR[15] = PORT_PCR_MUX(3); 
   \       0x9A   0xF44F 0x7140      MOV      R1,#+768
   \       0x9E   0x.... 0x....      LDR.W    R8,??DataTable13_9  ;; 0x4004903c
   \       0xA2   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0xA6   0xE0FF             B.N      ??UART_Init_6
     78              else
     79                PORTB->PCR[16] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_7: (+1)
   \       0xA8   0xF44F 0x7140      MOV      R1,#+768
   \       0xAC   0x.... 0x....      LDR.W    R8,??DataTable13_10  ;; 0x4004a040
   \       0xB0   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0xB4   0xE0F8             B.N      ??UART_Init_6
     80            }
     81            else
     82            {
     83              if (uartx == UART1)
   \                     ??UART_Init_1: (+1)
   \       0xB6   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \       0xBA   0x428B             CMP      R3,R1
   \       0xBC   0xD130             BNE.N    ??UART_Init_8
     84              {
     85                x = 1;
   \       0xBE   0xF05F 0x0E01      MOVS     LR,#+1
     86                sysclk = g_core_clock;
   \       0xC2   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0xC6   0xF8D1 0xC000      LDR      R12,[R1, #+0]
     87                SIM->SCGC4 |= SIM_SCGC4_UART1_MASK;
   \       0xCA   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \       0xCE   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \       0xD2   0xF458 0x6800      ORRS     R8,R8,#0x800
   \       0xD6   0xF8C1 0x8000      STR      R8,[R1, #+0]
     88                
     89                if(tx_pin == PTE0)   
   \       0xDA   0x0021             MOVS     R1,R4
   \       0xDC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xDE   0x297C             CMP      R1,#+124
   \       0xE0   0xD106             BNE.N    ??UART_Init_9
     90                  PORTE->PCR[0] = PORT_PCR_MUX(3); 
   \       0xE2   0xF44F 0x7140      MOV      R1,#+768
   \       0xE6   0x.... 0x....      LDR.W    R8,??DataTable13_12  ;; 0x4004d000
   \       0xEA   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \       0xEE   0xE005             B.N      ??UART_Init_10
     91                else
     92                  PORTC->PCR[4] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_9: (+1)
   \       0xF0   0xF44F 0x7140      MOV      R1,#+768
   \       0xF4   0x.... 0x....      LDR.W    R8,??DataTable13_13  ;; 0x4004b010
   \       0xF8   0xF8C8 0x1000      STR      R1,[R8, #+0]
     93                
     94                if(rx_pin == PTE1)
   \                     ??UART_Init_10: (+1)
   \       0xFC   0x0029             MOVS     R1,R5
   \       0xFE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x100   0x297D             CMP      R1,#+125
   \      0x102   0xD106             BNE.N    ??UART_Init_11
     95                  PORTE->PCR[1] = PORT_PCR_MUX(3); 
   \      0x104   0xF44F 0x7140      MOV      R1,#+768
   \      0x108   0x.... 0x....      LDR.W    R8,??DataTable13_14  ;; 0x4004d004
   \      0x10C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x110   0xE0CA             B.N      ??UART_Init_6
     96                else
     97                  PORTC->PCR[3] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_11: (+1)
   \      0x112   0xF44F 0x7140      MOV      R1,#+768
   \      0x116   0x.... 0x....      LDR.W    R8,??DataTable13_15  ;; 0x4004b00c
   \      0x11A   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x11E   0xE0C3             B.N      ??UART_Init_6
     98                
     99          
    100              }
    101              else
    102              {
    103                sysclk = g_bus_clock;
   \                     ??UART_Init_8: (+1)
   \      0x120   0x.... 0x....      LDR.W    R1,??DataTable13_16
   \      0x124   0xF8D1 0xC000      LDR      R12,[R1, #+0]
    104                if (uartx == UART2)
   \      0x128   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \      0x12C   0x428B             CMP      R3,R1
   \      0x12E   0xD114             BNE.N    ??UART_Init_12
    105                {
    106                  x = 2;
   \      0x130   0xF05F 0x0E02      MOVS     LR,#+2
    107                  SIM->SCGC4 |= SIM_SCGC4_UART2_MASK;
   \      0x134   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \      0x138   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \      0x13C   0xF458 0x5880      ORRS     R8,R8,#0x1000
   \      0x140   0xF8C1 0x8000      STR      R8,[R1, #+0]
    108                  
    109                  PORTD->PCR[3] = PORT_PCR_MUX(3); 
   \      0x144   0xF44F 0x7140      MOV      R1,#+768
   \      0x148   0x.... 0x....      LDR.W    R8,??DataTable13_18  ;; 0x4004c00c
   \      0x14C   0xF8C8 0x1000      STR      R1,[R8, #+0]
    110                  PORTD->PCR[2] = PORT_PCR_MUX(3);
   \      0x150   0x.... 0x....      LDR.W    R8,??DataTable13_19  ;; 0x4004c008
   \      0x154   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x158   0xE0A6             B.N      ??UART_Init_6
    111                }
    112                else
    113                {
    114                  if(uartx == UART3)
   \                     ??UART_Init_12: (+1)
   \      0x15A   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \      0x15E   0x428B             CMP      R3,R1
   \      0x160   0xD142             BNE.N    ??UART_Init_13
    115                  {
    116                    x = 3;
   \      0x162   0xF05F 0x0E03      MOVS     LR,#+3
    117                    SIM->SCGC4 |= SIM_SCGC4_UART3_MASK;
   \      0x166   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048034
   \      0x16A   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \      0x16E   0xF458 0x5800      ORRS     R8,R8,#0x2000
   \      0x172   0xF8C1 0x8000      STR      R8,[R1, #+0]
    118                    
    119                    if(tx_pin == PTE4)
   \      0x176   0x0021             MOVS     R1,R4
   \      0x178   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x17A   0x2980             CMP      R1,#+128
   \      0x17C   0xD106             BNE.N    ??UART_Init_14
    120                      PORTE->PCR[4] = PORT_PCR_MUX(3); 
   \      0x17E   0xF44F 0x7140      MOV      R1,#+768
   \      0x182   0x.... 0x....      LDR.W    R8,??DataTable13_21  ;; 0x4004d010
   \      0x186   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x18A   0xE010             B.N      ??UART_Init_15
    121                    else if(tx_pin == PTB11)
   \                     ??UART_Init_14: (+1)
   \      0x18C   0x0021             MOVS     R1,R4
   \      0x18E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x190   0x292B             CMP      R1,#+43
   \      0x192   0xD106             BNE.N    ??UART_Init_16
    122                      PORTB->PCR[11] = PORT_PCR_MUX(3); 
   \      0x194   0xF44F 0x7140      MOV      R1,#+768
   \      0x198   0x.... 0x....      LDR.W    R8,??DataTable13_22  ;; 0x4004a02c
   \      0x19C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x1A0   0xE005             B.N      ??UART_Init_15
    123                    else 
    124                      PORTC->PCR[17] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_16: (+1)
   \      0x1A2   0xF44F 0x7140      MOV      R1,#+768
   \      0x1A6   0x.... 0x....      LDR.W    R8,??DataTable13_23  ;; 0x4004b044
   \      0x1AA   0xF8C8 0x1000      STR      R1,[R8, #+0]
    125                    
    126                    if(rx_pin == PTE5)
   \                     ??UART_Init_15: (+1)
   \      0x1AE   0x0029             MOVS     R1,R5
   \      0x1B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x1B2   0x2981             CMP      R1,#+129
   \      0x1B4   0xD106             BNE.N    ??UART_Init_17
    127                      PORTE->PCR[5] = PORT_PCR_MUX(3); 
   \      0x1B6   0xF44F 0x7140      MOV      R1,#+768
   \      0x1BA   0x.... 0x....      LDR.W    R8,??DataTable13_24  ;; 0x4004d014
   \      0x1BE   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x1C2   0xE071             B.N      ??UART_Init_6
    128                    else if(rx_pin == PTB10)
   \                     ??UART_Init_17: (+1)
   \      0x1C4   0x0029             MOVS     R1,R5
   \      0x1C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x1C8   0x292A             CMP      R1,#+42
   \      0x1CA   0xD106             BNE.N    ??UART_Init_18
    129                      PORTB->PCR[10] = PORT_PCR_MUX(3); 
   \      0x1CC   0xF44F 0x7140      MOV      R1,#+768
   \      0x1D0   0x.... 0x....      LDR.W    R8,??DataTable13_25  ;; 0x4004a028
   \      0x1D4   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x1D8   0xE066             B.N      ??UART_Init_6
    130                    else
    131                      PORTC->PCR[16] = PORT_PCR_MUX(3);
   \                     ??UART_Init_18: (+1)
   \      0x1DA   0xF44F 0x7140      MOV      R1,#+768
   \      0x1DE   0x.... 0x....      LDR.W    R8,??DataTable13_26  ;; 0x4004b040
   \      0x1E2   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x1E6   0xE05F             B.N      ??UART_Init_6
    132                  }
    133                  else
    134                  {
    135                    if(uartx == UART4)
   \                     ??UART_Init_13: (+1)
   \      0x1E8   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \      0x1EC   0x428B             CMP      R3,R1
   \      0x1EE   0xD12C             BNE.N    ??UART_Init_19
    136                    {
    137                      x = 4;
   \      0x1F0   0xF05F 0x0E04      MOVS     LR,#+4
    138                      SIM->SCGC1 |= SIM_SCGC1_UART4_MASK;
   \      0x1F4   0x.... 0x....      LDR.W    R1,??DataTable13_28  ;; 0x40048028
   \      0x1F8   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \      0x1FC   0xF458 0x6880      ORRS     R8,R8,#0x400
   \      0x200   0xF8C1 0x8000      STR      R8,[R1, #+0]
    139                      
    140                      if(tx_pin == PTE24)
   \      0x204   0x0021             MOVS     R1,R4
   \      0x206   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x208   0x2994             CMP      R1,#+148
   \      0x20A   0xD106             BNE.N    ??UART_Init_20
    141                        PORTE->PCR[24] = PORT_PCR_MUX(3); 
   \      0x20C   0xF44F 0x7140      MOV      R1,#+768
   \      0x210   0x.... 0x....      LDR.W    R8,??DataTable13_29  ;; 0x4004d060
   \      0x214   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x218   0xE005             B.N      ??UART_Init_21
    142                      else
    143                        PORTC->PCR[15] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_20: (+1)
   \      0x21A   0xF44F 0x7140      MOV      R1,#+768
   \      0x21E   0x.... 0x....      LDR.W    R8,??DataTable13_30  ;; 0x4004b03c
   \      0x222   0xF8C8 0x1000      STR      R1,[R8, #+0]
    144                      
    145                      if(rx_pin == PTE25)
   \                     ??UART_Init_21: (+1)
   \      0x226   0x0029             MOVS     R1,R5
   \      0x228   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x22A   0x2995             CMP      R1,#+149
   \      0x22C   0xD106             BNE.N    ??UART_Init_22
    146                        PORTE->PCR[25] = PORT_PCR_MUX(3); 
   \      0x22E   0xF44F 0x7140      MOV      R1,#+768
   \      0x232   0x.... 0x....      LDR.W    R8,??DataTable13_31  ;; 0x4004d064
   \      0x236   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x23A   0xE035             B.N      ??UART_Init_6
    147                      else
    148                        PORTC->PCR[14] = PORT_PCR_MUX(3);
   \                     ??UART_Init_22: (+1)
   \      0x23C   0xF44F 0x7140      MOV      R1,#+768
   \      0x240   0x.... 0x....      LDR.W    R8,??DataTable13_32  ;; 0x4004b038
   \      0x244   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x248   0xE02E             B.N      ??UART_Init_6
    149                    }
    150                    else
    151                    {
    152                      x = 5;
   \                     ??UART_Init_19: (+1)
   \      0x24A   0xF05F 0x0E05      MOVS     LR,#+5
    153                      uartx = UART5;
   \      0x24E   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \      0x252   0x000B             MOVS     R3,R1
    154                      SIM->SCGC1 |= SIM_SCGC1_UART5_MASK;
   \      0x254   0x.... 0x....      LDR.W    R1,??DataTable13_28  ;; 0x40048028
   \      0x258   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \      0x25C   0xF458 0x6800      ORRS     R8,R8,#0x800
   \      0x260   0xF8C1 0x8000      STR      R8,[R1, #+0]
    155                      
    156                      if(tx_pin == PTD9)
   \      0x264   0x0021             MOVS     R1,R4
   \      0x266   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x268   0x2965             CMP      R1,#+101
   \      0x26A   0xD106             BNE.N    ??UART_Init_23
    157                        PORTD->PCR[9] = PORT_PCR_MUX(3); 
   \      0x26C   0xF44F 0x7140      MOV      R1,#+768
   \      0x270   0x.... 0x....      LDR.W    R8,??DataTable13_34  ;; 0x4004c024
   \      0x274   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x278   0xE005             B.N      ??UART_Init_24
    158                      else
    159                        PORTE->PCR[8] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_23: (+1)
   \      0x27A   0xF44F 0x7140      MOV      R1,#+768
   \      0x27E   0x.... 0x....      LDR.W    R8,??DataTable13_35  ;; 0x4004d020
   \      0x282   0xF8C8 0x1000      STR      R1,[R8, #+0]
    160                      
    161                      if(rx_pin == PTD8)
   \                     ??UART_Init_24: (+1)
   \      0x286   0x0029             MOVS     R1,R5
   \      0x288   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x28A   0x2964             CMP      R1,#+100
   \      0x28C   0xD106             BNE.N    ??UART_Init_25
    162                        PORTD->PCR[8] = PORT_PCR_MUX(3); 
   \      0x28E   0xF44F 0x7140      MOV      R1,#+768
   \      0x292   0x.... 0x....      LDR.W    R8,??DataTable13_36  ;; 0x4004c020
   \      0x296   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x29A   0xE005             B.N      ??UART_Init_6
    163                      else
    164                        PORTE->PCR[9] = PORT_PCR_MUX(3); 
   \                     ??UART_Init_25: (+1)
   \      0x29C   0xF44F 0x7140      MOV      R1,#+768
   \      0x2A0   0x.... 0x....      LDR.W    R8,??DataTable13_37  ;; 0x4004d024
   \      0x2A4   0xF8C8 0x1000      STR      R1,[R8, #+0]
    165                    }
    166                  }
    167                }
    168              }
    169            }
    170            
    171            //在配置好其他寄存器前，先关闭发送器和接收器
    172            uartx->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
   \                     ??UART_Init_6: (+1)
   \      0x2A8   0x78D9             LDRB     R1,[R3, #+3]
   \      0x2AA   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \      0x2AE   0x70D9             STRB     R1,[R3, #+3]
    173            
    174            //配置UART为 8位, 无奇偶校验 */
    175            uartx->C1 = 0;	
   \      0x2B0   0x2100             MOVS     R1,#+0
   \      0x2B2   0x7099             STRB     R1,[R3, #+2]
    176            
    177            //计算波特率
    178            sbr = (uint16)((sysclk)/(baud * 16));
   \      0x2B4   0x0101             LSLS     R1,R0,#+4
   \      0x2B6   0xFBBC 0xF8F1      UDIV     R8,R12,R1
    179            
    180            //保存UARTx_BDH寄存器中除了SBR的值
    181            temp = uartx->BDH & ~(UART_BDH_SBR(0x1F));
   \      0x2BA   0x7819             LDRB     R1,[R3, #+0]
   \      0x2BC   0xF011 0x01E0      ANDS     R1,R1,#0xE0
    182            
    183            uartx->BDH = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \      0x2C0   0xF3C8 0x2904      UBFX     R9,R8,#+8,#+5
   \      0x2C4   0xEA59 0x0901      ORRS     R9,R9,R1
   \      0x2C8   0xF883 0x9000      STRB     R9,[R3, #+0]
    184            uartx->BDL = (uint8)(sbr & UART_BDL_SBR_MASK);
   \      0x2CC   0xF883 0x8001      STRB     R8,[R3, #+1]
    185            
    186            //配置波特率的微调分数
    187            brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
   \      0x2D0   0xEA5F 0x194C      LSLS     R9,R12,#+5
   \      0x2D4   0xEA5F 0x1A00      LSLS     R10,R0,#+4
   \      0x2D8   0xFBB9 0xF9FA      UDIV     R9,R9,R10
   \      0x2DC   0x46C2             MOV      R10,R8
   \      0x2DE   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \      0x2E2   0xEBB9 0x194A      SUBS     R9,R9,R10, LSL #+5
    188            
    189            //保存UARTx_C4寄存器中除了BRFA的值
    190            temp = uartx->C4 & ~(UART_C4_BRFA(0x1F));
   \      0x2E6   0xF893 0xA00A      LDRB     R10,[R3, #+10]
   \      0x2EA   0xF01A 0x0AE0      ANDS     R10,R10,#0xE0
    191            
    192            uartx->C4 = temp |  UART_C4_BRFA(brfa);    
   \      0x2EE   0xF019 0x0B1F      ANDS     R11,R9,#0x1F
   \      0x2F2   0xEA5B 0x0B0A      ORRS     R11,R11,R10
   \      0x2F6   0xF883 0xB00A      STRB     R11,[R3, #+10]
    193            
    194            //配置UART接收DMA方式
    195            if( uart_init_structure.UART_RxDMAEnable == TRUE 
    196              && uart_init_structure.UART_RxIntEnable == TRUE )
   \      0x2FA   0xF89D 0xB031      LDRB     R11,[SP, #+49]
   \      0x2FE   0xF1BB 0x0F01      CMP      R11,#+1
   \      0x302   0xD10C             BNE.N    ??UART_Init_26
   \      0x304   0xF89D 0x102E      LDRB     R1,[SP, #+46]
   \      0x308   0x2901             CMP      R1,#+1
   \      0x30A   0xD108             BNE.N    ??UART_Init_26
    197            {
    198              //使能接收中断或者DMA
    199              uartx->C2 |= UART_C2_RIE_MASK;
   \      0x30C   0x78D9             LDRB     R1,[R3, #+3]
   \      0x30E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x312   0x70D9             STRB     R1,[R3, #+3]
    200              //使能接收DMA
    201              uartx->C5 |= UART_C5_RDMAS_MASK;
   \      0x314   0x7AD9             LDRB     R1,[R3, #+11]
   \      0x316   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x31A   0x72D9             STRB     R1,[R3, #+11]
   \      0x31C   0xE01A             B.N      ??UART_Init_27
    202            }//配置UART接收中断方式
    203            else if(uart_init_structure.UART_RxIntEnable == TRUE 
    204                  && rx_isr != NULL)
   \                     ??UART_Init_26: (+1)
   \      0x31E   0xF89D 0x102E      LDRB     R1,[SP, #+46]
   \      0x322   0x2901             CMP      R1,#+1
   \      0x324   0xD10E             BNE.N    ??UART_Init_28
   \      0x326   0x0031             MOVS     R1,R6
   \      0x328   0x2900             CMP      R1,#+0
   \      0x32A   0xD00B             BEQ.N    ??UART_Init_28
    205            {
    206              //使能接收中断
    207              uartx->C2 |= UART_C2_RIE_MASK; 
   \      0x32C   0x78D9             LDRB     R1,[R3, #+3]
   \      0x32E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x332   0x70D9             STRB     R1,[R3, #+3]
    208              UART_R_ISR[x] = rx_isr;
   \      0x334   0x.... 0x....      LDR.W    R1,??DataTable13_38
   \      0x338   0x46F3             MOV      R11,LR
   \      0x33A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \      0x33E   0xF841 0x602B      STR      R6,[R1, R11, LSL #+2]
   \      0x342   0xE007             B.N      ??UART_Init_27
    209            } 
    210            else
    211            {
    212              uartx->C2 &= ~(UART_C2_RIE_MASK); 
   \                     ??UART_Init_28: (+1)
   \      0x344   0x78D9             LDRB     R1,[R3, #+3]
   \      0x346   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \      0x34A   0x70D9             STRB     R1,[R3, #+3]
    213              uartx->C5 &= ~(UART_C5_RDMAS_MASK);
   \      0x34C   0x7AD9             LDRB     R1,[R3, #+11]
   \      0x34E   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \      0x352   0x72D9             STRB     R1,[R3, #+11]
    214            }
    215            
    216            //配置UART接收DMA方式
    217            if( uart_init_structure.UART_TxDMAEnable == TRUE 
    218              && uart_init_structure.UART_TxIntEnable == TRUE )
   \                     ??UART_Init_27: (+1)
   \      0x354   0xF89D 0x1030      LDRB     R1,[SP, #+48]
   \      0x358   0x2901             CMP      R1,#+1
   \      0x35A   0xD10C             BNE.N    ??UART_Init_29
   \      0x35C   0xF89D 0x102F      LDRB     R1,[SP, #+47]
   \      0x360   0x2901             CMP      R1,#+1
   \      0x362   0xD108             BNE.N    ??UART_Init_29
    219            {
    220              //使能发送中断或者DMA
    221              uartx->C2 |= UART_C2_TIE_MASK;
   \      0x364   0x78D9             LDRB     R1,[R3, #+3]
   \      0x366   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x36A   0x70D9             STRB     R1,[R3, #+3]
    222              //使能接收DMA
    223              uartx->C5 |= UART_C5_TDMAS_MASK;
   \      0x36C   0x7AD9             LDRB     R1,[R3, #+11]
   \      0x36E   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x372   0x72D9             STRB     R1,[R3, #+11]
   \      0x374   0xE01A             B.N      ??UART_Init_30
    224            }//配置UART发送中断方式
    225            else if(uart_init_structure.UART_TxIntEnable == TRUE 
    226                  && tx_isr != NULL)
   \                     ??UART_Init_29: (+1)
   \      0x376   0xF89D 0x102F      LDRB     R1,[SP, #+47]
   \      0x37A   0x2901             CMP      R1,#+1
   \      0x37C   0xD10E             BNE.N    ??UART_Init_31
   \      0x37E   0x0039             MOVS     R1,R7
   \      0x380   0x2900             CMP      R1,#+0
   \      0x382   0xD00B             BEQ.N    ??UART_Init_31
    227            {
    228              //使能发送中断
    229              uartx->C2 |= UART_C2_TIE_MASK; 
   \      0x384   0x78D9             LDRB     R1,[R3, #+3]
   \      0x386   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x38A   0x70D9             STRB     R1,[R3, #+3]
    230              UART_T_ISR[x] = tx_isr;
   \      0x38C   0x.... 0x....      LDR.W    R1,??DataTable13_39
   \      0x390   0x46F3             MOV      R11,LR
   \      0x392   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \      0x396   0xF841 0x702B      STR      R7,[R1, R11, LSL #+2]
   \      0x39A   0xE007             B.N      ??UART_Init_30
    231            } 
    232            else
    233            {
    234              uartx->C2 &= ~(UART_C2_TIE_MASK);
   \                     ??UART_Init_31: (+1)
   \      0x39C   0x78D9             LDRB     R1,[R3, #+3]
   \      0x39E   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \      0x3A2   0x70D9             STRB     R1,[R3, #+3]
    235              uartx->C5 &= ~(UART_C5_TDMAS_MASK);
   \      0x3A4   0x7AD9             LDRB     R1,[R3, #+11]
   \      0x3A6   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \      0x3AA   0x72D9             STRB     R1,[R3, #+11]
    236            }
    237            
    238            //配置UART FIFO 功能
    239            if( (uartx->C2 & UART_C2_RE_MASK) == 0 
    240               && uart_init_structure.RxFIFO.FIFO_Enable == TRUE)
   \                     ??UART_Init_30: (+1)
   \      0x3AC   0x78D9             LDRB     R1,[R3, #+3]
   \      0x3AE   0x0749             LSLS     R1,R1,#+29
   \      0x3B0   0xD429             BMI.N    ??UART_Init_32
   \      0x3B2   0xF89D 0x1035      LDRB     R1,[SP, #+53]
   \      0x3B6   0x2901             CMP      R1,#+1
   \      0x3B8   0xD125             BNE.N    ??UART_Init_32
    241            {
    242              //使能 UART 接收FIFO
    243              uartx->PFIFO |= UART_PFIFO_RXFE_MASK;
   \      0x3BA   0x7C19             LDRB     R1,[R3, #+16]
   \      0x3BC   0xF051 0x0108      ORRS     R1,R1,#0x8
   \      0x3C0   0x7419             STRB     R1,[R3, #+16]
    244              
    245              if(uart_init_structure.RxFIFO.FIFO_BufFlow_IntEnable == TRUE)
   \      0x3C2   0xF89D 0x1036      LDRB     R1,[SP, #+54]
   \      0x3C6   0x2901             CMP      R1,#+1
   \      0x3C8   0xD103             BNE.N    ??UART_Init_33
    246              {
    247                uartx->CFIFO |= UART_CFIFO_RXUFE_MASK;
   \      0x3CA   0x7C59             LDRB     R1,[R3, #+17]
   \      0x3CC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x3D0   0x7459             STRB     R1,[R3, #+17]
    248              }
    249              //  UART1->PFIFO = 0x99;//TX and RX
    250              //  UART1->CFIFO |= 0xC0;
    251              //读取 FIFO buffer 深度
    252              len = (uint8)( uartx->PFIFO & UART_PFIFO_RXFIFOSIZE_MASK ) >> UART_PFIFO_RXFIFOSIZE_SHIFT;
   \                     ??UART_Init_33: (+1)
   \      0x3D2   0xF893 0xB010      LDRB     R11,[R3, #+16]
   \      0x3D6   0xF01B 0x0B07      ANDS     R11,R11,#0x7
    253              len = len > 0 ? 1 << (len + 1) : 1;
   \      0x3DA   0x4659             MOV      R1,R11
   \      0x3DC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x3DE   0x2900             CMP      R1,#+0
   \      0x3E0   0xD005             BEQ.N    ??UART_Init_34
   \      0x3E2   0x2201             MOVS     R2,#+1
   \      0x3E4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x3E8   0xFA12 0xF20B      LSLS     R2,R2,R11
   \      0x3EC   0xE000             B.N      ??UART_Init_35
   \                     ??UART_Init_34: (+1)
   \      0x3EE   0x2201             MOVS     R2,#+1
    254              //如果Rx FIFO buffer中的DataWords 大于等于 UART_FIFOWaterMark
    255              //将产生中断或者DMA信号，取决C2_RIE和C5_RDMAS的状态
    256              if( uart_init_structure.RxFIFO.FIFO_WaterMark > len )
   \                     ??UART_Init_35: (+1)
   \      0x3F0   0x0011             MOVS     R1,R2
   \      0x3F2   0xF89D 0xB037      LDRB     R11,[SP, #+55]
   \      0x3F6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x3F8   0x4559             CMP      R1,R11
   \      0x3FA   0xD201             BCS.N    ??UART_Init_36
    257              {
    258                uartx->RWFIFO = UART_RWFIFO_RXWATER(len);
   \      0x3FC   0x755A             STRB     R2,[R3, #+21]
   \      0x3FE   0xE002             B.N      ??UART_Init_32
    259              }
    260              else
    261              {
    262                uartx->RWFIFO = UART_RWFIFO_RXWATER(uart_init_structure.RxFIFO.FIFO_WaterMark);
   \                     ??UART_Init_36: (+1)
   \      0x400   0xF89D 0x1037      LDRB     R1,[SP, #+55]
   \      0x404   0x7559             STRB     R1,[R3, #+21]
    263              }  
    264            }
    265            
    266            if( (uartx->C2 & UART_C2_TE_MASK) == 0 
    267               && uart_init_structure.TxFIFO.FIFO_Enable == TRUE)
   \                     ??UART_Init_32: (+1)
   \      0x406   0x78D9             LDRB     R1,[R3, #+3]
   \      0x408   0x0709             LSLS     R1,R1,#+28
   \      0x40A   0xD428             BMI.N    ??UART_Init_37
   \      0x40C   0xF89D 0x1032      LDRB     R1,[SP, #+50]
   \      0x410   0x2901             CMP      R1,#+1
   \      0x412   0xD124             BNE.N    ??UART_Init_37
    268            {
    269              //使能 UART 发送FIFO
    270              uartx->PFIFO |= UART_PFIFO_TXFE_MASK;
   \      0x414   0x7C19             LDRB     R1,[R3, #+16]
   \      0x416   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x41A   0x7419             STRB     R1,[R3, #+16]
    271              
    272              if(uart_init_structure.TxFIFO.FIFO_BufFlow_IntEnable == TRUE)
   \      0x41C   0xF89D 0x1033      LDRB     R1,[SP, #+51]
   \      0x420   0x2901             CMP      R1,#+1
   \      0x422   0xD103             BNE.N    ??UART_Init_38
    273              {
    274                uartx->CFIFO |= UART_CFIFO_TXOFE_MASK;
   \      0x424   0x7C59             LDRB     R1,[R3, #+17]
   \      0x426   0xF051 0x0102      ORRS     R1,R1,#0x2
   \      0x42A   0x7459             STRB     R1,[R3, #+17]
    275              }
    276              
    277              //读取 FIFO buffer 深度
    278              len = (uint8)( uartx->PFIFO & UART_PFIFO_TXFIFOSIZE_MASK ) >> UART_PFIFO_TXFIFOSIZE_SHIFT;
   \                     ??UART_Init_38: (+1)
   \      0x42C   0x7C19             LDRB     R1,[R3, #+16]
   \      0x42E   0xF3C1 0x1B02      UBFX     R11,R1,#+4,#+3
    279              len = len > 0 ? 1 << (len + 1) : 1;
   \      0x432   0x4659             MOV      R1,R11
   \      0x434   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x436   0x2900             CMP      R1,#+0
   \      0x438   0xD005             BEQ.N    ??UART_Init_39
   \      0x43A   0x2201             MOVS     R2,#+1
   \      0x43C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x440   0xFA12 0xF20B      LSLS     R2,R2,R11
   \      0x444   0xE000             B.N      ??UART_Init_40
   \                     ??UART_Init_39: (+1)
   \      0x446   0x2201             MOVS     R2,#+1
    280              //如果Tx FIFO buffer中的DataWords 小于等于 UART_FIFOWaterMark
    281              //将产生中断或者DMA信号，取决C2_TIE和C5_TDMAS的状态
    282              if( uart_init_structure.TxFIFO.FIFO_WaterMark > len )
   \                     ??UART_Init_40: (+1)
   \      0x448   0x0011             MOVS     R1,R2
   \      0x44A   0xF89D 0xB034      LDRB     R11,[SP, #+52]
   \      0x44E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x450   0x4559             CMP      R1,R11
   \      0x452   0xD201             BCS.N    ??UART_Init_41
    283              {
    284                uartx->TWFIFO = UART_TWFIFO_TXWATER(len);
   \      0x454   0x74DA             STRB     R2,[R3, #+19]
   \      0x456   0xE002             B.N      ??UART_Init_37
    285              }
    286              else
    287              {
    288                uartx->TWFIFO = UART_TWFIFO_TXWATER(uart_init_structure.TxFIFO.FIFO_WaterMark);
   \                     ??UART_Init_41: (+1)
   \      0x458   0xF89D 0x1034      LDRB     R1,[SP, #+52]
   \      0x45C   0x74D9             STRB     R1,[R3, #+19]
    289              }
    290            }
    291            //使能 UART 发送器
    292            uartx->C2 |= UART_C2_TE_MASK | UART_C2_RE_MASK;  
   \                     ??UART_Init_37: (+1)
   \      0x45E   0x78D9             LDRB     R1,[R3, #+3]
   \      0x460   0xF051 0x010C      ORRS     R1,R1,#0xC
   \      0x464   0x70D9             STRB     R1,[R3, #+3]
    293          }
   \      0x466   0xE8BD 0x0FF0      POP      {R4-R11}
   \      0x46A   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    294          
    295          
    296          /*
    297           * UART_RxFIFO_Flush
    298           * 清空UART Rx FIFO
    299           * 
    300           * 参数:
    301           *    uartx--UART模块号
    302           *      |__UART0          --UART0
    303           *      |__UART1          --UART1
    304           *      |__UART2          --UART2
    305           *      |__UART3          --UART3
    306           *      |__UART4          --UART4
    307           *      |__UART5          --UART5
    308           *
    309           */

   \                                 In section .text, align 2, keep-with-next
    310          void UART_RxFIFO_Flush(UART_Type *uartx)
    311          {
    312            //清空接收 FIFO
    313            if( uartx->PFIFO & UART_PFIFO_RXFE_MASK )
   \                     UART_RxFIFO_Flush: (+1)
   \        0x0   0x7C01             LDRB     R1,[R0, #+16]
   \        0x2   0x0709             LSLS     R1,R1,#+28
   \        0x4   0xD503             BPL.N    ??UART_RxFIFO_Flush_0
    314            {
    315              uartx->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \        0x6   0x7C41             LDRB     R1,[R0, #+17]
   \        0x8   0xF051 0x0140      ORRS     R1,R1,#0x40
   \        0xC   0x7441             STRB     R1,[R0, #+17]
    316            }
    317          }
   \                     ??UART_RxFIFO_Flush_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    318          
    319          /*
    320           * UART_TxFIFO_Flush
    321           * 清空UART Tx FIFO
    322           * 
    323           * 参数:
    324           *    uartx--UART模块号
    325           *      |__UART0          --UART0
    326           *      |__UART1          --UART1
    327           *      |__UART2          --UART2
    328           *      |__UART3          --UART3
    329           *      |__UART4          --UART4
    330           *      |__UART5          --UART5
    331           *
    332           */

   \                                 In section .text, align 2, keep-with-next
    333          void UART_TxFIFO_Flush(UART_Type *uartx)
    334          {
    335            //清空发送 FIFO
    336            if( uartx->PFIFO & UART_PFIFO_TXFE_MASK )
   \                     UART_TxFIFO_Flush: (+1)
   \        0x0   0x7C01             LDRB     R1,[R0, #+16]
   \        0x2   0x0609             LSLS     R1,R1,#+24
   \        0x4   0xD503             BPL.N    ??UART_TxFIFO_Flush_0
    337            {
    338              uartx->CFIFO |= UART_CFIFO_TXFLUSH_MASK;
   \        0x6   0x7C41             LDRB     R1,[R0, #+17]
   \        0x8   0xF051 0x0180      ORRS     R1,R1,#0x80
   \        0xC   0x7441             STRB     R1,[R0, #+17]
    339            }
    340          }
   \                     ??UART_TxFIFO_Flush_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    341          
    342          /*
    343           * UART_GetChar
    344           * 串口查询方式读取一个字节
    345           * 
    346           * 参数:
    347           *    uartx--UART模块号
    348           *      |__UART0          --UART0
    349           *      |__UART1          --UART1
    350           *      |__UART2          --UART2
    351           *      |__UART3          --UART3
    352           *      |__UART4          --UART4
    353           *      |__UART5          --UART5
    354           *
    355           * 输出:
    356           *    串口接收的1个字节
    357           *
    358           */

   \                                 In section .text, align 2, keep-with-next
    359          char UART_GetChar(UART_Type *uartx)
    360          {
    361            //等待数据接收
    362            while (!(uartx->S1 & UART_S1_RDRF_MASK));
   \                     UART_GetChar: (+1)
   \                     ??UART_GetChar_0: (+1)
   \        0x0   0x7901             LDRB     R1,[R0, #+4]
   \        0x2   0x0689             LSLS     R1,R1,#+26
   \        0x4   0xD5FC             BPL.N    ??UART_GetChar_0
    363            
    364            //返回接收的1个字节数据
    365            return uartx->D;
   \        0x6   0x79C0             LDRB     R0,[R0, #+7]
   \        0x8   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /********************************************************************/
    369          /*
    370           * UART_GetChar_Present
    371           * 检查是否接收到字符
    372           * 
    373           * 参数:
    374           *    uartx--UART模块号
    375           *      |__UART0          --UART0
    376           *      |__UART1          --UART1
    377           *      |__UART2          --UART2
    378           *      |__UART3          --UART3
    379           *      |__UART4          --UART4
    380           *      |__UART5          --UART5
    381           *
    382           * 输出:
    383           *  0       没有接收到字符
    384           *  1       已经接收到字符
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          int32 UART_GetChar_Present(UART_Type *uartx)
    387          {
    388              return (uartx->S1 & UART_S1_RDRF_MASK);
   \                     UART_GetChar_Present: (+1)
   \        0x0   0x7900             LDRB     R0,[R0, #+4]
   \        0x2   0xF010 0x0020      ANDS     R0,R0,#0x20
   \        0x6   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /*
    392           * UART_PutChar
    393           * 串口查询方式发送一个字节
    394           * 
    395           * 参数:
    396           *    uartx--UART模块号
    397           *      |__UART0          --UART0
    398           *      |__UART1          --UART1
    399           *      |__UART2          --UART2
    400           *      |__UART3          --UART3
    401           *      |__UART4          --UART4
    402           *      |__UART5          --UART5
    403           *    ch--待发送的1个字节
    404           *
    405           * 输出:
    406           *    无
    407           *
    408           */

   \                                 In section .text, align 2, keep-with-next
    409          void UART_PutChar(UART_Type *uartx, char ch)
    410          {
    411            //等待FIFO准备就绪
    412            while(!(uartx->S1 & UART_S1_TDRE_MASK));
   \                     UART_PutChar: (+1)
   \                     ??UART_PutChar_0: (+1)
   \        0x0   0x7902             LDRB     R2,[R0, #+4]
   \        0x2   0x0612             LSLS     R2,R2,#+24
   \        0x4   0xD5FC             BPL.N    ??UART_PutChar_0
    413            
    414            //将要发送的1个字节发给UART数据寄存器
    415            uartx->D = (uint8)ch;
   \        0x6   0x71C1             STRB     R1,[R0, #+7]
    416          }
   \        0x8   0x4770             BX       LR               ;; return
    417          
    418          
    419          /*
    420           * UART_PutCharArr
    421           * 串口查询方式发送字节型数组
    422           * 
    423           * 参数:
    424           *    uartx--UART模块号
    425           *      |__UART0          --UART0
    426           *      |__UART1          --UART1
    427           *      |__UART2          --UART2
    428           *      |__UART3          --UART3
    429           *      |__UART4          --UART4
    430           *      |__UART5          --UART5
    431           *    *ch--待发送的字节数组头地址
    432           *    len--字节数组长度
    433           *
    434           * 输出:
    435           *    无
    436           *
    437           */

   \                                 In section .text, align 2, keep-with-next
    438          void UART_PutCharArr(UART_Type *uartx, char *ch, int32 len)
    439          {
   \                     UART_PutCharArr: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    440            while(len--)
   \                     ??UART_PutCharArr_0: (+1)
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0x1E46             SUBS     R6,R0,#+1
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD005             BEQ.N    ??UART_PutCharArr_1
    441            {
    442              UART_PutChar(uartx, *(ch++));
   \       0x10   0x7829             LDRB     R1,[R5, #+0]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       UART_PutChar
   \       0x18   0x1C6D             ADDS     R5,R5,#+1
   \       0x1A   0xE7F5             B.N      ??UART_PutCharArr_0
    443            }
    444          }
   \                     ??UART_PutCharArr_1: (+1)
   \       0x1C   0xBD70             POP      {R4-R6,PC}       ;; return
    445          
    446          /*
    447           * UART_EnableIrq
    448           * 使能串口数据接收中断
    449           * 
    450           * 参数:
    451           *    uart_init_structure--UART初始化结构体，
    452           *                        具体定义见UART_InitTypeDef
    453           *
    454           * 输出:
    455           *    无
    456           *
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          void UART_EnableIrq(UART_InitTypeDef uart_init_structure)
    459          {
   \                     UART_EnableIrq: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
    460            if(uart_init_structure.UART_Uartx == UART0)
   \        0x4   0x9802             LDR      R0,[SP, #+8]
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \        0xA   0x4288             CMP      R0,R1
   \        0xC   0xD106             BNE.N    ??UART_EnableIrq_0
    461            {
    462              enable_irq(UART0_RX_TX_IRQn);
   \        0xE   0x202D             MOVS     R0,#+45
   \       0x10   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    463              enable_irq(UART0_ERR_IRQn);
   \       0x14   0x202E             MOVS     R0,#+46
   \       0x16   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \       0x1A   0xE03A             B.N      ??UART_EnableIrq_1
    464            }
    465            else if(uart_init_structure.UART_Uartx == UART1)
   \                     ??UART_EnableIrq_0: (+1)
   \       0x1C   0x9802             LDR      R0,[SP, #+8]
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD106             BNE.N    ??UART_EnableIrq_2
    466            {
    467              enable_irq(UART1_RX_TX_IRQn);
   \       0x26   0x202F             MOVS     R0,#+47
   \       0x28   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    468              enable_irq(UART1_ERR_IRQn);
   \       0x2C   0x2030             MOVS     R0,#+48
   \       0x2E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \       0x32   0xE02E             B.N      ??UART_EnableIrq_1
    469            }
    470            else if(uart_init_structure.UART_Uartx == UART2)
   \                     ??UART_EnableIrq_2: (+1)
   \       0x34   0x9802             LDR      R0,[SP, #+8]
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD106             BNE.N    ??UART_EnableIrq_3
    471            {
    472              enable_irq(UART2_RX_TX_IRQn);
   \       0x3E   0x2031             MOVS     R0,#+49
   \       0x40   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    473              enable_irq(UART2_ERR_IRQn);
   \       0x44   0x2032             MOVS     R0,#+50
   \       0x46   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \       0x4A   0xE022             B.N      ??UART_EnableIrq_1
    474            }
    475            else if(uart_init_structure.UART_Uartx == UART3)
   \                     ??UART_EnableIrq_3: (+1)
   \       0x4C   0x9802             LDR      R0,[SP, #+8]
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD106             BNE.N    ??UART_EnableIrq_4
    476            {
    477              enable_irq(UART3_RX_TX_IRQn);
   \       0x56   0x2033             MOVS     R0,#+51
   \       0x58   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    478              enable_irq(UART3_ERR_IRQn);
   \       0x5C   0x2034             MOVS     R0,#+52
   \       0x5E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \       0x62   0xE016             B.N      ??UART_EnableIrq_1
    479            }
    480            else if(uart_init_structure.UART_Uartx == UART4)
   \                     ??UART_EnableIrq_4: (+1)
   \       0x64   0x9802             LDR      R0,[SP, #+8]
   \       0x66   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xD106             BNE.N    ??UART_EnableIrq_5
    481            {
    482              enable_irq(UART4_RX_TX_IRQn);
   \       0x6E   0x2035             MOVS     R0,#+53
   \       0x70   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    483              enable_irq(UART4_ERR_IRQn);
   \       0x74   0x2036             MOVS     R0,#+54
   \       0x76   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
   \       0x7A   0xE00A             B.N      ??UART_EnableIrq_1
    484            }
    485            else if(uart_init_structure.UART_Uartx == UART5)
   \                     ??UART_EnableIrq_5: (+1)
   \       0x7C   0x9802             LDR      R0,[SP, #+8]
   \       0x7E   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \       0x82   0x4288             CMP      R0,R1
   \       0x84   0xD105             BNE.N    ??UART_EnableIrq_1
    486            {
    487              enable_irq(UART5_RX_TX_IRQn);
   \       0x86   0x2037             MOVS     R0,#+55
   \       0x88   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    488              enable_irq(UART5_ERR_IRQn);
   \       0x8C   0x2038             MOVS     R0,#+56
   \       0x8E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd716__NVIC_EnableIRQE4IRQn
    489            }
    490          }
   \                     ??UART_EnableIrq_1: (+1)
   \       0x92   0xBC01             POP      {R0}
   \       0x94   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    491          
    492          /*
    493           * UART_DisableIrq
    494           * 禁用串口数据接收中断
    495           * 
    496           * 参数:
    497           *    uart_init_structure--UART初始化结构体，
    498           *                        具体定义见UART_InitTypeDef
    499           *
    500           * 输出:
    501           *    无
    502           *
    503           */

   \                                 In section .text, align 2, keep-with-next
    504          void UART_DisableIrq(UART_InitTypeDef uart_init_structure)
    505          {
   \                     UART_DisableIrq: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
    506            //根据中断请求号使能相应中断
    507            if(uart_init_structure.UART_Uartx == UART0)
   \        0x4   0x9802             LDR      R0,[SP, #+8]
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4006a000
   \        0xA   0x4288             CMP      R0,R1
   \        0xC   0xD106             BNE.N    ??UART_DisableIrq_0
    508            {
    509              disable_irq(UART0_RX_TX_IRQn);
   \        0xE   0x202D             MOVS     R0,#+45
   \       0x10   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    510              disable_irq(UART0_ERR_IRQn);
   \       0x14   0x202E             MOVS     R0,#+46
   \       0x16   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \       0x1A   0xE03A             B.N      ??UART_DisableIrq_1
    511            }
    512            else if(uart_init_structure.UART_Uartx == UART1)
   \                     ??UART_DisableIrq_0: (+1)
   \       0x1C   0x9802             LDR      R0,[SP, #+8]
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x4006b000
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD106             BNE.N    ??UART_DisableIrq_2
    513            {
    514              disable_irq(UART1_RX_TX_IRQn);
   \       0x26   0x202F             MOVS     R0,#+47
   \       0x28   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    515              disable_irq(UART1_ERR_IRQn);
   \       0x2C   0x2030             MOVS     R0,#+48
   \       0x2E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \       0x32   0xE02E             B.N      ??UART_DisableIrq_1
    516            }
    517            else if(uart_init_structure.UART_Uartx == UART2)
   \                     ??UART_DisableIrq_2: (+1)
   \       0x34   0x9802             LDR      R0,[SP, #+8]
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable13_17  ;; 0x4006c000
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD106             BNE.N    ??UART_DisableIrq_3
    518            {
    519              disable_irq(UART2_RX_TX_IRQn);
   \       0x3E   0x2031             MOVS     R0,#+49
   \       0x40   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    520              disable_irq(UART2_ERR_IRQn);
   \       0x44   0x2032             MOVS     R0,#+50
   \       0x46   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \       0x4A   0xE022             B.N      ??UART_DisableIrq_1
    521            }
    522            else if(uart_init_structure.UART_Uartx == UART3)
   \                     ??UART_DisableIrq_3: (+1)
   \       0x4C   0x9802             LDR      R0,[SP, #+8]
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable13_20  ;; 0x4006d000
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD106             BNE.N    ??UART_DisableIrq_4
    523            {
    524              disable_irq(UART3_RX_TX_IRQn);
   \       0x56   0x2033             MOVS     R0,#+51
   \       0x58   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    525              disable_irq(UART3_ERR_IRQn);
   \       0x5C   0x2034             MOVS     R0,#+52
   \       0x5E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \       0x62   0xE016             B.N      ??UART_DisableIrq_1
    526            }
    527            else if(uart_init_structure.UART_Uartx == UART4)
   \                     ??UART_DisableIrq_4: (+1)
   \       0x64   0x9802             LDR      R0,[SP, #+8]
   \       0x66   0x.... 0x....      LDR.W    R1,??DataTable13_27  ;; 0x400ea000
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xD106             BNE.N    ??UART_DisableIrq_5
    528            {
    529              disable_irq(UART4_RX_TX_IRQn);
   \       0x6E   0x2035             MOVS     R0,#+53
   \       0x70   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    530              disable_irq(UART4_ERR_IRQn);
   \       0x74   0x2036             MOVS     R0,#+54
   \       0x76   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
   \       0x7A   0xE00A             B.N      ??UART_DisableIrq_1
    531            }
    532            else if(uart_init_structure.UART_Uartx == UART5)
   \                     ??UART_DisableIrq_5: (+1)
   \       0x7C   0x9802             LDR      R0,[SP, #+8]
   \       0x7E   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0x400eb000
   \       0x82   0x4288             CMP      R0,R1
   \       0x84   0xD105             BNE.N    ??UART_DisableIrq_1
    533            {
    534              disable_irq(UART5_RX_TX_IRQn);
   \       0x86   0x2037             MOVS     R0,#+55
   \       0x88   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    535              disable_irq(UART5_ERR_IRQn);
   \       0x8C   0x2038             MOVS     R0,#+56
   \       0x8E   0x.... 0x....      BL       _ZN27_INTERNAL_6_UART_c_e5efacd717__NVIC_DisableIRQE4IRQn
    536            }
    537          }
   \                     ??UART_DisableIrq_1: (+1)
   \       0x92   0xBC01             POP      {R0}
   \       0x94   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    538          
    539          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    540          void UART0_IRQHandler(void)
    541          {
   \                     _Z16UART0_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    542          #if (UCOS_II > 0u)
    543            OS_CPU_SR  cpu_sr = 0u;
    544            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    545            OSIntEnter();
    546            OS_EXIT_CRITICAL();
    547          #endif
    548            //判断Rx FIFO是否 Under flow
    549            if( UART0->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable13_40  ;; 0x4006a012
   \        0x6   0x7801             LDRB     R1,[R0, #+0]
   \        0x8   0x07C9             LSLS     R1,R1,#+31
   \        0xA   0xD503             BPL.N    ??UART0_IRQHandler_0
    550            {
    551              UART0->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x12   0x7001             STRB     R1,[R0, #+0]
    552            }
    553            //判断Tx FIFO是否 Over flow
    554            if( UART0->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART0_IRQHandler_0: (+1)
   \       0x14   0x7801             LDRB     R1,[R0, #+0]
   \       0x16   0x0789             LSLS     R1,R1,#+30
   \       0x18   0xD503             BPL.N    ??UART0_IRQHandler_1
    555            {
    556              UART0->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x1A   0x7801             LDRB     R1,[R0, #+0]
   \       0x1C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x20   0x7001             STRB     R1,[R0, #+0]
    557            }
    558            //进入接收中断函数
    559            if((UART0->S1 & UART_S1_RDRF_MASK) && (UART0->C2 & UART_C2_RIE_MASK))
   \                     ??UART0_IRQHandler_1: (+1)
   \       0x22   0x.... 0x....      LDR.W    R4,??DataTable13_41  ;; 0x4006a004
   \       0x26   0x7820             LDRB     R0,[R4, #+0]
   \       0x28   0x0680             LSLS     R0,R0,#+26
   \       0x2A   0xD507             BPL.N    ??UART0_IRQHandler_2
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable13_42  ;; 0x4006a003
   \       0x30   0x7800             LDRB     R0,[R0, #+0]
   \       0x32   0x0680             LSLS     R0,R0,#+26
   \       0x34   0xD502             BPL.N    ??UART0_IRQHandler_2
    560            {
    561              UART_R_ISR[0]();
   \       0x36   0x....             LDR.N    R0,??DataTable13_38
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x4780             BLX      R0
    562            }
    563            //进入发送中断函数
    564            if((UART0->S1 & UART_S1_TDRE_MASK) && (UART0->C2 & UART_C2_TIE_MASK))
   \                     ??UART0_IRQHandler_2: (+1)
   \       0x3C   0x7820             LDRB     R0,[R4, #+0]
   \       0x3E   0x0600             LSLS     R0,R0,#+24
   \       0x40   0xD506             BPL.N    ??UART0_IRQHandler_3
   \       0x42   0x....             LDR.N    R0,??DataTable13_42  ;; 0x4006a003
   \       0x44   0x7800             LDRB     R0,[R0, #+0]
   \       0x46   0x0600             LSLS     R0,R0,#+24
   \       0x48   0xD502             BPL.N    ??UART0_IRQHandler_3
    565            {
    566              UART_T_ISR[0]();
   \       0x4A   0x....             LDR.N    R0,??DataTable13_39
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x4780             BLX      R0
    567            }
    568            
    569          #if (UCOS_II > 0u)
    570            OSIntExit();          //告知系统此时即将离开中断服务子函数
    571          #endif
    572          }
   \                     ??UART0_IRQHandler_3: (+1)
   \                     ??UART0_IRQHandler_4: (+1)
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
    573          
    574          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    575          void UART1_IRQHandler(void)
    576          {
   \                     _Z16UART1_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    577          #if (UCOS_II > 0u)
    578            OS_CPU_SR  cpu_sr = 0u;
    579            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    580            OSIntEnter();
    581            OS_EXIT_CRITICAL();
    582          #endif
    583            //判断Rx FIFO是否 Under flow
    584            if( UART1->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x....             LDR.N    R0,??DataTable13_43  ;; 0x4006b012
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD503             BPL.N    ??UART1_IRQHandler_0
    585            {
    586              UART1->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x7001             STRB     R1,[R0, #+0]
    587            }
    588            //判断Tx FIFO是否 Over flow
    589            if( UART1->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART1_IRQHandler_0: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x0789             LSLS     R1,R1,#+30
   \       0x16   0xD503             BPL.N    ??UART1_IRQHandler_1
    590            {
    591              UART1->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    592            }  
    593            //进入接收中断函数
    594            if((UART1->S1 & UART_S1_RDRF_MASK) && (UART1->C2 & UART_C2_RIE_MASK))
   \                     ??UART1_IRQHandler_1: (+1)
   \       0x20   0x....             LDR.N    R4,??DataTable13_44  ;; 0x4006b004
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD506             BPL.N    ??UART1_IRQHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable13_45  ;; 0x4006b003
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD502             BPL.N    ??UART1_IRQHandler_2
    595            {
    596              UART_R_ISR[1]();
   \       0x30   0x....             LDR.N    R0,??DataTable13_38
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0x4780             BLX      R0
    597            }
    598            //进入发送中断函数
    599            if((UART1->S1 & UART_S1_TDRE_MASK) && (UART1->C2 & UART_C2_TIE_MASK))
   \                     ??UART1_IRQHandler_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0600             LSLS     R0,R0,#+24
   \       0x3A   0xD506             BPL.N    ??UART1_IRQHandler_3
   \       0x3C   0x....             LDR.N    R0,??DataTable13_45  ;; 0x4006b003
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x0600             LSLS     R0,R0,#+24
   \       0x42   0xD502             BPL.N    ??UART1_IRQHandler_3
    600            {
    601              UART_T_ISR[1]();
   \       0x44   0x....             LDR.N    R0,??DataTable13_39
   \       0x46   0x6840             LDR      R0,[R0, #+4]
   \       0x48   0x4780             BLX      R0
    602            }
    603            
    604          #if (UCOS_II > 0u)
    605            OSIntExit();          //告知系统此时即将离开中断服务子函数
    606          #endif
    607          }
   \                     ??UART1_IRQHandler_3: (+1)
   \                     ??UART1_IRQHandler_4: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    608          
    609          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    610          void UART2_IRQHandler(void)
    611          {
   \                     _Z16UART2_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    612          #if (UCOS_II > 0u)
    613            OS_CPU_SR  cpu_sr = 0u;
    614            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    615            OSIntEnter();
    616            OS_EXIT_CRITICAL();
    617          #endif
    618            //判断Rx FIFO是否 Under flow
    619            if( UART2->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x....             LDR.N    R0,??DataTable13_46  ;; 0x4006c012
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD503             BPL.N    ??UART2_IRQHandler_0
    620            {
    621              UART2->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x7001             STRB     R1,[R0, #+0]
    622            }
    623            //判断Tx FIFO是否 Over flow
    624            if( UART2->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART2_IRQHandler_0: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x0789             LSLS     R1,R1,#+30
   \       0x16   0xD503             BPL.N    ??UART2_IRQHandler_1
    625            {
    626              UART2->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    627            }    
    628            //进入接收中断函数
    629            if((UART2->S1 & UART_S1_RDRF_MASK) && (UART2->C2 & UART_C2_RIE_MASK))
   \                     ??UART2_IRQHandler_1: (+1)
   \       0x20   0x....             LDR.N    R4,??DataTable13_47  ;; 0x4006c004
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD506             BPL.N    ??UART2_IRQHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable13_48  ;; 0x4006c003
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD502             BPL.N    ??UART2_IRQHandler_2
    630            {
    631              UART_R_ISR[2]();
   \       0x30   0x....             LDR.N    R0,??DataTable13_38
   \       0x32   0x6880             LDR      R0,[R0, #+8]
   \       0x34   0x4780             BLX      R0
    632            }
    633            //进入发送中断函数
    634            if((UART2->S1 & UART_S1_TDRE_MASK) && (UART2->C2 & UART_C2_TIE_MASK))
   \                     ??UART2_IRQHandler_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0600             LSLS     R0,R0,#+24
   \       0x3A   0xD506             BPL.N    ??UART2_IRQHandler_3
   \       0x3C   0x....             LDR.N    R0,??DataTable13_48  ;; 0x4006c003
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x0600             LSLS     R0,R0,#+24
   \       0x42   0xD502             BPL.N    ??UART2_IRQHandler_3
    635            {
    636              UART_T_ISR[2]();
   \       0x44   0x....             LDR.N    R0,??DataTable13_39
   \       0x46   0x6880             LDR      R0,[R0, #+8]
   \       0x48   0x4780             BLX      R0
    637            }
    638            
    639          #if (UCOS_II > 0u)
    640            OSIntExit();          //告知系统此时即将离开中断服务子函数
    641          #endif
    642          }
   \                     ??UART2_IRQHandler_3: (+1)
   \                     ??UART2_IRQHandler_4: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    643          
    644          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    645          void UART3_IRQHandler(void)
    646          {
   \                     _Z16UART3_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    647          #if (UCOS_II > 0u)
    648            OS_CPU_SR  cpu_sr = 0u;
    649            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    650            OSIntEnter();
    651            OS_EXIT_CRITICAL();
    652          #endif
    653            //判断Rx FIFO是否 Under flow
    654            if( UART3->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x....             LDR.N    R0,??DataTable13_49  ;; 0x4006d012
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD503             BPL.N    ??UART3_IRQHandler_0
    655            {
    656              UART3->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x7001             STRB     R1,[R0, #+0]
    657            }
    658            //判断Tx FIFO是否 Over flow
    659            if( UART3->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART3_IRQHandler_0: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x0789             LSLS     R1,R1,#+30
   \       0x16   0xD503             BPL.N    ??UART3_IRQHandler_1
    660            {
    661              UART3->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    662            }   
    663            //进入接收中断函数
    664            if((UART3->S1 & UART_S1_RDRF_MASK) && (UART3->C2 & UART_C2_RIE_MASK))
   \                     ??UART3_IRQHandler_1: (+1)
   \       0x20   0x....             LDR.N    R4,??DataTable13_50  ;; 0x4006d004
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD506             BPL.N    ??UART3_IRQHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable13_51  ;; 0x4006d003
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD502             BPL.N    ??UART3_IRQHandler_2
    665            {
    666              UART_R_ISR[3]();
   \       0x30   0x....             LDR.N    R0,??DataTable13_38
   \       0x32   0x68C0             LDR      R0,[R0, #+12]
   \       0x34   0x4780             BLX      R0
    667            }
    668            //进入发送中断函数
    669            if((UART3->S1 & UART_S1_TDRE_MASK) && (UART3->C2 & UART_C2_TIE_MASK))
   \                     ??UART3_IRQHandler_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0600             LSLS     R0,R0,#+24
   \       0x3A   0xD506             BPL.N    ??UART3_IRQHandler_3
   \       0x3C   0x....             LDR.N    R0,??DataTable13_51  ;; 0x4006d003
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x0600             LSLS     R0,R0,#+24
   \       0x42   0xD502             BPL.N    ??UART3_IRQHandler_3
    670            {
    671              UART_T_ISR[3]();
   \       0x44   0x....             LDR.N    R0,??DataTable13_39
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x4780             BLX      R0
    672            }
    673            
    674          #if (UCOS_II > 0u)
    675            OSIntExit();          //告知系统此时即将离开中断服务子函数
    676          #endif
    677          }
   \                     ??UART3_IRQHandler_3: (+1)
   \                     ??UART3_IRQHandler_4: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    678          
    679          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    680          void UART4_IRQHandler(void)
    681          {
   \                     _Z16UART4_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    682          #if (UCOS_II > 0u)
    683            OS_CPU_SR  cpu_sr = 0u;
    684            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    685            OSIntEnter();
    686            OS_EXIT_CRITICAL();
    687          #endif
    688            //判断Rx FIFO是否 Under flow
    689            if( UART4->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x....             LDR.N    R0,??DataTable13_52  ;; 0x400ea012
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD503             BPL.N    ??UART4_IRQHandler_0
    690            {
    691              UART4->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x7001             STRB     R1,[R0, #+0]
    692            }
    693            //判断Tx FIFO是否 Over flow
    694            if( UART4->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART4_IRQHandler_0: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x0789             LSLS     R1,R1,#+30
   \       0x16   0xD503             BPL.N    ??UART4_IRQHandler_1
    695            {
    696              UART4->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    697            }  
    698            //进入接收中断函数
    699            if((UART4->S1 & UART_S1_RDRF_MASK) && (UART4->C2 & UART_C2_RIE_MASK))
   \                     ??UART4_IRQHandler_1: (+1)
   \       0x20   0x....             LDR.N    R4,??DataTable13_53  ;; 0x400ea004
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD506             BPL.N    ??UART4_IRQHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable13_54  ;; 0x400ea003
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD502             BPL.N    ??UART4_IRQHandler_2
    700            {
    701              UART_R_ISR[4]();
   \       0x30   0x....             LDR.N    R0,??DataTable13_38
   \       0x32   0x6900             LDR      R0,[R0, #+16]
   \       0x34   0x4780             BLX      R0
    702            }
    703            //进入发送中断函数
    704            if((UART4->S1 & UART_S1_TDRE_MASK) && (UART4->C2 & UART_C2_TIE_MASK))
   \                     ??UART4_IRQHandler_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0600             LSLS     R0,R0,#+24
   \       0x3A   0xD506             BPL.N    ??UART4_IRQHandler_3
   \       0x3C   0x....             LDR.N    R0,??DataTable13_54  ;; 0x400ea003
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x0600             LSLS     R0,R0,#+24
   \       0x42   0xD502             BPL.N    ??UART4_IRQHandler_3
    705            {
    706              UART_T_ISR[4]();
   \       0x44   0x....             LDR.N    R0,??DataTable13_39
   \       0x46   0x6900             LDR      R0,[R0, #+16]
   \       0x48   0x4780             BLX      R0
    707            }
    708            
    709          #if (UCOS_II > 0u)
    710            OSIntExit();          //告知系统此时即将离开中断服务子函数
    711          #endif
    712          }
   \                     ??UART4_IRQHandler_3: (+1)
   \                     ??UART4_IRQHandler_4: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    713          
    714          //HW层中断函数，用户无需调用

   \                                 In section .text, align 2, keep-with-next
    715          void UART5_IRQHandler(void)
    716          {
   \                     _Z16UART5_IRQHandlerv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    717          #if (UCOS_II > 0u)
    718            OS_CPU_SR  cpu_sr = 0u;
    719            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    720            OSIntEnter();
    721            OS_EXIT_CRITICAL();
    722          #endif
    723            //判断Rx FIFO是否 Under flow
    724            if( UART5->SFIFO & UART_SFIFO_RXUF_MASK)
   \        0x2   0x....             LDR.N    R0,??DataTable13_55  ;; 0x400eb012
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD503             BPL.N    ??UART5_IRQHandler_0
    725            {
    726              UART5->SFIFO |= UART_SFIFO_RXUF_MASK;
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x7001             STRB     R1,[R0, #+0]
    727            }
    728            //判断Tx FIFO是否 Over flow
    729            if( UART5->SFIFO & UART_SFIFO_TXOF_MASK)
   \                     ??UART5_IRQHandler_0: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x0789             LSLS     R1,R1,#+30
   \       0x16   0xD503             BPL.N    ??UART5_IRQHandler_1
    730            {
    731              UART5->SFIFO |= UART_SFIFO_TXOF_MASK;
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    732            }   
    733            //进入接收中断函数
    734            if((UART5->S1 & UART_S1_RDRF_MASK) && (UART5->C2 & UART_C2_RIE_MASK))
   \                     ??UART5_IRQHandler_1: (+1)
   \       0x20   0x....             LDR.N    R4,??DataTable13_56  ;; 0x400eb004
   \       0x22   0x7820             LDRB     R0,[R4, #+0]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD506             BPL.N    ??UART5_IRQHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable13_57  ;; 0x400eb003
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD502             BPL.N    ??UART5_IRQHandler_2
    735            {
    736              UART_R_ISR[5]();
   \       0x30   0x....             LDR.N    R0,??DataTable13_38
   \       0x32   0x6940             LDR      R0,[R0, #+20]
   \       0x34   0x4780             BLX      R0
    737            }
    738            //进入发送中断函数
    739            if((UART5->S1 & UART_S1_TDRE_MASK) && (UART5->C2 & UART_C2_TIE_MASK))
   \                     ??UART5_IRQHandler_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0600             LSLS     R0,R0,#+24
   \       0x3A   0xD506             BPL.N    ??UART5_IRQHandler_3
   \       0x3C   0x....             LDR.N    R0,??DataTable13_57  ;; 0x400eb003
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x0600             LSLS     R0,R0,#+24
   \       0x42   0xD502             BPL.N    ??UART5_IRQHandler_3
    740            {
    741              UART_T_ISR[5]();
   \       0x44   0x....             LDR.N    R0,??DataTable13_39
   \       0x46   0x6940             LDR      R0,[R0, #+20]
   \       0x48   0x4780             BLX      R0
    742            }
    743            
    744          #if (UCOS_II > 0u)
    745            OSIntExit();          //告知系统此时即将离开中断服务子函数
    746          #endif
    747          }
   \                     ??UART5_IRQHandler_3: (+1)
   \                     ??UART5_IRQHandler_4: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    748          

   \                                 In section .text, align 2, keep-with-next
    749          void UART0_ERR_IRQHandler(void)
    750          {
    751          }
   \                     _Z20UART0_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    752          

   \                                 In section .text, align 2, keep-with-next
    753          void UART1_ERR_IRQHandler(void)
    754          {
    755          }
   \                     _Z20UART1_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    756          

   \                                 In section .text, align 2, keep-with-next
    757          void UART2_ERR_IRQHandler(void)
    758          {
    759          }
   \                     _Z20UART2_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    760          

   \                                 In section .text, align 2, keep-with-next
    761          void UART3_ERR_IRQHandler(void)
    762          {
    763          }
   \                     _Z20UART3_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    764          

   \                                 In section .text, align 2, keep-with-next
    765          void UART4_ERR_IRQHandler(void)
    766          {
    767          }
   \                     _Z20UART4_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    768          

   \                                 In section .text, align 2, keep-with-next
    769          void UART5_ERR_IRQHandler(void)
    770          {
    771          }
   \                     _Z20UART5_ERR_IRQHandlerv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    772          

   \                                 In section .text, align 2, keep-with-next
    773          void SendUNum_3(int32 num){
   \                     SendUNum_3: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    774              uart_putchar(num/1000000);
   \        0x4   0x....             LDR.N    R0,??DataTable13_58  ;; 0xf4240
   \        0x6   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x.... 0x....      BL       uart_putchar
    775              uart_putchar(num/10000%100);
   \       0x10   0xF242 0x7010      MOVW     R0,#+10000
   \       0x14   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \       0x18   0x2164             MOVS     R1,#+100
   \       0x1A   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x1E   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x22   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x24   0x.... 0x....      BL       uart_putchar
    776              uart_putchar(num/100%100);
   \       0x28   0x2064             MOVS     R0,#+100
   \       0x2A   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \       0x2E   0x2164             MOVS     R1,#+100
   \       0x30   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x34   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x38   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3A   0x.... 0x....      BL       uart_putchar
    777          }
   \       0x3E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    778          void SendUNum_2(int32 num){
   \                     SendUNum_2: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    779              uart_putchar(num/100);
   \        0x4   0x2064             MOVS     R0,#+100
   \        0x6   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x.... 0x....      BL       uart_putchar
    780              uart_putchar(num%100);
   \       0x10   0x2064             MOVS     R0,#+100
   \       0x12   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \       0x16   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \       0x1A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1C   0x.... 0x....      BL       uart_putchar
    781          }
   \       0x20   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    782          void SendUNum_1(int32 num){
   \                     SendUNum_1: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    783              uart_putchar(num);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x.... 0x....      BL       uart_putchar
    784          }
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    785          

   \                                 In section .text, align 2, keep-with-next
    786          void SendSNum_3(int32 num){
   \                     SendSNum_3: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    787            if(num<0){
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD504             BPL.N    ??SendSNum_3_0
    788              num = -num;
   \        0x8   0x4264             RSBS     R4,R4,#+0
    789              uart_putchar('-');
   \        0xA   0x202D             MOVS     R0,#+45
   \        0xC   0x.... 0x....      BL       uart_putchar
   \       0x10   0xE002             B.N      ??SendSNum_3_1
    790            }
    791            else{
    792              uart_putchar('+');
   \                     ??SendSNum_3_0: (+1)
   \       0x12   0x202B             MOVS     R0,#+43
   \       0x14   0x.... 0x....      BL       uart_putchar
    793            }
    794              uart_putchar(num/100);
   \                     ??SendSNum_3_1: (+1)
   \       0x18   0x2064             MOVS     R0,#+100
   \       0x1A   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x.... 0x....      BL       uart_putchar
    795              uart_putchar(num%100);
   \       0x24   0x2064             MOVS     R0,#+100
   \       0x26   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \       0x2A   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \       0x2E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x30   0x.... 0x....      BL       uart_putchar
    796          }
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    797          

   \                                 In section .text, align 2, keep-with-next
    798          void uart_putchar(uint8 ch){
   \                     uart_putchar: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    799              UART_PutChar(UART0, ch);
   \        0x4   0x0021             MOVS     R1,R4
   \        0x6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x8   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4006a000
   \        0xA   0x.... 0x....      BL       UART_PutChar
    800          }
   \        0xE   0xBD10             POP      {R4,PC}          ;; return
    801          

   \                                 In section .text, align 2, keep-with-next
    802          void SCI_TXD(u8 ch)
    803          {
   \                     SCI_TXD: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    804              UART_PutChar(UART3, ch);
   \        0x4   0x0021             MOVS     R1,R4
   \        0x6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x8   0x....             LDR.N    R0,??DataTable13_20  ;; 0x4006d000
   \        0xA   0x.... 0x....      BL       UART_PutChar
    805          }
   \        0xE   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x4006'A000        DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     g_core_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x4004'8034        DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x4004'9008        DC32     0x40049008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x4004'9038        DC32     0x40049038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x4004'A044        DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0x4004'9004        DC32     0x40049004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \        0x0   0x4004'903C        DC32     0x4004903c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \        0x0   0x4004'A040        DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \        0x0   0x4006'B000        DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \        0x0   0x4004'D000        DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \        0x0   0x4004'B010        DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \        0x0   0x4004'D004        DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \        0x0   0x4004'B00C        DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \        0x0   0x....'....        DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \        0x0   0x4006'C000        DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \        0x0   0x4004'C00C        DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \        0x0   0x4004'C008        DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \        0x0   0x4006'D000        DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \        0x0   0x4004'D010        DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \        0x0   0x4004'A02C        DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \        0x0   0x4004'B044        DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \        0x0   0x4004'D014        DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \        0x0   0x4004'A028        DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \        0x0   0x4004'B040        DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \        0x0   0x400E'A000        DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \        0x0   0x4004'8028        DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_29:
   \        0x0   0x4004'D060        DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_30:
   \        0x0   0x4004'B03C        DC32     0x4004b03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_31:
   \        0x0   0x4004'D064        DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_32:
   \        0x0   0x4004'B038        DC32     0x4004b038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_33:
   \        0x0   0x400E'B000        DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_34:
   \        0x0   0x4004'C024        DC32     0x4004c024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_35:
   \        0x0   0x4004'D020        DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_36:
   \        0x0   0x4004'C020        DC32     0x4004c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_37:
   \        0x0   0x4004'D024        DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_38:
   \        0x0   0x....'....        DC32     UART_R_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_39:
   \        0x0   0x....'....        DC32     UART_T_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_40:
   \        0x0   0x4006'A012        DC32     0x4006a012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_41:
   \        0x0   0x4006'A004        DC32     0x4006a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_42:
   \        0x0   0x4006'A003        DC32     0x4006a003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_43:
   \        0x0   0x4006'B012        DC32     0x4006b012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_44:
   \        0x0   0x4006'B004        DC32     0x4006b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_45:
   \        0x0   0x4006'B003        DC32     0x4006b003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_46:
   \        0x0   0x4006'C012        DC32     0x4006c012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_47:
   \        0x0   0x4006'C004        DC32     0x4006c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_48:
   \        0x0   0x4006'C003        DC32     0x4006c003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_49:
   \        0x0   0x4006'D012        DC32     0x4006d012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_50:
   \        0x0   0x4006'D004        DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_51:
   \        0x0   0x4006'D003        DC32     0x4006d003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_52:
   \        0x0   0x400E'A012        DC32     0x400ea012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_53:
   \        0x0   0x400E'A004        DC32     0x400ea004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_54:
   \        0x0   0x400E'A003        DC32     0x400ea003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_55:
   \        0x0   0x400E'B012        DC32     0x400eb012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_56:
   \        0x0   0x400E'B004        DC32     0x400eb004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_57:
   \        0x0   0x400E'B003        DC32     0x400eb003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_58:
   \        0x0   0x000F'4240        DC32     0xf4240

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SCI_TXD
         8   -> UART_PutChar
       8   SendSNum_3
         8   -> uart_putchar
       8   SendUNum_1
         8   -> uart_putchar
       8   SendUNum_2
         8   -> uart_putchar
       8   SendUNum_3
         8   -> uart_putchar
       0   UART0_ERR_IRQHandler()
       8   UART0_IRQHandler()
         8   -- Indirect call
       0   UART1_ERR_IRQHandler()
       8   UART1_IRQHandler()
         8   -- Indirect call
       0   UART2_ERR_IRQHandler()
       8   UART2_IRQHandler()
         8   -- Indirect call
       0   UART3_ERR_IRQHandler()
       8   UART3_IRQHandler()
         8   -- Indirect call
       0   UART4_ERR_IRQHandler()
       8   UART4_IRQHandler()
         8   -- Indirect call
       0   UART5_ERR_IRQHandler()
       8   UART5_IRQHandler()
         8   -- Indirect call
      24   UART_DisableIrq
        24   -> __NVIC_DisableIRQ(IRQn)
      24   UART_EnableIrq
        24   -> __NVIC_EnableIRQ(IRQn)
       0   UART_GetChar
       0   UART_GetChar_Present
      52   UART_Init
       0   UART_PutChar
      16   UART_PutCharArr
        16   -> UART_PutChar
       0   UART_RxFIFO_Flush
       0   UART_TxFIFO_Flush
       0   __NVIC_DisableIRQ(IRQn)
       0   __NVIC_EnableIRQ(IRQn)
       8   uart_putchar
         8   -> UART_PutChar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_57
       4  ??DataTable13_58
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      16  SCI_TXD
      54  SendSNum_3
      14  SendUNum_1
      34  SendUNum_2
      64  SendUNum_3
       2  UART0_ERR_IRQHandler()
      82  UART0_IRQHandler()
       2  UART1_ERR_IRQHandler()
      76  UART1_IRQHandler()
       2  UART2_ERR_IRQHandler()
      76  UART2_IRQHandler()
       2  UART3_ERR_IRQHandler()
      76  UART3_IRQHandler()
       2  UART4_ERR_IRQHandler()
      76  UART4_IRQHandler()
       2  UART5_ERR_IRQHandler()
      76  UART5_IRQHandler()
     152  UART_DisableIrq
     152  UART_EnableIrq
      10  UART_GetChar
       8  UART_GetChar_Present
    1134  UART_Init
      10  UART_PutChar
      30  UART_PutCharArr
      24  UART_R_ISR
      16  UART_RxFIFO_Flush
      24  UART_T_ISR
      16  UART_TxFIFO_Flush
      40  __NVIC_DisableIRQ(IRQn)
      32  __NVIC_EnableIRQ(IRQn)
      16  uart_putchar
      48  -- Other

 
    48 bytes in section .ARM.exidx
    48 bytes in section .bss
 2 508 bytes in section .text
 
 2 508 bytes of CODE  memory
    48 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: 2
