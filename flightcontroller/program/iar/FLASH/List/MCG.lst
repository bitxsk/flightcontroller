###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         31/Aug/2018  16:56:54
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\MCG.c
#    Command line =  
#        -f C:\Users\XSK199~1\AppData\Local\Temp\EW72B0.tmp
#        (C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\MCG.c
#        -D K60 -D USE_K60F15 -D ARM_MATH_CM4 -D __FPU_PRESENT=1 -D
#        __FPU_USED=1 -lCN
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -lB
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List
#        -o
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        D:\iar\arm\inc\c\DLib_Config_Full.h -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\app\Sensor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\CPU\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\HW\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\DEV\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\FatFs\option\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\common\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\driver\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\descriptor\
#        -I
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\..\lib\USB\class\
#        -On --c++ -I D:\iar\arm\CMSIS\Core\Include\ -I
#        D:\iar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\List\MCG.lst
#    Object file  =  
#        C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\iar\FLASH\Obj\MCG.o
#
###############################################################################

C:\Users\xsk19940910\Desktop\flightController-1\flightController-1\program\lib\LPLD\HW\MCG.c
      1          /**
      2           * @file MCG.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief MCG底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"
     23          #include "MCG.h"
     24          
     25          

   \                                 In section .data, align 4
     26          uint32 g_core_clock = -1ul;
   \                     g_core_clock:
   \        0x0   0xFFFF'FFFF        DC32 4294967295

   \                                 In section .data, align 4
     27          uint32 g_bus_clock = -1ul;
   \                     g_bus_clock:
   \        0x0   0xFFFF'FFFF        DC32 4294967295

   \                                 In section .data, align 4
     28          uint32 g_flash_clock = -1ul;
   \                     g_flash_clock:
   \        0x0   0xFFFF'FFFF        DC32 4294967295

   \                                 In section .data, align 4
     29          uint32 g_flexbus_clock = -1ul;
   \                     g_flexbus_clock:
   \        0x0   0xFFFF'FFFF        DC32 4294967295
     30          
     31          /*
     32           * PLL_Setup
     33           * 初始化内核时钟及其他系统时钟
     34           * 
     35           * 参数:
     36           *    core_clk_mhz--期望内核时钟频率
     37           *      |__PLLx--参见HAL_MCG.h中的PLL_option定义
     38           *
     39           * 输出:
     40           *    内核频率，单位MHz
     41           */

   \                                 In section .text, align 4, keep-with-next
     42          uint8 PLL_Setup(PllOptionEnum_Type core_clk_mhz)
     43          {
   \                     PLL_Setup: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
     44            uint8 pll_freq;
     45            uint8 prdiv, vdiv;
     46            uint8 core_div, bus_div, flexbus_div, flash_div;
     47          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)
     48          /*
     49           *************************************************
     50            【LPLD注解】MCG关键系数
     51            prdiv(PLL分频系数): 0~31(1~32)
     52            vdiv(PLL倍频系数): 0~31(24~55)
     53            PLL参考时钟范围: 2MHz~4MHz
     54            PLL参考时钟 = 外部参考时钟(CANNED_OSC_CLK_HZ)/prdiv
     55            CoreClk = PLL参考时钟 x PLL倍频系数 /OUTDIV1
     56           *************************************************
     57           */
     58           
     59            // 对于MK60DZ10来说，core_clk_mhz建议不要超过100，这里限制为最高200
     60            core_clk_mhz = (PllOptionEnum_Type)(core_clk_mhz>200u?200u:core_clk_mhz);
     61            
     62            // 根据期望主频选择分频和倍频系数
     63            switch(core_clk_mhz)
     64            {
     65            case PLL_48:
     66          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
     67              prdiv = 24u; //50Mhz/ 25 = 2Mhz
     68          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
     69              prdiv = 3u;  //8Mhz/ 4 = 2Mhz
     70          #endif
     71              vdiv = 0u;  // 2Mhz * 24 = 48Mhz
     72              break;
     73            case PLL_50:
     74          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
     75              prdiv = 24u; //50Mhz/ 25 = 2Mhz
     76          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
     77              prdiv = 3u; //8Mhz/ 4 = 2Mhz
     78          #endif
     79              vdiv = 1u; // 2Mhz * 25 = 50Mhz
     80              break;
     81            case PLL_96:
     82          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
     83              prdiv = 24u; //50Mhz/ 25 = 2Mhz
     84          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
     85              prdiv = 3u; //8Mhz/ 4 = 2Mhz
     86          #endif
     87              vdiv = 24u; //2Mhz * 48 = 96Mhz
     88              break;
     89            case PLL_100:
     90          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
     91              prdiv = 24u; //50Mhz/ 25 = 2Mhz
     92          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
     93              prdiv = 3u; //8Mhz/ 4 = 2Mhz
     94          #endif
     95              vdiv = 26u; //2Mhz * 50 = 100Mhz
     96              break;
     97            case PLL_120:
     98          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
     99              prdiv = 19u; //50Mhz/ 20 = 2.5Mhz
    100              vdiv = 24u;  //2.5Mhz * 48 = 120Mhz
    101          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    102              prdiv = 1u; //8Mhz/ 2 = 4Mhz
    103              vdiv  = 6u; //4Mhz * 30 = 120Mhz
    104          #endif
    105              break;
    106            case PLL_150:
    107          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    108              prdiv = 15u; //50Mhz/ 16 = 3.3Mhz
    109              vdiv = 24u;  //3.3Mhz * 48 = 156.4Mhz
    110          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    111              prdiv = 1u; //8Mhz/ 2 = 4Mhz
    112              vdiv  = 13u; //4Mhz * 37 = 148Mhz
    113          #endif
    114              break;
    115            case PLL_180:
    116          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    117              prdiv = 14u; //50Mhz/ 15 = 3.3Mhz
    118              vdiv = 30u;  //3.3Mhz * 54 = 178.2Mhz
    119          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    120              prdiv = 1u;  //8Mhz/ 2 = 4Mhz
    121              vdiv = 21u;  //4Mhz * 45 = 180Mhz
    122          #endif
    123              break;
    124            case PLL_200:
    125          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    126              prdiv = 12u; 
    127              vdiv = 28u;
    128          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    129              prdiv = 1u;  //8Mhz/ 2 = 4Mhz
    130              vdiv = 26u;  //4Mhz * 50 = 200Mhz
    131          #endif
    132              break;
    133            default:
    134              return PLL_Setup(PLL_96);
    135            }
    136          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
    137           /*
    138           *************************************************
    139            【LPLD注解】MCG关键系数
    140            prdiv(PLL分频系数): 0~7(1~8)
    141            vdiv(PLL倍频系数): 0~31(16~47)
    142            PLL参考时钟范围: 8MHz~16MHz
    143            PLL参考时钟 = 外部参考时钟(CANNED_OSC_CLK_HZ)/prdiv
    144            PLL输出时钟范围: 90MHz~180MHz
    145            PLL输出时钟 = PLL参考时钟 x vdiv（PLL倍频系数）/2
    146            CoreClk = PLL输出时钟 /OUTDIV1
    147           *************************************************
    148          */
    149            
    150            // 对于MK60F12来说，core_clk_mhz建议不要超过120，这里限制为最高200
    151            // 对于MK60F15来说，core_clk_mhz建议不要超过150，这里限制为最高200
    152            core_clk_mhz = (PllOptionEnum_Type)(core_clk_mhz>200u?200u:core_clk_mhz);
   \        0x4   0x0001             MOVS     R1,R0
   \        0x6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x8   0x29C9             CMP      R1,#+201
   \        0xA   0xD301             BCC.N    ??PLL_Setup_1
   \        0xC   0x24C8             MOVS     R4,#+200
   \        0xE   0xE000             B.N      ??PLL_Setup_2
   \                     ??PLL_Setup_1: (+1)
   \       0x10   0x0004             MOVS     R4,R0
    153            // 根据期望主频选择分频和倍频系数
    154            switch(core_clk_mhz)
   \                     ??PLL_Setup_2: (+1)
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x16   0x2864             CMP      R0,#+100
   \       0x18   0xD008             BEQ.N    ??PLL_Setup_3
   \       0x1A   0x2878             CMP      R0,#+120
   \       0x1C   0xD009             BEQ.N    ??PLL_Setup_4
   \       0x1E   0x2896             CMP      R0,#+150
   \       0x20   0xD00A             BEQ.N    ??PLL_Setup_5
   \       0x22   0x28B4             CMP      R0,#+180
   \       0x24   0xD00B             BEQ.N    ??PLL_Setup_6
   \       0x26   0x28C8             CMP      R0,#+200
   \       0x28   0xD00C             BEQ.N    ??PLL_Setup_7
   \       0x2A   0xE00E             B.N      ??PLL_Setup_8
    155            {
    156            case PLL_100:
    157          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    158              prdiv = 4u; //50Mhz / 5 = 10Mhz
   \                     ??PLL_Setup_3: (+1)
   \       0x2C   0x2104             MOVS     R1,#+4
    159              vdiv = 4u;  //10Mhz * 20 /2 = 100Mhz
   \       0x2E   0x2204             MOVS     R2,#+4
    160          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    161              prdiv = 0u; //8Mhz / 1 = 8Mhz
    162              vdiv = 9u;  //8Mhz * 25 /2 = 100Mhz
    163          #endif
    164              break;
   \       0x30   0xE010             B.N      ??PLL_Setup_9
    165            case PLL_120:
    166          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    167              prdiv = 4u; //50Mhz / 5 = 10Mhz
   \                     ??PLL_Setup_4: (+1)
   \       0x32   0x2104             MOVS     R1,#+4
    168              vdiv = 8u;  //10Mhz * 24 /2 = 120Mhz
   \       0x34   0x2208             MOVS     R2,#+8
    169          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    170              prdiv = 0u; //8Mhz / 1 = 8Mhz
    171              vdiv = 14u; //8Mhz * 30 /2 = 120Mhz
    172          #endif
    173              break;
   \       0x36   0xE00D             B.N      ??PLL_Setup_9
    174            case PLL_150:
    175          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    176              prdiv = 4u; //50Mhz / 5 = 10Mhz
   \                     ??PLL_Setup_5: (+1)
   \       0x38   0x2104             MOVS     R1,#+4
    177              vdiv = 14u; //10Mhz * 30 /2 = 150Mhz
   \       0x3A   0x220E             MOVS     R2,#+14
    178          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    179              prdiv = 0u; //8Mhz / 1 = 8Mhz
    180              vdiv = 22u; //8Mhz * 38 /2 = 152Mhz
    181          #endif
    182              break;
   \       0x3C   0xE00A             B.N      ??PLL_Setup_9
    183            case PLL_180:
    184          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    185              prdiv = 4u; //50Mhz / 5 = 10Mhz
   \                     ??PLL_Setup_6: (+1)
   \       0x3E   0x2104             MOVS     R1,#+4
    186              vdiv = 20u; //10Mhz * 36 /2 = 180Mhz
   \       0x40   0x2214             MOVS     R2,#+20
    187          #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    188              prdiv = 0u; //8Mhz / 1 = 8Mhz
    189              vdiv = 29u; //8Mhz * 45 /2 = 180Mhz    
    190          #endif
    191              break;
   \       0x42   0xE007             B.N      ??PLL_Setup_9
    192            case PLL_200:
    193          #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    194              prdiv = 3u;  //50Mhz / 4 = 12.5Mhz
   \                     ??PLL_Setup_7: (+1)
   \       0x44   0x2103             MOVS     R1,#+3
    195              vdiv = 16u;  //12.5Mhz * 32 / 2 = 200
   \       0x46   0x2210             MOVS     R2,#+16
    196          #endif
    197              break;
   \       0x48   0xE004             B.N      ??PLL_Setup_9
    198            default:
    199              return PLL_Setup(PLL_120);
   \                     ??PLL_Setup_8: (+1)
   \       0x4A   0x2078             MOVS     R0,#+120
   \       0x4C   0xF7FF 0xFFD8      BL       PLL_Setup
   \       0x50   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x52   0xE0C5             B.N      ??PLL_Setup_10
    200            } 
    201          #endif
    202            
    203            pll_freq = core_clk_mhz * 1;
   \                     ??PLL_Setup_9: (+1)
   \       0x54   0x0020             MOVS     R0,R4
    204            core_div = 0;
   \       0x56   0x2300             MOVS     R3,#+0
    205            if((bus_div = (uint8)(core_clk_mhz/BUS_CLK_MHZ - 1u)) == (uint8)-1)
   \       0x58   0x0025             MOVS     R5,R4
   \       0x5A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0x5C   0x263C             MOVS     R6,#+60
   \       0x5E   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \       0x62   0x1E6D             SUBS     R5,R5,#+1
   \       0x64   0x002E             MOVS     R6,R5
   \       0x66   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x68   0x2EFF             CMP      R6,#+255
   \       0x6A   0xD102             BNE.N    ??PLL_Setup_11
    206            {
    207              bus_div = 0;
   \       0x6C   0x2600             MOVS     R6,#+0
   \       0x6E   0x0035             MOVS     R5,R6
   \       0x70   0xE009             B.N      ??PLL_Setup_12
    208            }
    209            else if(core_clk_mhz/(bus_div+1) > BUS_CLK_MHZ)
   \                     ??PLL_Setup_11: (+1)
   \       0x72   0x0026             MOVS     R6,R4
   \       0x74   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x76   0x002F             MOVS     R7,R5
   \       0x78   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x7A   0x1C7F             ADDS     R7,R7,#+1
   \       0x7C   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \       0x80   0x2E3D             CMP      R6,#+61
   \       0x82   0xD300             BCC.N    ??PLL_Setup_12
    210            {
    211              bus_div += 1;
   \       0x84   0x1C6D             ADDS     R5,R5,#+1
    212            }
    213            if((flexbus_div = (core_clk_mhz/FLEXBUS_CLK_MHZ - 1u)) == (uint8)-1)
   \                     ??PLL_Setup_12: (+1)
   \       0x86   0x0026             MOVS     R6,R4
   \       0x88   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x8A   0x2732             MOVS     R7,#+50
   \       0x8C   0xFBB6 0xF6F7      UDIV     R6,R6,R7
   \       0x90   0x1E76             SUBS     R6,R6,#+1
   \       0x92   0x0037             MOVS     R7,R6
   \       0x94   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x96   0x2FFF             CMP      R7,#+255
   \       0x98   0xD102             BNE.N    ??PLL_Setup_13
    214            {
    215              flexbus_div = 0;
   \       0x9A   0x2700             MOVS     R7,#+0
   \       0x9C   0x003E             MOVS     R6,R7
   \       0x9E   0xE00B             B.N      ??PLL_Setup_14
    216            }
    217            else if(core_clk_mhz/(flexbus_div+1) > FLEXBUS_CLK_MHZ)
   \                     ??PLL_Setup_13: (+1)
   \       0xA0   0x0027             MOVS     R7,R4
   \       0xA2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0xA4   0x46B4             MOV      R12,R6
   \       0xA6   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0xAA   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \       0xAE   0xFB97 0xF7FC      SDIV     R7,R7,R12
   \       0xB2   0x2F33             CMP      R7,#+51
   \       0xB4   0xD300             BCC.N    ??PLL_Setup_14
    218            {
    219              flexbus_div += 1;
   \       0xB6   0x1C76             ADDS     R6,R6,#+1
    220            }
    221            if((flash_div = (core_clk_mhz/FLASH_CLK_MHZ - 1u)) == (uint8)-1)
   \                     ??PLL_Setup_14: (+1)
   \       0xB8   0x0027             MOVS     R7,R4
   \       0xBA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0xBC   0xF05F 0x0C19      MOVS     R12,#+25
   \       0xC0   0xFBB7 0xF7FC      UDIV     R7,R7,R12
   \       0xC4   0x1E7F             SUBS     R7,R7,#+1
   \       0xC6   0x46BC             MOV      R12,R7
   \       0xC8   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0xCC   0xF1BC 0x0FFF      CMP      R12,#+255
   \       0xD0   0xD103             BNE.N    ??PLL_Setup_15
    222            {
    223              flash_div = 0;
   \       0xD2   0xF05F 0x0C00      MOVS     R12,#+0
   \       0xD6   0x4667             MOV      R7,R12
   \       0xD8   0xE00D             B.N      ??PLL_Setup_16
    224            }
    225            else if(core_clk_mhz/(flash_div+1) > FLASH_CLK_MHZ)
   \                     ??PLL_Setup_15: (+1)
   \       0xDA   0x46A4             MOV      R12,R4
   \       0xDC   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0xE0   0x46BE             MOV      LR,R7
   \       0xE2   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0xE6   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \       0xEA   0xFB9C 0xFCFE      SDIV     R12,R12,LR
   \       0xEE   0xF1BC 0x0F1A      CMP      R12,#+26
   \       0xF2   0xD300             BCC.N    ??PLL_Setup_16
    226            {
    227              flash_div += 1;
   \       0xF4   0x1C7F             ADDS     R7,R7,#+1
    228            }
    229           
    230          #if defined(CPU_MK60DZ10)
    231            
    232            #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    233            // 这里假设复位后 MCG 模块默认为 FEI 模式
    234            // 首先移动到 FBE 模式
    235            MCG->C2 = 0;
    236            // 振荡器初始化完成后,释放锁存状态下的 oscillator 和 GPIO 
    237            SIM->SCGC4 |= SIM_SCGC4_LLWU_MASK;
    238            LLWU->CS |= LLWU_CS_ACKISO_MASK;
    239            // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
    240            // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    241            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);  
    242            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    243            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    244            // 进入FBE模式
    245            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
    246            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    247            // 产生 2MHz 的参考时钟给 PLL.
    248            MCG->C5 = MCG_C5_PRDIV(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    249            // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
    250            MCG->C6 = 0x0;
    251            //设置系统时钟分频系数
    252            Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    253            //设置倍频系数
    254            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(vdiv); 
    255            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    256            while (!(MCG->S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
    257            // 已经进入PBE模式
    258            // 清零CLKS 进入PEE模式
    259            MCG->C1 &= ~MCG_C1_CLKS_MASK;
    260            // Wait for clock status bits to update
    261            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    262            // 已经进入PEE模式
    263            
    264            #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    265            // 这里假设复位后 MCG 模块默认为 FEI 模式
    266            // 首先移动到 FBE 模式
    267            MCG->C2 = MCG_C2_RANGE(0x01) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
    268            // 振荡器初始化完成后,释放锁存状态下的 oscillator 和 GPIO 
    269            SIM->SCGC4 |= SIM_SCGC4_LLWU_MASK;
    270            LLWU->CS |= LLWU_CS_ACKISO_MASK;
    271            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
    272            while (!(MCG->S & MCG_S_OSCINIT_MASK)) {}; //等待C2[EREFS]初始化
    273            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    274            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    275            // 进入FBE模式
    276            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
    277            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    278            // 产生 2MHz 的参考时钟给 PLL.
    279            MCG->C5 = MCG_C5_PRDIV(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    280            // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
    281            MCG->C6 = 0x0;
    282            //设置系统时钟分频系数
    283            Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    284            //设置倍频系数
    285            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(vdiv); 
    286            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    287            while (!(MCG->S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
    288            // 已经进入PBE模式
    289            // 清零CLKS 进入PEE模式
    290            MCG->C1 &= ~MCG_C1_CLKS_MASK;
    291            // Wait for clock status bits to update
    292            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    293            #endif
    294            
    295          #elif (defined(CPU_MK60D10)) 
    296            
    297            #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    298            // 这里假设复位后 MCG 模块默认为 FEI 模式
    299            // 首先移动到 FBE 模式
    300            MCG->C2 = 0;
    301            // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
    302            // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    303            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);  
    304            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    305            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    306            // 进入FBE模式
    307            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
    308            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    309            // 产生 2MHz 的参考时钟给 PLL.
    310            MCG->C5 = MCG_C5_PRDIV0(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    311            // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
    312            MCG->C6 = 0x0;
    313            //设置系统时钟分频系数
    314            Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    315            //设置倍频系数
    316            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv); 
    317            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    318            while (!(MCG->S & MCG_S_LOCK0_MASK)){}; // Wait for LOCK bit to set
    319            // 已经进入PBE模式
    320            // 清零CLKS 进入PEE模式
    321            MCG->C1 &= ~MCG_C1_CLKS_MASK;
    322            // Wait for clock status bits to update
    323            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    324            // 已经进入PEE模式
    325            
    326            #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    327            
    328            // 这里假设复位后 MCG 模块默认为 FEI 模式
    329            // 首先移动到 FBE 模式
    330            MCG->C2 = MCG_C2_RANGE0(0x01) | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK;
    331          
    332            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
    333            while (!(MCG->S & MCG_S_OSCINIT0_MASK)) {}; //等待C2[EREFS]初始化
    334            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    335            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    336            // 进入FBE模式
    337            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
    338            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    339            // 产生 2MHz 的参考时钟给 PLL.
    340            MCG->C5 = MCG_C5_PRDIV0(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    341            // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
    342            MCG->C6 = 0x0;
    343            //设置系统时钟分频系数
    344            Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    345            //设置倍频系数
    346            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv); 
    347            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    348            while (!(MCG->S & MCG_S_LOCK0_MASK)){}; // Wait for LOCK bit to set
    349            // 已经进入PBE模式
    350            // 清零CLKS 进入PEE模式
    351            MCG->C1 &= ~MCG_C1_CLKS_MASK;
    352            // Wait for clock status bits to update
    353            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    354            
    355            #endif
    356            
    357          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
    358            
    359            if (PMC->REGSC &  PMC_REGSC_ACKISO_MASK)
   \                     ??PLL_Setup_16: (+1)
   \       0xF6   0xF8DF 0xC0EC      LDR.W    R12,??PLL_Setup_0  ;; 0x4007d002
   \       0xFA   0xF89C 0xE000      LDRB     LR,[R12, #+0]
   \       0xFE   0xEA5F 0x7E0E      LSLS     LR,LR,#+28
   \      0x102   0xD505             BPL.N    ??PLL_Setup_17
    360                  PMC->REGSC |= PMC_REGSC_ACKISO_MASK;
   \      0x104   0xF89C 0xE000      LDRB     LR,[R12, #+0]
   \      0x108   0xF05E 0x0E08      ORRS     LR,LR,#0x8
   \      0x10C   0xF88C 0xE000      STRB     LR,[R12, #+0]
    361            /*注意：PLL初始化不会配置系统时钟分频，
    362              所以系统时钟分频必须在PLL之前调用*/ 
    363            SIM->CLKDIV1 = ( 0
    364                            | SIM_CLKDIV1_OUTDIV1(core_div)   //设置内核分频
    365                            | SIM_CLKDIV1_OUTDIV2(bus_div)   //设置外设分频
    366                            | SIM_CLKDIV1_OUTDIV3(flexbus_div)   //设置FlexBus分频
    367                            | SIM_CLKDIV1_OUTDIV4(flash_div) );//设置FLASH分频
   \                     ??PLL_Setup_17: (+1)
   \      0x110   0x469C             MOV      R12,R3
   \      0x112   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x116   0x46AE             MOV      LR,R5
   \      0x118   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \      0x11C   0xEA5F 0x6E0E      LSLS     LR,LR,#+24
   \      0x120   0xF01E 0x6E70      ANDS     LR,LR,#0xF000000
   \      0x124   0xEA5E 0x7E0C      ORRS     LR,LR,R12, LSL #+28
   \      0x128   0x46B4             MOV      R12,R6
   \      0x12A   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x12E   0xEA5F 0x5C0C      LSLS     R12,R12,#+20
   \      0x132   0xF41C 0x0C70      ANDS     R12,R12,#0xF00000
   \      0x136   0xEA5C 0x0E0E      ORRS     LR,R12,LR
   \      0x13A   0x46BC             MOV      R12,R7
   \      0x13C   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x140   0xEA5F 0x4C0C      LSLS     R12,R12,#+16
   \      0x144   0xF41C 0x2C70      ANDS     R12,R12,#0xF0000
   \      0x148   0xEA5C 0x0E0E      ORRS     LR,R12,LR
   \      0x14C   0xF8DF 0xC098      LDR.W    R12,??PLL_Setup_0+0x4  ;; 0x40048044
   \      0x150   0xF8CC 0xE000      STR      LR,[R12, #+0]
    368            //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
    369            
    370            #if OSC_CIRCUIT_TPYE == CANNED_OSC_CIRCUIT
    371            // 这里假设复位后 MCG 模块默认为 FEI 模式
    372            // 首先移动到 FBE 模式
    373            MCG->C2 = MCG_C2_RANGE0(1);
   \      0x154   0xF05F 0x0C10      MOVS     R12,#+16
   \      0x158   0xF8DF 0xE090      LDR.W    LR,??PLL_Setup_0+0x8  ;; 0x40064001
   \      0x15C   0xF88E 0xC000      STRB     R12,[LR, #+0]
    374            // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
    375            // CLKS=2, FRDIV=5, IREFS=0, IRCLKEN=0, IREFSTEN=0
    376            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(5);
   \      0x160   0xF8DF 0xC08C      LDR.W    R12,??PLL_Setup_0+0xC  ;; 0x40064000
   \      0x164   0xF05F 0x0EA8      MOVS     LR,#+168
   \      0x168   0xF88C 0xE000      STRB     LR,[R12, #+0]
    377            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
   \                     ??PLL_Setup_18: (+1)
   \      0x16C   0xF8DF 0xE084      LDR.W    LR,??PLL_Setup_0+0x10  ;; 0x40064006
   \      0x170   0xF89E 0x8000      LDRB     R8,[LR, #+0]
   \      0x174   0xEA5F 0x68C8      LSLS     R8,R8,#+27
   \      0x178   0xD4F8             BMI.N    ??PLL_Setup_18
    378            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
   \                     ??PLL_Setup_19: (+1)
   \      0x17A   0xF89E 0x8000      LDRB     R8,[LR, #+0]
   \      0x17E   0xF3C8 0x0881      UBFX     R8,R8,#+2,#+2
   \      0x182   0xF1B8 0x0F02      CMP      R8,#+2
   \      0x186   0xD1F8             BNE.N    ??PLL_Setup_19
    379            // 进入FBE模式
    380            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV
    381            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    382            // 产生 10MHz 的参考时钟给 PLL.
    383            MCG->C6 |= MCG_C6_CME0_MASK;
   \      0x188   0xF8DF 0x806C      LDR.W    R8,??PLL_Setup_0+0x14  ;; 0x40064005
   \      0x18C   0xF898 0x9000      LDRB     R9,[R8, #+0]
   \      0x190   0xF059 0x0920      ORRS     R9,R9,#0x20
   \      0x194   0xF888 0x9000      STRB     R9,[R8, #+0]
    384            MCG->C5 = MCG_C5_PRDIV0(prdiv); // 设置 PLL 匹配晶振的参考分频数
   \      0x198   0xF011 0x0907      ANDS     R9,R1,#0x7
   \      0x19C   0xF8DF 0xA05C      LDR.W    R10,??PLL_Setup_0+0x18  ;; 0x40064004
   \      0x1A0   0xF88A 0x9000      STRB     R9,[R10, #+0]
    385            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv); 
   \      0x1A4   0xF012 0x091F      ANDS     R9,R2,#0x1F
   \      0x1A8   0xF059 0x0940      ORRS     R9,R9,#0x40
   \      0x1AC   0xF888 0x9000      STRB     R9,[R8, #+0]
    386            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??PLL_Setup_20: (+1)
   \      0x1B0   0xF89E 0x8000      LDRB     R8,[LR, #+0]
   \      0x1B4   0xEA5F 0x6888      LSLS     R8,R8,#+26
   \      0x1B8   0xD5FA             BPL.N    ??PLL_Setup_20
    387            while (!(MCG->S & MCG_S_LOCK0_MASK)){}; // Wait for LOCK bit to set
   \                     ??PLL_Setup_21: (+1)
   \      0x1BA   0xF89E 0x8000      LDRB     R8,[LR, #+0]
   \      0x1BE   0xEA5F 0x6848      LSLS     R8,R8,#+25
   \      0x1C2   0xD5FA             BPL.N    ??PLL_Setup_21
    388            // 已经进入PBE模式
    389            // 清零CLKS 进入PEE模式
    390            MCG->C1 &= ~MCG_C1_CLKS_MASK;
   \      0x1C4   0xF89C 0x8000      LDRB     R8,[R12, #+0]
   \      0x1C8   0xF018 0x083F      ANDS     R8,R8,#0x3F
   \      0x1CC   0xF88C 0x8000      STRB     R8,[R12, #+0]
    391            // Wait for clock status bits to update
    392            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??PLL_Setup_22: (+1)
   \      0x1D0   0xF89E 0xC000      LDRB     R12,[LR, #+0]
   \      0x1D4   0xF3CC 0x0C81      UBFX     R12,R12,#+2,#+2
   \      0x1D8   0xF1BC 0x0F03      CMP      R12,#+3
   \      0x1DC   0xD1F8             BNE.N    ??PLL_Setup_22
    393            // 已经进入PEE模式
    394            #elif OSC_CIRCUIT_TPYE == CRYSTAL_OSC_CIRCUIT
    395            // 这里假设复位后 MCG 模块默认为 FEI 模式
    396            // 首先移动到 FBE 模式
    397            MCG->C2 = MCG_C2_RANGE0(1) | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK;
    398            // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
    399            // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    400            MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
    401            while (!(MCG->S & MCG_S_OSCINIT0_MASK)) {}; //等待C2[EREFS]初始化
    402            while (MCG->S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    403            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    404            // 进入FBE模式
    405            // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV
    406            // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
    407            // 产生 10MHz 的参考时钟给 PLL.
    408            MCG->C6 |= MCG_C6_CME0_MASK;
    409            MCG->C5 = MCG_C5_PRDIV0(prdiv); // 设置 PLL 匹配晶振的参考分频数
    410            MCG->C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv); 
    411            while (!(MCG->S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    412            while (!(MCG->S & MCG_S_LOCK0_MASK)){}; // Wait for LOCK bit to set
    413            // 已经进入PBE模式
    414            // 清零CLKS 进入PEE模式
    415            MCG->C1 &= ~MCG_C1_CLKS_MASK;
    416            // Wait for clock status bits to update
    417            while (((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    418            // 已经进入PEE模式
    419            #endif
    420          #endif  
    421            return pll_freq;
   \      0x1DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??PLL_Setup_10: (+1)
   \      0x1E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??PLL_Setup_0:
   \      0x1E4   0x4007'D002        DC32     0x4007d002
   \      0x1E8   0x4004'8044        DC32     0x40048044
   \      0x1EC   0x4006'4001        DC32     0x40064001
   \      0x1F0   0x4006'4000        DC32     0x40064000
   \      0x1F4   0x4006'4006        DC32     0x40064006
   \      0x1F8   0x4006'4005        DC32     0x40064005
   \      0x1FC   0x4006'4004        DC32     0x40064004
    422          } 
    423          
    424          /*
    425           * Set_SYS_DIV
    426           * 设置系统始终分频
    427           *
    428           * 说明:
    429           * 这段代码必须放置在RAM中，目的是防止程序跑飞，详见官方文档errata e2448.
    430           * 当Flash时钟分频改变的时候，Flash预读取必须禁用.
    431           * 禁止从Flash中运行以下代码.
    432           * 在预读取被重新使能之前必须在时钟分频改变后有一段小的延时.
    433           *
    434           * 参数:
    435           *    outdiv1~outdiv4--分别为core, bus, FlexBus, Flash时钟分频系数
    436           */

   \                                 In section .textrw, align 4, keep-with-next
    437          RAMFUNC void Set_SYS_DIV(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
    438          {
   \                     Set_SYS_DIV: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    439            uint32 temp_reg;
    440            uint8 i;
    441            
    442            temp_reg = FMC->PFAPR; // 备份 FMC_PFAPR 寄存器
   \        0x2   0x4E0F             LDR.N    R6,??Set_SYS_DIV_0  ;; 0x4001f000
   \        0x4   0x6834             LDR      R4,[R6, #+0]
    443            
    444            // 设置 M0PFD 到 M7PFD 为 1 禁用预先读取
    445            FMC->PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    446                       | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    447                       | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \        0x6   0x6835             LDR      R5,[R6, #+0]
   \        0x8   0xF455 0x057F      ORRS     R5,R5,#0xFF0000
   \        0xC   0x6035             STR      R5,[R6, #+0]
    448            
    449            // 设置时钟分频为期望值  
    450            SIM->CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    451                        | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
   \        0xE   0x060D             LSLS     R5,R1,#+24
   \       0x10   0xF015 0x6570      ANDS     R5,R5,#0xF000000
   \       0x14   0xEA55 0x7500      ORRS     R5,R5,R0, LSL #+28
   \       0x18   0x0517             LSLS     R7,R2,#+20
   \       0x1A   0xF417 0x0770      ANDS     R7,R7,#0xF00000
   \       0x1E   0x433D             ORRS     R5,R7,R5
   \       0x20   0x041F             LSLS     R7,R3,#+16
   \       0x22   0xF417 0x2770      ANDS     R7,R7,#0xF0000
   \       0x26   0x433D             ORRS     R5,R7,R5
   \       0x28   0x4F06             LDR.N    R7,??Set_SYS_DIV_0+0x4  ;; 0x40048044
   \       0x2A   0x603D             STR      R5,[R7, #+0]
    452          
    453            // 延时一小段时间等待改变
    454            for (i = 0 ; i < outdiv4 ; i++)
   \       0x2C   0x2500             MOVS     R5,#+0
   \                     ??Set_SYS_DIV_1: (+1)
   \       0x2E   0x002F             MOVS     R7,R5
   \       0x30   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x32   0x429F             CMP      R7,R3
   \       0x34   0xD201             BCS.N    ??Set_SYS_DIV_2
   \       0x36   0x1C6D             ADDS     R5,R5,#+1
   \       0x38   0xE7F9             B.N      ??Set_SYS_DIV_1
    455            {}
    456            
    457            FMC->PFAPR = temp_reg; // 回复原先的 FMC_PFAPR 寄存器值
   \                     ??Set_SYS_DIV_2: (+1)
   \       0x3A   0x6034             STR      R4,[R6, #+0]
    458            
    459            return;
   \       0x3C   0xBCF0             POP      {R4-R7}
   \       0x3E   0x4770             BX       LR               ;; return
   \                     ??Set_SYS_DIV_0:
   \       0x40   0x4001'F000        DC32     0x4001f000
   \       0x44   0x4004'8044        DC32     0x40048044
    460          } // set_sys_dividers
    461          
    462          /*******************************************
    463          *         MK60F12 & 15
    464          *  MCGOUT = PLL output frequency/2
    465          *  PLL = (Crystal / PRDIV0 ) * VDIV0
    466          ********************************************
    467          PRDIV0 Divide Factor
    468          ********************************************
    469          PRDIV0  Va
    470          ********************************************
    471          000     1
    472          001     2
    473          010     3
    474          011     4
    475          100     5
    476          101     6
    477          110     7
    478          111     8
    479          ********************************************
    480          VDIV0 MultiplyFactor
    481          ********************************************
    482          VDIV0 Va VDIV0 Va VDIV0 Va VDIV0 Va
    483          ********************************************
    484          00000 16 01000 24 10000 32 11000 40
    485          00001 17 01001 25 10001 33 11001 41
    486          00010 18 01010 26 10010 34 11010 42
    487          00011 19 01011 27 10011 35 11011 43
    488          00100 20 01100 28 10100 36 11100 44
    489          00101 21 01101 29 10101 37 11101 45
    490          00110 22 01110 30 10110 38 11110 46
    491          00111 23 01111 31 10111 39 11111 47
    492          ********************************************/
    493          
    494          /********************************************
    495          *             MK60DZ10
    496          *  MCGOUT = PLL output frequency
    497          *  PLL = (Crystal / PRDIV0 ) * VDIV0
    498          *********************************************
    499          PRDIV DivideFactor
    500          *********************************************
    501          PRDIV0 Va PRDIV0 Va PRDIV0 Va PRDIV0 Va
    502          *********************************************
    503          00000  1  01000   9 10000  17 11000  25
    504          00001  2  01001  10 10001  18 11001  Reserved
    505          00010  3  01010  11 10010  19 11010  Reserved
    506          00011  4  01011  12 10011  20 11011  Reserved
    507          00100  5  01100  13 10100  21 11100  Reserved
    508          00101  6  01101  14 10101  22 11101  Reserved
    509          00110  7  01110  15 10110  23 11110  Reserved
    510          00111  8  01111  16 10111  24 11111  Reserved
    511          *********************************************
    512          VDIV MultiplyFactor
    513          *********************************************
    514          VDIV0 Va VDIV0 Va VDIV0 Va VDIV0 Va
    515          *********************************************
    516          00000 24 01000 32 10000 40 11000 48
    517          00001 25 01001 33 10001 41 11001 49
    518          00010 26 01010 34 10010 42 11010 50
    519          00011 27 01011 35 10011 43 11011 51
    520          00100 28 01100 36 10100 44 11100 52
    521          00101 29 01101 37 10101 45 11101 53
    522          00110 30 01110 38 10110 46 11110 54
    523          00111 31 01111 39 10111 47 11111 55
    524          *********************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   PLL_Setup
        32   -> PLL_Setup
      16   Set_SYS_DIV


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     512  PLL_Setup
      72  Set_SYS_DIV
       4  g_bus_clock
       4  g_core_clock
       4  g_flash_clock
       4  g_flexbus_clock
       8  -- Other

 
   8 bytes in section .ARM.exidx
  16 bytes in section .data
 512 bytes in section .text
  72 bytes in section .textrw
 
 584 bytes of CODE  memory
   8 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
